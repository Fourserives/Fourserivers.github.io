<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>柏林噪声实践</title>
      <link href="/2024/09/24/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/09/24/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>在Unity中，柏林噪声已经被封装好了，对应的方法是</p><p><strong>Mathf.PerlinNoise(float x,float y,float z)</strong></p><p>柏林噪声可以让变化更加的平滑而不会显得很突兀，以直线的变化轨迹来看：</p><p><img src="/./../images/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/image-20240924194101310.png" alt="image-20240924194101310"></p><p>第一条线是不使用柏林噪声的曲线变化度，第二条线则是使用柏林噪声的曲线，两者对比很清晰地看得出来变化的幅度很丝滑，不会特别突兀</p><h1 id="场景绘制"><a href="#场景绘制" class="headerlink" title="场景绘制"></a>场景绘制</h1><h2 id="物体的构建"><a href="#物体的构建" class="headerlink" title="物体的构建"></a>物体的构建</h2><p>在Unity中，每个物体本质上都是要通过网格来绘制的，而涉及到网格的重要三部分：</p><ul><li><strong>Mesh</strong> 通过网格绘制</li><li><strong>MeshFilter(网格过滤器)</strong> 持有Mesh的引用</li><li><strong>MeshRenderer(网格渲染器)</strong> 把材质绑定到网格上</li></ul><p>然后是物体的材质，材质通常包含了纹理，shader</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建网格后，要创建材质</span></span><br><span class="line">meshRenderer.material = meshMaterial;</span><br></pre></td></tr></table></figure><p>材质正常情况下就是绑定在meshRenderer(网格渲染器)下，对应的该渲染器下绑定的材质可以有多个</p><p><img src="/./../images/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/image-20240924201343947.png" alt="image-20240924201343947"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>角色3C</title>
      <link href="/2024/08/19/%E8%A7%92%E8%89%B23C/"/>
      <url>/2024/08/19/%E8%A7%92%E8%89%B23C/</url>
      
        <content type="html"><![CDATA[<h1 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h1><p><strong><code>Animator</code>组件</strong>的属性：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240824163043739.png" alt="image-20240824163043739"></p><p><code>Update Mode</code>指的是动画的刷新模式</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240824163121493.png" alt="image-20240824163121493"></p><p><code>Normal</code>：相当于Update，帧率同步，每帧刷新一次</p><p><code>Animate Physics</code>：相当于FixUpdate，物理更新</p><p><code>Unscaled Time</code>：相当于Update，但是这个模式下会忽略当前的时间尺度Time Scale</p><p>更加具体的表现可以参照视频：<a href="https://www.bilibili.com/video/BV1x44y1e7Ro">https://www.bilibili.com/video/BV1x44y1e7Ro</a></p><p><strong><code>Animation</code>动画</strong>的属性：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240819210226396.png" alt="image-20240819210226396"></p><p><code>Motion Time</code>表示的是播放的动画特定的帧(0 - 1)</p><p><code>Cycle Offset</code>表示的是提前量(0 - 1)</p><p><strong>区别在于：</strong></p><p>Motion Time对应的是播放此时特定的帧，0表示初始，1表示结束，如果0.5，则动画此时显示的是整个动画一半位置的表现</p><p>Cycle Offset对应的是提前量，0表示没有提前，1表示提前到结束，如果0.5，则动画此时从整个动画一半位置开始播放(相当于动画最开始都是默认从0帧开始，现在变成从0.5开始)</p><p> <code>Foot IK</code>对应的讲解详细参考：<a href="https://www.bilibili.com/video/BV1v3411e7am">https://www.bilibili.com/video/BV1v3411e7am</a></p><p><code>Write Defaults</code>的详解参考：<a href="https://www.bilibili.com/video/BV1WL411c7mK">https://www.bilibili.com/video/BV1WL411c7mK</a></p><p><a href="https://www.cnblogs.com/Esfog/p/Unity_WriteDefaults.html">https://www.cnblogs.com/Esfog/p/Unity_WriteDefaults.html</a> <a href="https://blog.csdn.net/yjy99yjy999/article/details/82730948">https://blog.csdn.net/yjy99yjy999/article/details/82730948</a></p><p>PS：Write Defaults 该属性值在我们做动画或者使用状态机的时候，最好将其关闭！</p><h1 id="动画状态"><a href="#动画状态" class="headerlink" title="动画状态"></a>动画状态</h1><p>动画状态的切换时，从A动画切换到B动画可以有多条连线：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821172749614.png" alt="image-20240821172749614"></p><p>多条连线也就意味着从A动画可以有不同情况下会切换为B动画，在Inspector窗口下可以看到当前动画连线的有：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821172849447.png" alt="image-20240821172849447"></p><p>PS：如果选择的是某个动画，我们可以看到<code>Transitions</code>下的多条连线，且此时可以调整它们的顺序；而如果选择的是A到B之间的连线，那么此时我们不可以调整它们的顺序</p><p>如果从A动画到B动画上会有不同的连线，这时候就要考虑到动画切换有关的内容了</p><p>如果我们要从A动画切换到B动画，可以注意到<code>Transitions</code>上的顺序以及后边的内容，后边两个标签分别表示的是：</p><p><code>Solo</code>：勾选上的优先选择</p><p><code>Mute</code>：勾选上的永远不会使用</p><p>而多条连线的动画播放使用的顺序就是：</p><ol><li><p>优先考虑勾选了<code>Solo</code>的几条分支</p><p>a. 如果有多条，那么按照Transitions的顺序，哪个条件先满足了先使用哪条</p></li><li><p>其次考虑没有勾选<code>Solo</code>以及<code>Mute</code>的几条分支</p><p>a. 如果有多条，那么按照Transitions的顺序，哪个条件先满足了先使用哪条</p></li></ol><h2 id="动画状态过渡中断"><a href="#动画状态过渡中断" class="headerlink" title="动画状态过渡中断"></a>动画状态过渡中断</h2><p>一般会有的运用场景，若身体动画和面部动画是分开的一层，此时如果身体动画或者面部动画切换到对应状态下的动画，但是另外一个动画却还没播放对应状态下要使用的话，此时就需要进行动画状态的过渡或者中断：</p><p>面部A → 面部B → 面部C</p><p>身体A → 身体B → 身体C </p><p>若从A到C动画，此时身体A→B准备到C了，而面部动画刚从A→B，这时候就要开始进行中断，从而达到身体C动画播放的同时面部也是播放的C动画</p><p>动画状态过渡中断主要看动画连线部分的<code>Interruption Source</code>标签</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821174941783.png" alt="image-20240821174941783"></p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821175204145.png" alt="image-20240821175204145"></p><ol><li><strong>Current State</strong></li></ol><p>选择该选项后意味着此时动画切换允许被<strong>部分&#x2F;全部</strong>动画打断，当我们启用了该选项后，此时下方对应的<code>Ordered Interruption</code>也可以被勾选上，它表示的意思是<strong>是否按顺序来允许其动画可以被打断</strong></p><p>如果没有勾选上，那么此时该动画可以被任何情况下该动画连接其他动画而被打断</p><p>如果勾选上，那么此时动画根据<code>Transitions</code> 下的顺序来被打断</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821175554129.png" alt="image-20240821175554129"></p><p>如图，如果此时勾选上了Ordered标签，在Walk → B的切换情况下，此时Walk → B上方的三个动画切换都可以打断它，但是Walk → C的动画切换不可以打断它</p><ol start="2"><li><strong>Next State</strong></li></ol><p>选择该选项表示的是此时动画切换允许被要切换到的动画对应连接的其他动画切换的时候进行打断，以下边例子举例来说：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240821202704608.png" alt="image-20240821202704608"></p><p>当Walk → GrilIdle过渡的时候，这时候可以通过GrilIdle → C 或者 GrilIdle → D这两个动画切换来打断，从而变成了Walk → C 或者 Walk → D</p><p>当然，如果此时GrilIdle → C &#x2F; D 的条件都同时触发的话，仍然会按照在<code>Transitions</code>下的动画切换顺序来进行打断</p><ol start="3"><li><strong>Current State Then Next State</strong></li><li><strong>Next State Then Current State</strong></li></ol><p>这两个对应的状态过渡中断就是上边两个的结合体，区别就是谁优先级高先考虑谁</p><p>在测试动画会发现一个新的问题，就是实际位移和动画表现的位移不同步，所以接下来可以采用<code>Root Motion</code>动画来解决这个问题</p><h1 id="Root-Motion动画"><a href="#Root-Motion动画" class="headerlink" title="Root Motion动画"></a>Root Motion动画</h1><p>Root Motion动画一般是<strong>自带位移</strong>的动画，当角色使用动画控制器绑定对应的动画并使用，启用<code>Apply Root Motion</code>，这时候如果播放动画，那么角色会根据该动画也自动完成一些位移操作</p><p>使用Root Motion可以解决脚本编译要实现的效果与动画效果不一致(比如：出现脚底抹油一样的效果)</p><p>但是要注意的是，使用Root Motion会出现一些其他问题：</p><p>走直线的动画会发生偏移，走路可能会让脚陷下去一些，使用混合树时表现跟脚本要实现的效果不一致等等</p><p>这是因为Root Motion动画与其他动画的区别是：</p><p><strong>动画文件会直接修改每一帧里游戏对象的坐标值和角度值，而root motion则通过 相对位移和转角 来移动游戏对象</strong></p><p>同样的，如果我们在当前绑定了Root Motion动画的对象上挂载了包含有<code>OnAnimatorMove()</code>方法的脚本，此时的<code>Apply Root Motion</code>便不再被使用，而是把控制权交由该方法来实现：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240822105535687.png" alt="image-20240822105535687"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnAnimatorMove</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//动画逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Root Motion机制的讲解可以参考：<a href="https://www.bilibili.com/video/BV1kZ4y1B7Tc">https://www.bilibili.com/video/BV1kZ4y1B7Tc</a></p><h2 id="Root-Motion基础设置"><a href="#Root-Motion基础设置" class="headerlink" title="Root Motion基础设置"></a>Root Motion基础设置</h2><p><img src="/./../../../typora-images/image-20240823105542355-1724381907586-3.png" alt="image-20240823105542355"></p><p>绿色和红色分别表示当前动画如果勾选上Bake Into Pose不会&#x2F;会导致不好的效果</p><ul><li><strong>Root Transform Rotation</strong></li></ul><p><code>Bake Into Pose</code>：</p><p>如果勾选了，其表示<strong>不要将骨骼节点的旋转当做root motion的一部分来处理，而是将其当做普通动画进行处理</strong></p><p>简而言之就是让骨骼不会跟随动画来进行移动，从而导致整体动画产生的位移发生偏移</p><p>也可以通过：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上一帧的相对旋转量</span></span><br><span class="line">animator.deltaRotation.eulerAngles;</span><br><span class="line"><span class="comment">//上一帧的相对位移量</span></span><br><span class="line">animator.deltaPosition;</span><br></pre></td></tr></table></figure><p>测试如果我们勾选上该选项后的偏移量以及位移量的变化，就可以发现其骨骼不发生变化之后，旋转量也会一直保持不变</p><p><strong>总结：要不要勾选这个选项取决于我们需不需要动画来驱动游戏对象的旋转，而至于能不能勾选，则要参考后边的红色或者绿色提示</strong></p><p><code>Based Upon</code>：</p><p>这里指游戏对象在动画开始时对准的方向是哪里</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240823111311947.png" alt="image-20240823111311947"></p><p>其中默认的Body Orientation指的是让游戏对象在动画开始时对准根骨骼节点的指向方向，<strong>一般来说不准</strong></p><p>而Original指的是让游戏对象在动画开始时对准动画最初的方向<strong>，一般来说使用这个</strong></p><p>当然，如果发现都不准确的话，则可以通过Offset来调整偏移量</p><ul><li><strong>Root Transform Rotation(Y)</strong></li></ul><p><code>Bake Into Pose</code>：</p><p>勾选表示不要将根骨骼节点在垂直方向的位移当做root motion的一部分来处理</p><p>同理，另外一个对应的就是X和Z轴方向上的root motion处理</p><p><strong>PS：虽然可以在Root Motion内通过Unity本身自带的功能来调整，但是在实际应用中最好还是使用<code>OnAnimatorMove()</code>方法来调整</strong></p><h2 id="Humanoid动画中的Root-Motion"><a href="#Humanoid动画中的Root-Motion" class="headerlink" title="Humanoid动画中的Root Motion"></a>Humanoid动画中的Root Motion</h2><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240823105555534.png" alt="image-20240823105555534"></p><p><code>Body Orientation</code>指的是基于根骨骼的方向</p><p>另外一个是Humanoid动画如果适配到Blend Tree，比如移动动画的切换，在通过特定数值（比如：速度值）来切换动画的话，最合理的参数应该是动画自己的速度，所以它的<strong>上下限匝值</strong>可以通过Unity里边直接让其自动生成：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240824153157690.png" alt="image-20240824153157690"></p><p>根据动画在不同方向上的位移速度，比如Vector3对应的三个方向来让其自动计算匝值，以图中举例，在使用这三个动画，为其自动生成出来的范围就是 -1.2826 —— 0.93</p><p>而另外一个<code>Adjuist Time Scale</code>是来解决不同动画的播放速度问题的，如果遇到动画播放效果不一致的话，就可以通过它来为我们自动计算动画播放速度，从而达到动画一致的表现效果</p><p><strong>PS：如果要让不同模型的角色使用同个状态机的话，会因为模型骨骼不一致，比如大体型人模与小体型人模的骨骼不同，本质上骨骼scale也不同，而Root Motion动画的位移是与scale有关的，所以会导致同样配置下动作表现会完全不同（比如直线动画走，一个快一个慢），这时候就要通过<code>/= animator.humanScale</code>的方式来获得真正意义上的相同速度</strong></p><p>eg：在速度speed都为1的情况下，第一个模型的scale如果是100%，那么此时动画的位移速度也是1:1的情况，而如果第二个模型的scale是68%的话，那么此时动画的位移速度如果要一致的情况下，就要 1 &#x2F; 0.68 得到真正相同的速度</p><h2 id="Root-Motion结合Rigid-Body完成自定义速度"><a href="#Root-Motion结合Rigid-Body完成自定义速度" class="headerlink" title="Root Motion结合Rigid Body完成自定义速度"></a>Root Motion结合Rigid Body完成自定义速度</h2><p>在前边我们通过Root Motion动画实现了动画与实际速度不一致(比如：脚底打滑)的问题，然后我们通过Root Motion动画来自己操控速度，这与实际开发并不符合，所以我们仍然要用回<code>OnAnimationMove()</code>方法来自己调控动画，而Root Motion只拿来解决动画与实际不一致的问题就行</p><p>这时候就要通过Rigid Body组件来完成我们的自定义移动需求了</p><p>为模型添加了<code>Rigid Body</code>组件后，由于接下来要通过它来让角色进行移动等操作，这通常都是建立在每一帧调用一次对应的操作，所以这时要回到<code>Animator</code>组件上并且把<code>Update Mode</code>选择为<code>Animate Physics</code>，同时Rigid Body组件也要相应的锁定：</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240827155718532.png" alt="image-20240827155718532"></p><p>再为其添加碰撞体，然后我们便可以通过Rigid Body来完成自定义的速度设置了，核心语句：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rig.velocity = animator.velocity;</span><br></pre></td></tr></table></figure><h1 id="Layer完成多动画组合"><a href="#Layer完成多动画组合" class="headerlink" title="Layer完成多动画组合"></a>Layer完成多动画组合</h1><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240827160150013.png" alt="image-20240827160150013"></p><p>**<code>Weight</code>**表示的是该层级动画的权重【0 - 1】，0就表示不起作用</p><p>**<code>Mask</code>**表示的是蒙版，作用是可以选择对应模型，在当前层级播放的动画对哪个部位会产生影响</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240827160656082.png" alt="image-20240827160656082"></p><p>绿色表示受影响，红色表示不受影响，这里使用的是Humanoid选项，如果要更细致一些的可以选择下边的Transform选项，可以精确到骨骼</p><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240827160836736.png" alt="image-20240827160836736"></p><p>**<code>Blending</code>**属性则有两个选项，分别对应了 覆盖 和 添加</p><p>覆盖指的是当前层级的动画覆盖上一层级的动画，添加指的是当前层级的动画和上一级动画混合起来</p><ul><li><p><strong>覆盖</strong></p><p>eg：角色持不同武器；角色表情控制等等，通常通过覆盖的方式来进行</p></li><li><p><strong>添加</strong></p><p>eg：角色疲惫状态；异常状态等，通常通过添加的方式来进行混合</p></li></ul><p><strong>PS：动画层级比较多的情况下，从上往下对应的下标为0-n，跟数组下标一样</strong></p><p>通常情况下，可以通过<code>animator.GetLayerIndex(&quot;层级名字&quot;)</code>来获得该层级的序号，然后再后续通过像animater.SetLayerWeight(层级序号，数值)来更改层级的权重值等等</p><p><strong>小知识：</strong>Mathf.Clamp(变量名，数值最左值，数值最右值)，表示把变量的值限制在一个区间内</p><p>**<code>Sync</code>**属性表示的是同步，意思就是两个层级是同步的，这里的应用可以详细参考：<a href="https://www.bilibili.com/video/BV1AF411M7eK">https://www.bilibili.com/video/BV1AF411M7eK</a></p><p>同步要注意一个问题就是，相同的动画片段可能播放的时长是不一样的，这会不会导致动画播放不一致？其实不会，因为unity会把使用同步的层级与被同步的对应的动画进行缩放，从而达到一样长的效果</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UGUI优化项</title>
      <link href="/2024/08/08/UGUI%E4%BC%98%E5%8C%96%E9%A1%B9/"/>
      <url>/2024/08/08/UGUI%E4%BC%98%E5%8C%96%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动背包存储大量数据"><a href="#滑动背包存储大量数据" class="headerlink" title="滑动背包存储大量数据"></a>滑动背包存储大量数据</h1><p>优化前需要了解大致的步骤：</p><ol><li><strong>数据从何而来</strong></li></ol><p>单机 → json，xml，二进制文件等</p><p>网络 → 服务器的数据库中</p><ol start="2"><li><strong>可视范围</strong></li></ol><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240808100946915.png" alt="image-20240808100946915"></p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240808104045044.png" alt="image-20240808104045044"></p><p>当前可视范围就为 ： <strong>Y  — Y + H</strong> (H是Viewport的高度)</p><p>此时起始位置就为 Y ，结束位置就为 Y + H</p><ol start="3"><li><strong>获取哪些道具应该被显示</strong></li></ol><p>假设一个格子的大小为 60 * 60，那么就可以计算当前<strong>可视范围的起始位置对应格子的索引值</strong>就为：</p><p><strong>可视范围的起始位置Y &#x2F; 一个格子的高 → 起始显示的是哪一行 * 一行有多少个格子 &#x3D; 起始位置显示的索引值</strong></p><p>eg： 90 &#x2F; 60 &#x3D; 1 * 3 &#x3D; 3，此时可视范围的第一个格子对应的索引下标就是 3</p><p>结束位置的计算为：</p><p><strong>可视范围的结束位置Y &#x2F; 一个格子的高 → 结束位置显示的是哪一行 * 一行有多少个格子 + (一行格子数 - 1) &#x3D; 结束位置显示的索引值</strong></p><p>eg：290 &#x2F; 60 &#x3D; 4 * 3 + (3 - 1) &#x3D; 14，此时可视范围的最后一个格子对应的索引下标就是14</p><ol start="4"><li><strong>记录当前显示的内容</strong></li></ol><p>需要一个容器来记录当前显示的对象信息，目的是每次改变时候都进行判断，移除视野外的对象(不在可视范围内[Y-Y+H])，如果该容器没有[Y,Y+H]算出来的索引值的格子，创建它</p><h2 id="步骤实现"><a href="#步骤实现" class="headerlink" title="步骤实现"></a>步骤实现</h2><p>背包的实现可以抽象为一个管理器，一个视觉刷新，一个背包格子共三个类来实现目前的内容需要</p><p>若要进行数据库调用数据，资源加载等则还要另起其他对应的类来分别实现其他功能业务</p><p>在可视范围的选定中，通常是对应我们定义的滑动(Scroll View)下<code>RectTransform</code>组件，需要注意的是该组件的Position和实际在地图上的坐标是不同的，所以在进行UGUI窗口获取Y值的时候要采用的是<code>anchoredPosition.y</code>属性来对应：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> minIndex = (<span class="built_in">int</span>)(content.anchoredPosition.y / gridHeight)*<span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span> maxIndex = (<span class="built_in">int</span>)(Mathf.CeilToInt((content.anchoredPosition.y + viewHeight)/gridHeight) * <span class="number">3</span>) + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>由此得到每次视角滑动时的范围数值变化，将可视范围定义后便可以通过物品编号来对应创建各个格子对象，该部分可以考虑两个方面的内容优化：</p><ul><li>格子对象的丢弃与重复使用通过缓存池来进行</li><li>格子创建考虑异步加载方式进行</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建指定索引范围内的格子        </span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = minIndex; i &lt;= maxIndex; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(showItems.ContainsKey(i))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> index = i;</span><br><span class="line">        <span class="comment">//占位</span></span><br><span class="line">        showItems.Add(index,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//通过异步加载创建格子</span></span><br><span class="line">        FoolManager.GetInstance().AsyncGetFool(monoBehaviour,<span class="string">&quot;Prefab/GridItem&quot;</span>,(obj) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//格子创建出来后要准备的工作</span></span><br><span class="line">            <span class="comment">//1.设置父对象</span></span><br><span class="line">            obj.transform.SetParent(content);</span><br><span class="line">            <span class="comment">//2.重置相对缩放大小</span></span><br><span class="line">            obj.transform.localPosition = Vector3.one;</span><br><span class="line">            <span class="comment">//3.更新格子信息</span></span><br><span class="line">            obj.GetComponent&lt;BagItem&gt;().InitInfo(BagManager.GetInstance().items[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否有该位置</span></span><br><span class="line">            <span class="keyword">if</span>(showItems.ContainsKey(index))</span><br><span class="line">            &#123;</span><br><span class="line">                showItems[index] = obj;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//避免因为时序问题(用户滑动太快)导致出现的错误</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                FoolManager.GetInstance().PushFool(<span class="string">&quot;Prefab/GridItem&quot;</span>,obj);</span><br><span class="line">        &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步加载的方式可以通过不同形式的资源管理器来实现，根据项目的不同可以选择Resources或者AB包资源管理的形式来进行资源内格子对象的生成与创建</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓存池</title>
      <link href="/2024/08/07/%E7%BC%93%E5%AD%98%E6%B1%A0/"/>
      <url>/2024/08/07/%E7%BC%93%E5%AD%98%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="缓存池初版设计"><a href="#缓存池初版设计" class="headerlink" title="缓存池初版设计"></a>缓存池初版设计</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存池</span></span><br><span class="line">  <span class="comment">//对应每种类型(键)  存储的对象(放进缓存池中的内容)</span></span><br><span class="line">  <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>,Queue&lt;GameObject&gt;&gt; fools = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> GameObject proObj;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GameObject <span class="title">GetFool</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      GameObject obj = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span>(fools.ContainsKey(name) &amp;&amp; fools[name].Count &gt; <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          obj = fools[name].Dequeue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));</span><br><span class="line">          obj.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">      obj.transform.parent = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushFool</span>(<span class="params"><span class="built_in">string</span> name,GameObject obj</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(proObj == <span class="literal">null</span>)</span><br><span class="line">          proObj = <span class="keyword">new</span> GameObject(<span class="string">&quot;Pool&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      obj.transform.parent = proObj.transform;</span><br><span class="line">      obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">if</span>(fools.ContainsKey(name))</span><br><span class="line">      &#123;</span><br><span class="line">          fools[name].Enqueue(obj);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">          Queue&lt;GameObject&gt; que = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line">          que.Enqueue(obj);</span><br><span class="line">          fools.Add(name, que);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="通过面向对象进行优化"><a href="#通过面向对象进行优化" class="headerlink" title="通过面向对象进行优化"></a>通过面向对象进行优化</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存池中的单个容器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对象挂载的父节点</span></span><br><span class="line">    <span class="keyword">public</span> GameObject fatherObj;</span><br><span class="line">    <span class="comment">//容器</span></span><br><span class="line">    <span class="keyword">public</span> Queue&lt;GameObject&gt; poolList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PoolData</span>(<span class="params">GameObject obj,GameObject proObj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给每个容器创建一个父对象，并且作为整个pool(相当于衣柜)对象的子物体</span></span><br><span class="line">        fatherObj = <span class="keyword">new</span> GameObject(obj.name);</span><br><span class="line">        fatherObj.transform.parent = proObj.transform;</span><br><span class="line">        poolList = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line">        PushPool(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushPool</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        poolList.Enqueue(obj);</span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        obj.transform.parent = fatherObj.transform;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">GetPool</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameObject obj = poolList.Dequeue();</span><br><span class="line">        obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        obj.transform.parent = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoolManager</span> : <span class="title">BaseManager</span>&lt;<span class="title">FoolManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//缓存池</span></span><br><span class="line">    <span class="comment">//对应每种类型(键)  存储的对象(放进缓存池中的内容)</span></span><br><span class="line">    <span class="keyword">public</span> Dictionary&lt;<span class="built_in">string</span>,PoolData&gt; fools = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, PoolData&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject proObj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">GetFool</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        GameObject obj = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(fools.ContainsKey(name) &amp;&amp; fools[name].poolList.Count &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            obj = fools[name].poolList.Dequeue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            obj = GameObject.Instantiate(Resources.Load&lt;GameObject&gt;(name));</span><br><span class="line">            obj.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        obj.transform.parent = <span class="literal">null</span>;</span><br><span class="line">                  </span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushFool</span>(<span class="params"><span class="built_in">string</span> name,GameObject obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(proObj == <span class="literal">null</span>)</span><br><span class="line">            proObj = <span class="keyword">new</span> GameObject(<span class="string">&quot;Pool&quot;</span>);</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(fools.ContainsKey(name))</span><br><span class="line">        &#123;</span><br><span class="line">            fools[name].PushPool(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Queue&lt;GameObject&gt; que = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line">            que.Enqueue(obj);</span><br><span class="line">            fools.Add(name, <span class="keyword">new</span> PoolData(obj,proObj));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        fools.Clear();</span><br><span class="line">        proObj = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="异步加载结合缓存池"><a href="#异步加载结合缓存池" class="headerlink" title="异步加载结合缓存池"></a>异步加载结合缓存池</h1><p>以其中某个业务段举例，在进行异步加载时可以通过定义资源管理器(Resources资源加载方式或者AB包资源加载方式)，在需要进行异步加载的时候进行调用，同时塞进缓存池中</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = minIndex; i &lt;= maxIndex; i++)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(showItems.ContainsKey(i))</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">int</span> index = i;</span><br><span class="line">              <span class="comment">//占位</span></span><br><span class="line">              showItems.Add(index,<span class="literal">null</span>);</span><br><span class="line">              <span class="comment">//通过异步加载创建格子</span></span><br><span class="line">              FoolManager.GetInstance().AsyncGetFool(monoBehaviour,<span class="string">&quot;Prefab/GridItem&quot;</span>,(obj) =&gt;</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="comment">//格子创建出来后要准备的工作</span></span><br><span class="line">                  <span class="comment">//1.设置父对象</span></span><br><span class="line">                  obj.transform.SetParent(content);</span><br><span class="line">                  <span class="comment">//2.重置相对缩放大小</span></span><br><span class="line">                  obj.transform.localPosition = Vector3.one;</span><br><span class="line">                  <span class="comment">//3.更新格子信息</span></span><br><span class="line">                  obj.GetComponent&lt;BagItem&gt;().InitInfo(BagManager.GetInstance().items[i]);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//判断是否有该位置</span></span><br><span class="line">                  <span class="keyword">if</span>(showItems.ContainsKey(index))</span><br><span class="line">                  &#123;</span><br><span class="line">                      showItems[index] = obj;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//避免因为时序问题(用户滑动太快)导致出现的错误</span></span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      FoolManager.GetInstance().PushFool(<span class="string">&quot;Prefab/GridItem&quot;</span>,obj);</span><br><span class="line">              &#125;</span><br><span class="line">              );</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（六）</title>
      <link href="/2024/07/22/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2024/07/22/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AB包的上传与下载"><a href="#AB包的上传与下载" class="headerlink" title="AB包的上传与下载"></a>AB包的上传与下载</h1><p>回顾一下热更新的流程：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240722140558845.png" alt="image-20240722140558845"></p><h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><p>在完成AB包的打包操作之后，接下来需要做的流程就是去<strong>获取AB包文件的MD5码</strong></p><h2 id="MD5码"><a href="#MD5码" class="headerlink" title="MD5码"></a>MD5码</h2><p>概述：MD5是一种广泛使用的密码散列函数，它可以生成出一个128为(16字节)的散列值，用于确保信息的完整一致性</p><p>当我们将数据通过MD5算法计算过后，不管传入的数据有多大，都会生成一个固定长度的信息摘要值</p><p><strong>MD5算法的特点：</strong></p><p>相同的数据每次经过MD5算法计算后的结果都会是一样的</p><p>如果数据发生变化，则MD5码也会发生变化</p><p>所以，<strong>MD5码可以作为文件的唯一标识，通过它来判断文件内容是否发生了变化</strong></p><p><strong>把文件流信息转换为MD5码的流程为：</strong></p><ol><li><p>根据文件路径，获取文件的流信息 (FileStream类)</p></li><li><p>利用md5对象根据流信息，计算出MD5码（字节数组形式） (MD5类)</p></li><li><p>将字节数组形式的MD5码转为 16进制字符串 (StringBuilder类)</p></li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">string</span> <span class="title">getMD5</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//将文件以流的形式打开</span></span><br><span class="line">      <span class="keyword">using</span> (FileStream file = <span class="keyword">new</span> FileStream(path,FileMode.Open))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//声明一个MD5对象，用于生成MD5码</span></span><br><span class="line">          MD5 md5 = <span class="keyword">new</span> MD5CryptoServiceProvider();</span><br><span class="line">          <span class="comment">//通过该类自带的方法获取 16个字节 数组</span></span><br><span class="line">          <span class="built_in">byte</span>[] md5Info = md5.ComputeHash(file);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//关闭文件流</span></span><br><span class="line">          file.Close();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//把16个字节转换为 十六进制 拼接为字符串，为了减少md5码的长度</span></span><br><span class="line">          StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">          <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;md5Info.Length;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              sb.Append(md5Info[i].ToString(<span class="string">&quot;x2&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> sb.ToString();    </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="生成AB包资源对比文件"><a href="#生成AB包资源对比文件" class="headerlink" title="生成AB包资源对比文件"></a>生成AB包资源对比文件</h2><p>AB包打包后，我们需要的AB包文件相当于是没有后缀名的那些文件</p><p>首先定义一个工具类用于创建对比文件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;AB包工具/创建对比文件&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CreateABCompareFile</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取文件夹信息</span></span><br><span class="line">        DirectoryInfo directory = Directory.CreateDirectory(Application.dataPath + <span class="string">&quot;/ArtRes/AB/PC/&quot;</span>);</span><br><span class="line">        <span class="comment">//获取文件夹下的所有文件信息</span></span><br><span class="line">        FileInfo[] fileInfos = directory.GetFiles();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于存储信息的字符串</span></span><br><span class="line">        <span class="built_in">string</span> abCompareInfo = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (FileInfo info <span class="keyword">in</span> fileInfos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Debug.Log(info.Name);      文件名</span></span><br><span class="line"><span class="comment">            Debug.Log(info.FullName);  文件路径</span></span><br><span class="line"><span class="comment">            Debug.Log(info.Extension); 文件后缀</span></span><br><span class="line"><span class="comment">            Debug.Log(info.Length);    文件大小</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//只要没有后缀的，没有后缀的才是我们要的AB包</span></span><br><span class="line">            <span class="keyword">if</span>(info.Extension == <span class="string">&quot;&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                abCompareInfo += info.Name + <span class="string">&quot; &quot;</span> + info.Length + <span class="string">&quot; &quot;</span> + getMD5(info.FullName);</span><br><span class="line">                <span class="comment">//用一个分隔符分开不同文件之间的信息</span></span><br><span class="line">                abCompareInfo += <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        abCompareInfo = abCompareInfo.Substring(<span class="number">0</span>,abCompareInfo.Length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存储拼接好的AB包资源信息</span></span><br><span class="line">        File.WriteAllText(Application.dataPath + <span class="string">&quot;/ArtRes/AB/PC/ABCompareInfo.txt&quot;</span>,abCompareInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//刷新编辑器</span></span><br><span class="line">        AssetDatabase.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">getMD5</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将文件以流的形式打开</span></span><br><span class="line">        <span class="keyword">using</span> (FileStream file = <span class="keyword">new</span> FileStream(path,FileMode.Open))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//声明一个MD5对象，用于生成MD5码</span></span><br><span class="line">            MD5 md5 = <span class="keyword">new</span> MD5CryptoServiceProvider();</span><br><span class="line">            <span class="comment">//通过该类自带的方法获取 16个字节 数组</span></span><br><span class="line">            <span class="built_in">byte</span>[] md5Info = md5.ComputeHash(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//关闭文件流</span></span><br><span class="line">            file.Close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把16个字节转换为 十六进制 拼接为字符串，为了减少md5码的长度</span></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;md5Info.Length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.Append(md5Info[i].ToString(<span class="string">&quot;x2&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sb.ToString();    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="搭建FTP服务器"><a href="#搭建FTP服务器" class="headerlink" title="搭建FTP服务器"></a>搭建FTP服务器</h2><p>前提：先安装好对应的ftp构建工具，这里采用的是Serv-ftp</p><p>在安装完成并启动后，第一次就会让你注册一个用户，相当于用于后续要访问ftp服务器的账户</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240724173800045.png" alt="image-20240724173800045"></p><p>测试阶段填写登录ID即可，下一步是填写密码，这里要注意的是，一般我们要划分至少两个身份的用户，一个是到时候完成上传工作，一个是完成下载操作，其中有一个是可以不用密码，所以密码可以根据不同用户来选择是否为空</p><p>再下一步是选择我们要存储AB包文件的地址：这里测试就先填本地的文件存储地址即可</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240724174024033.png" alt="image-20240724174024033"></p><p>最后是设置该用户的权限：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240724174052434.png" alt="image-20240724174052434"></p><p>这里分别对应的就是上传和下载的两个用户应该具备的条件，上传的话意味着还要可写，所以要选择完全访问，如果是匿名下载的话，那就只要访问即可，就可以选只读选项，最后就完成了ftp服务器的搭建了</p><p>接下来就是测试ftp服务器能否可用，新版本的话可以直接在谷歌浏览器通过</p><p><code>http://ip</code>直接连接上去，然后使用账号密码登录就可以看到服务器上存储的内容了：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240724174259873.png" alt="image-20240724174259873"></p><h2 id="上传AB包和资源比对文件"><a href="#上传AB包和资源比对文件" class="headerlink" title="上传AB包和资源比对文件"></a>上传AB包和资源比对文件</h2><ol><li><p>读取文件夹信息</p><p>1.1 获取文件夹下所有文件信息</p><p>1.2 找到目标信息</p></li><li><p>上传文件(路径 ＋ 文件名)</p></li></ol><p>根据使用的服务器类型不同，上传文件的方法也不一样，这里以ftp本地服务器作为例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UploadAllABFile</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">        <span class="comment">//获取文件夹信息</span></span><br><span class="line">       DirectoryInfo directory = Directory.CreateDirectory(Application.dataPath + <span class="string">&quot;/ArtRes/AB/PC/&quot;</span>);</span><br><span class="line">       <span class="comment">//获取文件夹下的所有文件信息</span></span><br><span class="line">       FileInfo[] fileInfos = directory.GetFiles();</span><br><span class="line">       <span class="comment">// foreach (FileInfo fileInfo in fileInfos)</span></span><br><span class="line">       <span class="comment">// &#123;</span></span><br><span class="line">       <span class="comment">//     Debug.Log(fileInfo.Name);</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">foreach</span> (FileInfo info <span class="keyword">in</span> fileInfos)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//没有后缀的才是我们要的AB包的信息</span></span><br><span class="line">           <span class="comment">//同样需要获取的还有 资源对比文件(格式为txt)</span></span><br><span class="line">           <span class="keyword">if</span>(info.Extension == <span class="string">&quot;&quot;</span> || info.Extension == <span class="string">&quot;.txt&quot;</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//上传文件          路径信息 文件名</span></span><br><span class="line">               FtpUploadFile(info.FullName,info.Name);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           Debug.Log(info.Name);      文件名</span></span><br><span class="line"><span class="comment">           Debug.Log(info.FullName);  文件路径</span></span><br><span class="line"><span class="comment">           Debug.Log(info.Extension); 文件后缀</span></span><br><span class="line"><span class="comment">           Debug.Log(info.Length);    文件大小</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">async</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">FtpUploadFile</span>(<span class="params"><span class="built_in">string</span> filePath,<span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">await</span> Task.Run(() =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">try</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//1.创建一个ftp链接用于上传</span></span><br><span class="line">               FtpWebRequest req = FtpWebRequest.Create(<span class="keyword">new</span> Uri(<span class="string">&quot;http://192.168.0.105/AB/PC/&quot;</span>+fileName)) <span class="keyword">as</span> FtpWebRequest;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//2.设置一个通信凭证</span></span><br><span class="line">               NetworkCredential n = <span class="keyword">new</span> NetworkCredential(<span class="string">&quot;Chen&quot;</span>, <span class="string">&quot;Chen123&quot;</span>);</span><br><span class="line">               req.Credentials = n;</span><br><span class="line">               <span class="comment">//3.其他设置</span></span><br><span class="line">               <span class="comment">// 设置代理为null</span></span><br><span class="line">               req.Proxy = <span class="literal">null</span>;</span><br><span class="line">               <span class="comment">// 请求完毕后 是否要关闭控制链接</span></span><br><span class="line">               req.KeepAlive = <span class="literal">false</span>;</span><br><span class="line">               <span class="comment">// 操作命令 —— 上传</span></span><br><span class="line">               req.Method = WebRequestMethods.Ftp.UploadFile;</span><br><span class="line">               <span class="comment">// 指定传输的类型 2进制</span></span><br><span class="line">               req.UseBinary = <span class="literal">true</span>;</span><br><span class="line">               <span class="comment">//4.上传文件</span></span><br><span class="line">               <span class="comment">// ftp的流对象</span></span><br><span class="line">               Stream upLoadStream = req.GetRequestStream();</span><br><span class="line">               <span class="comment">// 读取文件信息 写入该流对象</span></span><br><span class="line">               <span class="keyword">using</span> (FileStream file = File.OpenRead(filePath))</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="comment">//一点一点地上传</span></span><br><span class="line">                   <span class="built_in">byte</span>[] buffer = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">2048</span>];</span><br><span class="line">                   <span class="comment">//返回值 代表读取了多少个字节</span></span><br><span class="line">                   <span class="built_in">int</span> contentLength = file.Read(buffer, <span class="number">0</span>, buffer.Length);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">while</span>(contentLength != <span class="number">0</span>)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="comment">//写入到上传流中</span></span><br><span class="line">                       upLoadStream.Write(buffer, <span class="number">0</span>, contentLength);</span><br><span class="line">                       <span class="comment">//写完继续读</span></span><br><span class="line">                       contentLength = file.Read(buffer,<span class="number">0</span>, buffer.Length);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">//循环结束</span></span><br><span class="line">                   file.Close();</span><br><span class="line">                   upLoadStream.Close();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               Debug.Log(fileName + <span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">           &#123;</span><br><span class="line">               Debug.Log(<span class="string">&quot;上传失败&quot;</span> + ex.Message);</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">       &#125;);</span><br><span class="line">       </span><br><span class="line">   &#125;   </span><br></pre></td></tr></table></figure><p>PS：上传文件最好使用异步处理，否则上传的时候会很卡，因为一次性要传递很多文件以及排队等待上传，通过异步多线程的方式就可以达到不会有卡顿的效果</p><p>有关于异步(Async，await，task等)可以参考学习：<a href="https://www.bilibili.com/video/BV1Q14y1F7k1">https://www.bilibili.com/video/BV1Q14y1F7k1</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（五）</title>
      <link href="/2024/07/16/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2024/07/16/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="toLua"><a href="#toLua" class="headerlink" title="toLua"></a>toLua</h1><p>toLua环境配置：</p><p>包下载 <a href="https://github.com/topameng/tolua">https://github.com/topameng/tolua</a></p><p>这两个文件夹复制到Assets同级目录下</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240716140011426.png" alt="image-20240716140011426"></p><p>再将其复制丢到Assets文件夹里边</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240716140055853.png" alt="image-20240716140055853"></p><p>回到unity完成toLua的配置</p><p>toLua的重要文件为<code>CustomSetting.cs</code>,其主要作用主要是：</p><ul><li>添加需要导出的类或者委托</li><li>类加入到customTypeList中</li><li>委托加入到customDelegateList列表中</li><li>saveDir变量为导出目录</li></ul><h2 id="C-调用Lua"><a href="#C-调用Lua" class="headerlink" title="C#调用Lua"></a>C#调用Lua</h2><p>C#要想调用Lua需要一个toLua解析器(LuaState)，通过DoString方法执行Lua代码，通过DoFile和Require执行Lua脚本，在创建toLua解析器之前需要先导包<code>using LuaInterface</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用toLua提供的解析器对象执行lua代码和脚本</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化一个toLua解析器</span></span><br><span class="line">      LuaState luaState = <span class="keyword">new</span> LuaState();</span><br><span class="line">      <span class="comment">//启动解析器</span></span><br><span class="line">      luaState.Start();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//执行lua代码</span></span><br><span class="line">      luaState.DoString(<span class="string">&quot;print(&#x27;启动第一个lua内容&#x27;)&quot;</span>);</span><br><span class="line">      <span class="comment">//执行lua代码 并指明出处 方便调试时查看问题</span></span><br><span class="line">      luaState.DoString(<span class="string">&quot;print(&#x27;启动第一个lua内容&#x27;)&quot;</span>,<span class="string">&quot;L1_LuaState.cs&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//执行lua文件 通过DoFile执行</span></span><br><span class="line">      <span class="comment">//后缀.lua可加可不加</span></span><br><span class="line">      luaState.DoString(<span class="string">&quot;Main.lua&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//第二种执行lua文件的语法  不用加后缀</span></span><br><span class="line">      luaState.Require(<span class="string">&quot;Main&quot;</span>);</span><br><span class="line">      <span class="comment">//检查解析器栈顶是否为空</span></span><br><span class="line">      luaState.CheckTop();</span><br><span class="line">      <span class="comment">//销毁解析器</span></span><br><span class="line">      luaState.Dispose();</span><br><span class="line"></span><br><span class="line">      luaState = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>销毁相关一般要遵循：先CheckTop再Dispose</p><p>toLua的解析器也是一样<strong>默认会在Lua文件下查找要调用的Lua脚本</strong>(Require)，而如果Lua包下要自定义新包放入新的路径，这时候就要进行自定义解析路径：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种：如果该文件属于Lua文件夹下 可以直接加父目录</span></span><br><span class="line">      luaState.Require(<span class="string">&quot;CSharpCallLua/L2_Loader&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//第二种：通过LuaState中的方法 AddSearchPath</span></span><br><span class="line"><span class="comment">//如果是在Lua文件夹外边再定义一个新的存储要调用的Lua脚本内容，就只能用该方法</span></span><br><span class="line">      luaState.AddSearchPath(Application.dataPath + <span class="string">&quot;/Lua/CSharpCallLua&quot;</span>);</span><br><span class="line">      luaState.Require(<span class="string">&quot;L2_Loader&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="自定义解析器"><a href="#自定义解析器" class="headerlink" title="自定义解析器"></a>自定义解析器</h3><p>在实际应用开发中，如果在C#中需要通过解析器来调用我们自定义的路径下的Lua脚本，通常是默认要放在<strong>Resources包</strong>或<strong>AB包</strong>中，为了调用里边的lua脚本，就会遇到这些问题：</p><ol><li>toLua解析器默认只会从Lua文件下查找要调用的Lua脚本</li><li>通过AddSearchPath方法或调用时多加包名调用的方式会造成大量的代码调用，增加工作量</li><li>在Resources下或者AB包下的lua脚本文件一般默认后缀名都是其他类型(不允许.lua后缀)</li></ol><p>为了解决这些问题，就需要使用到自定义解析器了，在xLua中，解决这些问题的方法很简单，只要通过AddLoader方法，然后重载一下回调方法即可，而在toLua中就不一样了，toLua需要我们自行去定义一个类似于AddLoader的类来继承其方法内容 —— <strong>LuaFileUtils</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaCustomLoader</span> : <span class="title">LuaFileUtils</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重写 重定向 加载方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">ReadFile</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果要重定向解析lua的方式，只需要在该函数中重写逻辑即可</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该自定义解析器类继承了<code>LuaFileUtils</code>后，只要回到需要启动解析器的C#脚本下初始化该对象即可启用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义解析类 new了就可以用，因为父类是一个单例模式对象</span></span><br><span class="line"><span class="keyword">new</span> LuaCustomLoader();</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化一个toLua解析器</span></span><br><span class="line">      LuaState luaState = <span class="keyword">new</span> LuaState();</span><br><span class="line">      <span class="comment">//启动解析器</span></span><br><span class="line">      luaState.Start();</span><br></pre></td></tr></table></figure><p>这里只要new创建对象即可，不需要进行引用，原因就是：LuaFileUtils本身是个单例模式</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240716230724805.png" alt="image-20240716230724805"></p><p>接下来就是要重写<strong>重定向</strong>方法，实现读取的逻辑，在编写逻辑之前要先知道两种存储途径是怎么生成的，即我们自定义的lua内容要怎么保存到Resources或AB包下：</p><ol><li>Lua文件夹 → Resources文件夹</li></ol><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240716231001923.png" alt="image-20240716231001923"></p><p>Lua文件夹下的lua脚本转移到Resources文件夹下还需要注意两个点：</p><ul><li>只能转移Lua文件夹下自定义的其他文件或lua脚本，但是不能转移Lua同级目录下的文件夹及其内部内容</li><li>转移的时候还会把默认的toLua中的lua脚本也一并转移过去</li></ul><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240716234758165.png" alt="image-20240716234758165"></p><ol start="2"><li>AB包路径下Lua文件夹</li></ol><p>在将Lua文件夹下自定义文件夹进行打包处理前,Lua文件夹下的lua脚本要修改其后缀，因为AB包打包不支持<code>.lua</code>后缀名，所以要手动改为<code>.lua.txt</code>，同时也要和xLua一样先Clear Lua再进行，不然会报错</p><p>再完成了这两种方式的路径修改后，接下来就是重写重定向方法里边的内容，实现解析器能够自动地从这两个路径上去解析每一个lua脚本</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">byte</span>[] <span class="title">ReadFile</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果要重定向解析lua的方式，只需要在该函数中重写逻辑即可</span></span><br><span class="line">        <span class="comment">//如果没有lua后缀，加上lua后缀，无论从AB包中还是res下加载，都不支持用.lua，所以toLua加上了bytes后缀，但我们可以自己加上.txt后缀</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.EndsWith(<span class="string">&quot;.lua&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            fileName += <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为进行热更新的lua代码 通常就是我们自己写的上层lua逻辑</span></span><br><span class="line">        <span class="comment">//toLua的自带逻辑和自带类 我们一般不用热更新，直接从resources下加载即可</span></span><br><span class="line">        <span class="comment">//所以顺序一般为  先从AB包中加载，如果没有的话再从Resources下加载</span></span><br><span class="line">        <span class="built_in">byte</span>[] buffer = <span class="literal">null</span>;</span><br><span class="line">         <span class="comment">//第二种：从AB包中加载lua文件</span></span><br><span class="line">        <span class="comment">//eg：传入路径名为 CSharpCallLua/L2_Loader，而由于打包为AB包内容，我们加载只需要加载文件名即可</span></span><br><span class="line">        <span class="built_in">string</span>[] strs = fileName.Split(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="comment">//加载AB包中的lua文件</span></span><br><span class="line">        TextAsset luaCode = ABMgr.GetInstance().LoadRes&lt;TextAsset&gt;(<span class="string">&quot;lua&quot;</span>,strs[strs.Length<span class="number">-1</span>]);<span class="comment">//加载最后边的文件名</span></span><br><span class="line">        <span class="keyword">if</span>(luaCode != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buffer = luaCode.bytes;</span><br><span class="line">            Resources.UnloadAsset(luaCode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buffer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第一种：从Resources中加载lua文件         前提：通过Lua → copy to Resources 把Lua文件夹下的资源文件拷贝到Res下</span></span><br><span class="line">            <span class="built_in">string</span> path = <span class="string">&quot;Lua/&quot;</span> + fileName;</span><br><span class="line">            TextAsset text = Resources.Load&lt;TextAsset&gt;(path); </span><br><span class="line">            <span class="keyword">if</span>(text != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buffer = text.bytes;</span><br><span class="line">                <span class="comment">//卸载使用后的文本资源</span></span><br><span class="line">                Resources.UnloadAsset(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了更方便的管理解析器内容（让解析器唯一），就需要我们去设计一个解析器管理器</p><h3 id="toLua解析器管理器"><a href="#toLua解析器管理器" class="headerlink" title="toLua解析器管理器"></a>toLua解析器管理器</h3><p>要把该管理器 做成一个 继承了mono的 <strong>单例模式对象</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaMgr</span> : <span class="title">SingletonAutoMono</span>&lt;<span class="title">LuaMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> LuaState luaState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最后打包的时候 再用 再取消注释</span></span><br><span class="line">        <span class="comment">//new LuaCustomLoader();</span></span><br><span class="line">        <span class="comment">//就是初始化 唯一的 luaState</span></span><br><span class="line">        luaState = <span class="keyword">new</span> LuaState();</span><br><span class="line">        luaState.Start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后面有些东西没写 当我们讲到对应知识点时 再来写</span></span><br><span class="line">        <span class="comment">//委托初始化相关</span></span><br><span class="line">        <span class="comment">//想要C#和Lua相互访问使用委托 必须要在初始化时 把委托工厂初始化了 不然没法使用委托</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//协程相关</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lua使用Unity中的类相关</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该属性可以让外部获取到 解析器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;value&gt;</span><span class="doctag">&lt;/value&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> LuaState LuaState</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> luaState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 提供一个外部执行 lua语法字符串的 方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span>lua语法字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;chunkName&quot;&gt;</span>执行出处<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoString</span>(<span class="params"><span class="built_in">string</span> str, <span class="built_in">string</span> chunkName = <span class="string">&quot;LuaMgr.cs&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaState.DoString(str, chunkName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行指定名字的lua脚本</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fileName&quot;&gt;</span>lua脚本名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Require</span>(<span class="params"><span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaState.Require(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 销毁lua解析器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( luaState == <span class="literal">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        luaState.CheckTop();</span><br><span class="line">        luaState.Dispose();</span><br><span class="line">        luaState = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量的获取，在toLua中获取方式与xLua也不相同，其可以直接通过解析器 ＋ 中括号内对应获取的变量名得到，同样的，如果是局部变量(local)，toLua也不能获取到</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取全局变量</span></span><br><span class="line">       <span class="comment">//toLua中访问全局变量 一个套路 得到luastate解析器 然后中括号 变量名 即可得到</span></span><br><span class="line">       Debug.Log(<span class="string">&quot;testNumber:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>]);</span><br><span class="line">       Debug.Log(<span class="string">&quot;testBool:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testBool&quot;</span>]);</span><br><span class="line">       Debug.Log(<span class="string">&quot;testFloat:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testFloat&quot;</span>]);</span><br><span class="line">       Debug.Log(<span class="string">&quot;testString:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testString&quot;</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//值拷贝</span></span><br><span class="line">       <span class="built_in">int</span> <span class="keyword">value</span> = Convert.ToInt32(LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>]);</span><br><span class="line">       <span class="keyword">value</span> = <span class="number">99</span>;</span><br><span class="line">       Debug.Log(<span class="string">&quot;testNumber:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果要改值 直接这样写即可</span></span><br><span class="line">       LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>] = <span class="number">99</span>;</span><br><span class="line">       Debug.Log(<span class="string">&quot;testNumber:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//toLua中 也没有办法通过C#得到local申明的局部临时变量</span></span><br><span class="line">       Debug.Log(<span class="string">&quot;testLocal:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testLocal&quot;</span>]);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//可以在C#处为lua添加全局变量 相当于在lua中的_G中加了一个变量</span></span><br><span class="line">       Debug.Log(<span class="string">&quot;addValue:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>]);</span><br><span class="line">       LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>] = <span class="number">999</span>;</span><br><span class="line">       Debug.Log(<span class="string">&quot;addValue:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>]);</span><br></pre></td></tr></table></figure><p>在C#对Lua变量的值修改或者定义一个新的变量的操作为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果要改值 直接这样写即可</span></span><br><span class="line">        LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>] = <span class="number">99</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;testNumber:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;testNumber&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在C#处为lua添加全局变量 相当于在lua中的_G中加了一个变量</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;addValue:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>]);</span><br><span class="line">        LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>] = <span class="number">999</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;addValue:&quot;</span> + LuaMgr.GetInstance().LuaState[<span class="string">&quot;addValue&quot;</span>]);</span><br></pre></td></tr></table></figure><h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><p>测试用的lua下函数内容有</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无参无返回函数</span></span><br><span class="line">testFun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无参无返回&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--有参有返回函数</span></span><br><span class="line">testFun2 = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有参有返回值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">100</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--多返回值函数</span></span><br><span class="line">testFun3 = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;多返回值&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span>, <span class="literal">false</span>, <span class="string">&quot;123&quot;</span>, a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--变长参数函数</span></span><br><span class="line">testFun4 = <span class="function"><span class="keyword">function</span><span class="params">(a, ...)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;变长参数函数&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line">    <span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k,v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>全局函数的获取也分为几个类型：</p><ul><li><strong>无参无返回值</strong></li></ul><p>主要有三种方式来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法 通过 GetFunction方法获取</span></span><br><span class="line">       LuaFunction function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;testFun&quot;</span>);</span><br><span class="line">       <span class="comment">//调用 无参无返回</span></span><br><span class="line">       function.Call();</span><br><span class="line">       <span class="comment">//执行完过后 </span></span><br><span class="line">       function.Dispose();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第二种方法 通过 中括号 函数名的形式</span></span><br><span class="line">       function = LuaMgr.GetInstance().LuaState[<span class="string">&quot;testFun&quot;</span>] <span class="keyword">as</span> LuaFunction;</span><br><span class="line">       function.Call();</span><br><span class="line">       function.Dispose();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第三种方式 转为委托来使用</span></span><br><span class="line">       <span class="comment">//首先得到一个luafunction 然后再转成委托的形式</span></span><br><span class="line">       function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;testFun&quot;</span>);</span><br><span class="line">       <span class="comment">//通过luafunction中的方法 存入到委托中再使用</span></span><br><span class="line">       UnityAction action = function.ToDelegate&lt;UnityAction&gt;();</span><br><span class="line">       action();</span><br></pre></td></tr></table></figure><p>需要注意的是，前两种方式获得要得到的函数之后，还需要手动开启以及手动关闭，分别通过</p><p><code>Call()</code>和<code>Dispose()</code></p><p>常用的是第三种方式，通过委托来获取到函数，通过这种方式也能获得后续不同类型的函数，需要注意的是，通过委托的形式来获取函数要<strong>先在解析器管理器初始化委托工厂：</strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//委托初始化相关</span></span><br><span class="line">       <span class="comment">//想要C#和Lua相互访问使用委托 必须要在初始化时 把委托工厂初始化了 不然没法使用委托</span></span><br><span class="line">       DelegateFactory.Init();</span><br></pre></td></tr></table></figure><ul><li><strong>有参有返回值</strong></li></ul><p>主要有四种方式来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：通过luafunction的call来访问</span></span><br><span class="line">       function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;testFun2&quot;</span>);</span><br><span class="line">       <span class="comment">//开始使用</span></span><br><span class="line">       function.BeginPCall();</span><br><span class="line">       <span class="comment">//传参</span></span><br><span class="line">       function.Push(<span class="number">99</span>);</span><br><span class="line">       <span class="comment">//调用</span></span><br><span class="line">       function.PCall();</span><br><span class="line">       <span class="comment">//得到返回值</span></span><br><span class="line">       <span class="built_in">int</span> val = (<span class="built_in">int</span>)function.CheckNumber();</span><br><span class="line">       <span class="comment">//执行结束</span></span><br><span class="line">       function.EndPCall();</span><br><span class="line">       Debug.Log(<span class="string">&quot;有参有返回 Cell：&quot;</span>+val);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第二种方式：通过luafunction的Invoke方法来访问</span></span><br><span class="line">       <span class="comment">//最后一个类型是返回值类型，前边的类型是传入参数类型，有多个的话从左到右排</span></span><br><span class="line">       <span class="built_in">int</span> res = function.Invoke&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;(<span class="number">99</span>);</span><br><span class="line">       Debug.Log(<span class="string">&quot;有参有返回 Invoke：&quot;</span>+res);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第三种方式：委托</span></span><br><span class="line">       <span class="comment">//最后一个类型是返回值类型，前边的类型是传入参数类型，有多个的话从左到右排</span></span><br><span class="line">       Func&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; func = function.ToDelegate&lt;Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;&gt;();</span><br><span class="line">       <span class="built_in">int</span> res1 = func(<span class="number">99</span>);</span><br><span class="line">       Debug.Log(<span class="string">&quot;有参有返回 委托：&quot;</span>+res1);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第四种方式：解析器直接调用</span></span><br><span class="line">       <span class="comment">//第一个参数为函数名，第二 到 第n个 是传入参数(多个的话)，最后一个固定写true</span></span><br><span class="line">       <span class="built_in">int</span> res2 = LuaMgr.GetInstance().LuaState.Invoke&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;(<span class="string">&quot;testFun2&quot;</span>,<span class="number">200</span>,<span class="literal">true</span>);</span><br><span class="line">       Debug.Log (<span class="string">&quot;有参有返回 解析器调用：&quot;</span>+res2);</span><br></pre></td></tr></table></figure><p>除了第一种方式之外，另外三种方式，如果传入参数有多个的话，是从左到右按顺序传入对应的几个类型的参数进去</p><ul><li><strong>多返回值</strong></li></ul><p>主要有两种方式来获取</p><p>第一种方式就是通过解析器提供的方法来实现，比较直接且简单明了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方式：通过Call的形式</span></span><br><span class="line">        function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;testFun3&quot;</span>);</span><br><span class="line">        <span class="comment">//开始调用</span></span><br><span class="line">        function.BeginPCall();</span><br><span class="line">        <span class="comment">//传参</span></span><br><span class="line">        function.Push(<span class="number">90</span>);</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        function.PCall();</span><br><span class="line">        <span class="comment">//得到返回值</span></span><br><span class="line">        <span class="built_in">int</span> v1 = (<span class="built_in">int</span>)function.CheckNumber();</span><br><span class="line">        <span class="built_in">int</span> v2 = (<span class="built_in">int</span>)function.CheckNumber();</span><br><span class="line">        <span class="built_in">bool</span> v3 = function.CheckBoolean();</span><br><span class="line">        <span class="built_in">string</span> v4 = function.CheckString();</span><br><span class="line">        <span class="built_in">int</span> v5 = (<span class="built_in">int</span>)function.CheckNumber();</span><br><span class="line">        <span class="comment">//执行结束</span></span><br><span class="line">        function.EndPCall();</span><br><span class="line">        Debug.Log(<span class="string">&quot;多返回值 Cell：&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;第一个值：&quot;</span>+v1+<span class="string">&quot; 第二个值：&quot;</span>+v2+<span class="string">&quot; 第三个值：&quot;</span>+v3+<span class="string">&quot; 第四个值：&quot;</span>+v4+<span class="string">&quot; 第五个值：&quot;</span>+v5);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重点在于第二种方式：通过 out来接取多的返回值</p><p>首先要定义一个委托来对应要获取的lua多返回值函数，定义的有返回值委托的类型接取的相当于多返回值里的第一个返回值，而传入参数的内容里边，第一个传入参数对应的就是lua函数要传入的内容，其他的参数都要通过out来对应接取：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CustomCallOut</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> b,<span class="keyword">out</span> <span class="built_in">bool</span> c,<span class="keyword">out</span> <span class="built_in">string</span> d,<span class="keyword">out</span> <span class="built_in">int</span> e</span>)</span>;</span><br></pre></td></tr></table></figure><p>然后再通过我们自定义的委托来获取到lua脚本中多返回值的函数，获取这些返回值</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式：通过out来接</span></span><br><span class="line">        <span class="comment">//重要！：如果是自定义委托 要在关键文件 CustomSetting 加上这个自定义委托</span></span><br><span class="line">        CustomCallOut callOut = function.ToDelegate&lt;CustomCallOut&gt;();</span><br><span class="line">        <span class="built_in">int</span> b2;</span><br><span class="line">        <span class="built_in">bool</span> c2;</span><br><span class="line">        <span class="built_in">string</span> d2;</span><br><span class="line">        <span class="built_in">int</span> e2;</span><br><span class="line">        <span class="built_in">int</span> a2 = callOut(<span class="number">99</span>,<span class="keyword">out</span> b2,<span class="keyword">out</span> c2,<span class="keyword">out</span> d2,<span class="keyword">out</span> e2);</span><br><span class="line">        Debug.Log(<span class="string">&quot;多返回值 out接取：&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;第一个值：&quot;</span>+a2+<span class="string">&quot; 第二个值：&quot;</span>+b2+<span class="string">&quot; 第三个值：&quot;</span>+c2+<span class="string">&quot; 第四个值：&quot;</span>+d2+<span class="string">&quot; 第五个值：&quot;</span>+e2);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重点！！！如果我们在C#下设置了自定义的委托并且要使用到它，还要在<code>Editor → CustomSettings.cs</code>内注册我们自定义的委托！最后还要通过Lua标签下重新生成Lua的内容</strong></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240717220909333.png" alt="image-20240717220909333"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240717220928522.png" alt="image-20240717220928522"></p><ul><li><strong>变长参数</strong></li></ul><p>主要有两种方式：</p><p>第一种方式也是通过自定义委托来获取，在使用的时候也和前边多返回值一样，要在配置文件下注册我们自定义的委托，同时在lua中重新生成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomCallParams</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">params</span> <span class="built_in">object</span>[] objs</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;testFun4&quot;</span>);</span><br><span class="line">    <span class="comment">//第一种方式：通过自定义委托来执行</span></span><br><span class="line">    CustomCallParams call = function.ToDelegate&lt;CustomCallParams&gt;();</span><br><span class="line">    call(<span class="number">100</span>,<span class="number">5</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">false</span>,<span class="number">10.5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种方式：通过luafunction直接Call</p><p>PS：这种方式只能适用于无返回值的时候</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function.Call&lt;<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">string</span>,<span class="built_in">bool</span>,<span class="built_in">int</span>&gt;(<span class="number">100</span>,<span class="number">20</span>,<span class="string">&quot;字符&quot;</span>,<span class="literal">true</span>,<span class="number">233</span>);</span><br></pre></td></tr></table></figure><h3 id="访问Lua中table表现List和Dictionary"><a href="#访问Lua中table表现List和Dictionary" class="headerlink" title="访问Lua中table表现List和Dictionary"></a>访问Lua中table表现List和Dictionary</h3><p>lua上定义好测试的List和Dictionary</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--table表现的List</span></span><br><span class="line">testList = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>&#125;</span><br><span class="line">testList2 = &#123;<span class="string">&quot;123&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="literal">true</span>, <span class="number">1</span>, <span class="number">1.2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--table表现的Dictionary</span></span><br><span class="line">testDic = &#123;</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="string">&quot;2&quot;</span>] = <span class="number">10</span>,</span><br><span class="line">    [<span class="string">&quot;3&quot;</span>] = <span class="number">20</span>,</span><br><span class="line">    [<span class="string">&quot;4&quot;</span>] = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testDic2 = &#123;</span><br><span class="line">    [<span class="string">&quot;1&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="literal">true</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="literal">false</span>] = <span class="literal">true</span>,</span><br><span class="line">    [<span class="string">&quot;123&quot;</span>] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到C#上进行定义，在toLua中，可以通过解析器提供的<code>GetTable</code>来直接获取到List和Dictionary类型</p><p>使用GetTable来获取列表<code>List</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List相关</span></span><br><span class="line">       <span class="comment">//toLua中 C#得到Lua中的表 都只有一个套路 通过LuaTable来获取</span></span><br><span class="line">       LuaTable table = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testList&quot;</span>);</span><br><span class="line">       Debug.Log(table[<span class="number">1</span>]);</span><br><span class="line">       Debug.Log(table[<span class="number">2</span>]);</span><br><span class="line">       Debug.Log(table[<span class="number">3</span>]);</span><br><span class="line">       Debug.Log(table[<span class="number">4</span>]);</span><br><span class="line">       Debug.Log(table[<span class="number">5</span>]);</span><br><span class="line">       <span class="comment">//如果要遍历LuaTable对应的table 需要先转数组</span></span><br><span class="line">       <span class="built_in">object</span>[] objs = table.ToArray();</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; objs.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(<span class="string">&quot;遍历打印：&quot;</span> + objs[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//修改 直接就是引用拷贝</span></span><br><span class="line">       table[<span class="number">1</span>] = <span class="number">999</span>;</span><br><span class="line">       LuaTable tableTmp = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testList&quot;</span>);</span><br><span class="line">       Debug.Log(<span class="string">&quot;测试引用拷贝：&quot;</span> + tableTmp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">       LuaTable table2 = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testList2&quot;</span>);</span><br><span class="line">       Debug.Log(table2[<span class="number">1</span>]);</span><br><span class="line">       Debug.Log(table2[<span class="number">2</span>]);</span><br><span class="line">       Debug.Log(table2[<span class="number">3</span>]);</span><br><span class="line">       Debug.Log(table2[<span class="number">4</span>]);</span><br><span class="line">       Debug.Log(table2[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">       objs = table2.ToArray();</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; objs.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(<span class="string">&quot;遍历打印：&quot;</span> + objs[i]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>使用GetTable来获取<code>Dictionary</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dictironary相关</span></span><br><span class="line">       LuaTable dic = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testDic&quot;</span>);</span><br><span class="line">       Debug.Log(dic[<span class="string">&quot;1&quot;</span>]);</span><br><span class="line">       Debug.Log(dic[<span class="string">&quot;2&quot;</span>]);</span><br><span class="line">       Debug.Log(dic[<span class="string">&quot;3&quot;</span>]);</span><br><span class="line">       Debug.Log(dic[<span class="string">&quot;4&quot;</span>]);</span><br></pre></td></tr></table></figure><p>虽然toLua可以通过GetTable来获取Dictionary类型，但是通过中括号得到值 <strong>只支持 int和string</strong>，其它类型的没办法直接来获取</p><p>所以这时候就要通过LuaTable下的<code>ToDictTable</code>方法来获取，其中，ToDictTable的两个参数对应的是Dictionary的键值对，如果Dictionary类型里边定义了很多不同数据类型，就可以使用object，如果是固定同一类型的就可以换成那个类型的即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LuaTable dic2 = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testDic2&quot;</span>);</span><br><span class="line">LuaDictTable&lt;<span class="built_in">object</span>, <span class="built_in">object</span>&gt; luaDic2 = dic2.ToDictTable&lt;<span class="built_in">object</span>, <span class="built_in">object</span>&gt;();</span><br><span class="line">        Debug.Log(luaDic2[<span class="literal">true</span>]);</span><br><span class="line">        Debug.Log(luaDic2[<span class="string">&quot;123&quot;</span>]);</span><br><span class="line">        Debug.Log(luaDic2[<span class="literal">false</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dic建议 使用 迭代器遍历</span></span><br><span class="line">        IEnumerator&lt;LuaDictEntry&lt;<span class="built_in">object</span>, <span class="built_in">object</span>&gt;&gt; ie = luaDic2.GetEnumerator();</span><br><span class="line">        <span class="keyword">while</span>(ie.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(ie.Current.Key + <span class="string">&quot;_&quot;</span> + ie.Current.Value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>C#要调用Lua中对应的List和Dictionary属性的值，通过<code>GetTable()</code>来获取；而Dictionary通常还要使用LuaDictTable&lt;T,T&gt;来接取 GetTable()得到的再调用 <code>ToDictTable&lt;T,T&gt;</code>的值</p><h3 id="访问Lua中table表现的类"><a href="#访问Lua中table表现的类" class="headerlink" title="访问Lua中table表现的类"></a>访问Lua中table表现的类</h3><p> 由于在lua中类的定义本质上也是用table来表示的，所以C#访问lua中表现的类依然是通过<code>GetTable</code>方式来实现，再根据类中属性类型的不同，比如表示函数的function或字典，再调用对应的LuaFunction等来实现即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过 luastate中的 getTable方法 来获取</span></span><br><span class="line">       LuaTable table = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testClass&quot;</span>);</span><br><span class="line">       <span class="comment">//table = LuaMgr.GetInstance().LuaState[&quot;testClass&quot;] as LuaTable;</span></span><br><span class="line">       <span class="comment">//访问其中的变量</span></span><br><span class="line">       <span class="comment">//中括号 变量名 就可以获取</span></span><br><span class="line">       Debug.Log(table[<span class="string">&quot;testInt&quot;</span>]);</span><br><span class="line">       Debug.Log(table[<span class="string">&quot;testBool&quot;</span>]);</span><br><span class="line">       Debug.Log(table[<span class="string">&quot;testFloat&quot;</span>]);</span><br><span class="line">       Debug.Log(table[<span class="string">&quot;testString&quot;</span>]);</span><br><span class="line">       table[<span class="string">&quot;testInt&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">       <span class="comment">//它是引用拷贝</span></span><br><span class="line">       LuaTable table2 = LuaMgr.GetInstance().LuaState.GetTable(<span class="string">&quot;testClass&quot;</span>);</span><br><span class="line">       Debug.Log(table2[<span class="string">&quot;testInt&quot;</span>]);</span><br><span class="line">       <span class="comment">//获取其中的函数 </span></span><br><span class="line">       LuaFunction function = table.GetLuaFunction(<span class="string">&quot;testFun&quot;</span>);</span><br><span class="line">       function.Call();</span><br></pre></td></tr></table></figure><h3 id="使用toLua提供的协程"><a href="#使用toLua提供的协程" class="headerlink" title="使用toLua提供的协程"></a>使用toLua提供的协程</h3><p>C#调用toLua中的携程，实际上携程的逻辑都在Lua中，C#相当于只是执行了一个函数而已，在Lua中定义携程先:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--lua协程相关的代码</span></span><br><span class="line"><span class="keyword">local</span> coDelay = <span class="literal">nil</span></span><br><span class="line"><span class="comment">--协程 相关的lua逻辑 这些内容都是toLua帮助我们实现的</span></span><br><span class="line"><span class="comment">--lua自带的 create resume yield status wrap running</span></span><br><span class="line">StartDelay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    coDelay = <span class="built_in">coroutine</span>.start(Delay)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Delay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> c = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">--等待1s 执行一次逻辑</span></span><br><span class="line">        <span class="built_in">coroutine</span>.wait(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Count:&quot;</span> .. c)</span><br><span class="line">        c = c + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> c &gt;= <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">            StopDelay()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">StopDelay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">coroutine</span>.stop(coDelay)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>PS: 其中携程的stop，start等都是 toLua 提供的，不是lua本身自带的功能！</strong></p><p>然后再C#上进行调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LuaFunction function = LuaMgr.GetInstance().LuaState.GetFunction(<span class="string">&quot;StartDelay&quot;</span>);</span><br><span class="line">       function.Call();</span><br><span class="line">       function.Dispose();</span><br></pre></td></tr></table></figure><p><strong>重点！在C#要使用toLua的协程，还需要在解析器管理器上进行初始化，类似于要使用委托前的初始化，通过添加一个脚本<code>LuaLooper</code>：</strong></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240719151845474.png" alt="image-20240719151845474"></p><p>这样就能让c#调用toLua上的协程并让其正确运行</p><h2 id="Lua调用C"><a href="#Lua调用C" class="headerlink" title="Lua调用C#"></a>Lua调用C#</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>toLua中通过Lua调用C#的类的操作基本上和xLua一样，区别就是 不需要用<code>CS.</code>，而且toLua在调用C#的类之前，还需要<strong>在解析器上进行初始化类相关的内容</strong>！</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240720163539226.png" alt="image-20240720163539226"></p><p>同时，<strong>如果是Lua不认识的类，比如自定义的类，Unity的一些类等等，需要我们手动的在<code>CustomSettings.cs</code>的<code>customTypeList</code>下手动注册并且通过Lua自动生成对应的文件：</strong></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240720163731291.png" alt="image-20240720163731291"></p><p>测试Lua调用类、成员方法、继承了Mono的自定义类等：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--toLua和xLua访问C#类非常相似</span></span><br><span class="line"><span class="comment">--命名空间.类名</span></span><br><span class="line"><span class="comment">--eg： UnityEngine.GameObject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--与xLua的区别是 不需要加CS.命名空间.类名 省略了CS</span></span><br><span class="line"><span class="keyword">local</span> obj = UnityEngine.GameObject(<span class="string">&quot;测试&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--同样，为了方便使用并且节约性能，定义全局变量来存储C#中的类，相当于取别名</span></span><br><span class="line">GameObject = UnityEngine.GameObject</span><br><span class="line"><span class="keyword">local</span> obj2 = GameObject(<span class="string">&quot;别名创建&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--类中的静态对象 可以使用.来调用</span></span><br><span class="line"><span class="keyword">local</span> obj3 = GameObject.Find(<span class="string">&quot;测试&quot;</span>)</span><br><span class="line"><span class="comment">--得到对象中的成员变量，也是通过对象.属性获得</span></span><br><span class="line"><span class="built_in">print</span>(obj3.transform.position.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">--!!!Debug报错了，因为我们没有把它加到CustomSetting文件中</span></span><br><span class="line"><span class="comment">--如果发现Lua使用C#中的类报错了，我们需要把它加入到CustomSetting文件中的customTypeList中！</span></span><br><span class="line"> <span class="comment">-- Debug目前不清楚为什么会用不了，暂时没找到解决方案！</span></span><br><span class="line"><span class="comment">--Debug = UnityEngine.Debug </span></span><br><span class="line"><span class="comment">--Debug.Log(obj3.transform.position.x)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--成员方法的使用</span></span><br><span class="line">Vector3 = UnityEngine.Vector3</span><br><span class="line"><span class="comment">--如果要使用对象的成员方法，需要加上冒号</span></span><br><span class="line">obj3.transform:Translate(Vector3.right)</span><br><span class="line"><span class="built_in">print</span>(obj3.transform.position.x)</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用自定义继承了Mono的类</span></span><br><span class="line"><span class="comment">--继承了Mono的类 是不能直接new的</span></span><br><span class="line"><span class="keyword">local</span> obj5 = GameObject(<span class="string">&quot;加脚本测试&quot;</span>)</span><br><span class="line"><span class="comment">--通过GameObject的 AddComponent方法 添加脚本</span></span><br><span class="line"><span class="comment">--typeof 是toLua提供的一个得到Type的方法</span></span><br><span class="line">obj5:AddComponent(typeof(LuaCallCsharp))</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用没有继承Mono的类</span></span><br><span class="line"><span class="keyword">local</span> t1 = Test()</span><br><span class="line">t1:Speak(<span class="string">&quot;t1说话&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t2 = AAA.Test2()</span><br><span class="line">t2:Speak(<span class="string">&quot;t2说话&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的调用规则和类的调用规则一致：命名空间.枚举名.枚举成员 ，也支持取别名</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--调用Unity自带的枚举</span></span><br><span class="line"><span class="comment">--同样要在toLua的配置文件下注册枚举，然后生成代码</span></span><br><span class="line">PrimitiveType = UnityEngine.PrimitiveType</span><br><span class="line">GameObject = UnityEngine.GameObject</span><br><span class="line"><span class="comment">--GameObject中的静态方法   —— 创建几何体</span></span><br><span class="line"><span class="keyword">local</span> obj = GameObject.CreatePrimitive(PrimitiveType.Cube)</span><br><span class="line"><span class="comment">--调用自定义的枚举</span></span><br><span class="line"><span class="keyword">local</span> c = E_myEnum.Atk</span><br><span class="line"><span class="keyword">local</span> d = E_myEnum.Idle</span><br><span class="line"><span class="comment">--userdata类型 保留了语言中的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c==d <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;枚举比较&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;枚举转字符串&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(c))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;枚举转整数&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(c:ToInt())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字转枚举&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(E_myEnum.IntToEnum(<span class="number">0</span>))</span><br><span class="line"><span class="comment">--和xLua的区别 没有提供字符串转枚举</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样的，<strong>枚举类型也需要我们去toLua的配置文件<code>CustomSettings.cs</code>下进行注册！</strong></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>toLua访问C#数组的规则和xLua几乎一样</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = Test3()</span><br><span class="line"></span><br><span class="line"><span class="comment">--数组的长度</span></span><br><span class="line"><span class="built_in">print</span>(obj.array.Length)</span><br><span class="line"></span><br><span class="line"><span class="comment">--访问元素</span></span><br><span class="line"><span class="built_in">print</span>(obj.array[<span class="number">0</span>])</span><br><span class="line"><span class="comment">--查找元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查找元素位置：&quot;</span>..obj.array:IndexOf(<span class="number">2</span>))</span><br><span class="line"><span class="comment">--遍历</span></span><br><span class="line"><span class="comment">--数组是C#的结构，所以lua的规则和C#不一样，遵循C#的</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,obj.array.Length - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Array&quot;</span> .. obj.array[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>区别在于toLua本身提供了多种不同的遍历方式，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--toLua中比xLua多了几种遍历方式</span></span><br><span class="line"><span class="comment">--迭代器遍历</span></span><br><span class="line"><span class="keyword">local</span> iter = obj.array:GetEnumerator()</span><br><span class="line"><span class="keyword">while</span> iter:MoveNext() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;iter：&quot;</span>..iter.Current)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--转table遍历</span></span><br><span class="line"><span class="keyword">local</span> t = obj.array:ToTable()</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#t <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;table：&quot;</span>..t[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而创建数组则也是通过<code>System.Array.CreateInstance(数组类型，长度)</code>的方式进行创建，如果发生报错，通常是因为 数组类型(eg：System.Int32) toLua无法识别，要在配置文件<code>CustomSettings</code>下注册并生成对应内容才行</p><h3 id="List和字典"><a href="#List和字典" class="headerlink" title="List和字典"></a>List和字典</h3><p>使用和C#的一致，麻烦的是在创建的时候，toLua要想创建List和字典，由于其本身不支持泛型，所以导致我们每定义一种类型的List或者字典，比如List<Int>，List<String>等都要在配置文件<code>CustomSettings</code>下进行注册：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240720221418482.png" alt="image-20240720221418482"></p><p>List和字典在lua上进行相关的操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--虽然自定义类Lesson3已经在 CustomSetting去添加了并且生成了</span></span><br><span class="line"><span class="comment">--但是我们改变了这个类 里面新加了 两个变量</span></span><br><span class="line"><span class="comment">--我们必须要在菜单栏中重新生成一次</span></span><br><span class="line"><span class="keyword">local</span> obj = Lesson3()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****List****&quot;</span>)</span><br><span class="line">obj.list:Add(<span class="number">10</span>)</span><br><span class="line">obj.list:Add(<span class="number">12</span>)</span><br><span class="line">obj.list:Add(<span class="number">15</span>)</span><br><span class="line"><span class="comment">--得到其中一个元素</span></span><br><span class="line"><span class="built_in">print</span>(obj.list[<span class="number">0</span>])</span><br><span class="line"><span class="comment">--长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;长度:&quot;</span> .. obj.list.Count)</span><br><span class="line"></span><br><span class="line"><span class="comment">--遍历</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span>, obj.list.Count - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;遍历&quot;</span> .. obj.list[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;****Dictionary****&quot;</span>)</span><br><span class="line">obj.dic:Add(<span class="number">1</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">obj.dic:Add(<span class="number">2</span>, <span class="string">&quot;234&quot;</span>)</span><br><span class="line">obj.dic:Add(<span class="number">3</span>, <span class="string">&quot;345&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.dic[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--xlua是通过pairs去遍历的 字典</span></span><br><span class="line"><span class="comment">--toLua中不支持这种遍历方式</span></span><br><span class="line"><span class="comment">--toLua中要用迭代器来进行遍历</span></span><br><span class="line"><span class="keyword">local</span> iter = obj.dic:GetEnumerator()</span><br><span class="line"><span class="keyword">while</span> iter:MoveNext() <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> v = iter.Current</span><br><span class="line">    <span class="built_in">print</span>(v.Key .. <span class="string">&quot;_&quot;</span> .. v.Value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--单纯遍历键</span></span><br><span class="line"><span class="keyword">local</span> keyIter = obj.dic.Keys:GetEnumerator()</span><br><span class="line"><span class="keyword">while</span> keyIter:MoveNext() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;键：&quot;</span>.. keyIter.Current)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--单纯遍历值</span></span><br><span class="line"><span class="keyword">local</span> valueIter = obj.dic.Values:GetEnumerator()</span><br><span class="line"><span class="keyword">while</span> valueIter:MoveNext() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;值：&quot;</span>.. valueIter.Current)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>PS：比较要注意的是字典的遍历，由于<strong>toLua不支持pairs操作</strong>，所以toLua要遍历字典的话通常采用的方式相当于C#的迭代器来进行遍历</p><p><strong>List和字典在lua上被创建：</strong></p><p>前提是先在<code>CustomSettings</code>下注册我们要使用的泛型(eg：List<int>)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在toLua中创建一个list</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;创建List&quot;</span>)</span><br><span class="line"><span class="comment">--toLua它对泛型支持比较糟糕 想要用什么泛型类型的对象</span></span><br><span class="line"><span class="comment">--都需要在CustomSetting中去添加对应的类型 生成</span></span><br><span class="line"><span class="comment">--才能够在toLua中去使用</span></span><br><span class="line"><span class="comment">--List&lt;string&gt;</span></span><br><span class="line"><span class="keyword">local</span> list2 = System.Collections.Generic.List_string()</span><br><span class="line">list2:Add(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list2[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果要在Lua中创建字典对象</span></span><br><span class="line"><span class="comment">--和List一样 需要在CustomSetting中去添加对应的类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;创建Dic&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dic2 = System.Collections.Generic.Dictionary_int_string()</span><br><span class="line">dic2:Add(<span class="number">10</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(dic2[<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> dic3 = System.Collections.Generic.Dictionary_string_int()</span><br><span class="line">dic3:Add(<span class="string">&quot;123&quot;</span>, <span class="number">88888</span>)</span><br><span class="line"><span class="comment">--toLua使用Dic这 不能够直接通过字符串作为键来访问值</span></span><br><span class="line"><span class="comment">--print(dic3[&quot;123&quot;])</span></span><br><span class="line"><span class="keyword">local</span> b,v = dic3:TryGetValue(<span class="string">&quot;123&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure><p>需要注意到的是，根据我们定义的List和字典里边的类型的不同，<strong>在toLua中定义的时候除了命名空间.类之外，还要加上 List&#x2F;Dictionary + 类型的小写(List_int())</strong></p><p><strong>PS：字典不可以直接通过字符串作为键来访问值，只能通过固定写法<code>local b,v = dic3:TryGetValue(&quot;123&quot;, nil)</code>来获取值</strong></p><h3 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h3><p>C#上定义拓展方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="keyword">this</span> Test4 obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(obj.name + <span class="string">&quot;移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name = <span class="string">&quot;MrLi&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Speak2</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;演讲&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lua中使用拓展方法比较特别，需要在配置文件上加上特定的内容：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240720224229041.png" alt="image-20240720224229041"></p><p>要把该类的拓展方法所在的静态类也添加进去，并且是用<strong>AddExtendType</strong>的方式联系在一起，这样才能让拓展方法生效</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--成员方法的调用</span></span><br><span class="line"><span class="comment">--相当于先实例化再通过冒号来调用</span></span><br><span class="line"><span class="keyword">local</span> obj = Test4()</span><br><span class="line">obj:Speak(<span class="string">&quot;小明去旅游&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--拓展方法的调用</span></span><br><span class="line"><span class="comment">--在使用前要先在配置类中加上      _GT(typeof(Test4)).AddExtendType(typeof(Tools))</span></span><br><span class="line">obj:Move()</span><br></pre></td></tr></table></figure><h3 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h3><p>toLua的ref和out函数的使用和xLua一致，都是通过多返回值来处理，和xLua的区别就是：out参数不能省略</p><p>对应的C#ref和out函数定义:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RefFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">ref</span> <span class="built_in">int</span> b,<span class="keyword">ref</span> <span class="built_in">int</span> c,<span class="built_in">int</span> d</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       b = a+d;</span><br><span class="line">       c = a-d;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">OutFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> b,<span class="keyword">out</span> <span class="built_in">int</span> c,<span class="built_in">int</span> d</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       b = a+d;</span><br><span class="line">       c = a-d;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RefOutFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> b,<span class="keyword">ref</span> <span class="built_in">int</span> c</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       b = a * <span class="number">10</span>;</span><br><span class="line">       c = a * <span class="number">20</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">150</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过lua来调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--toLua和xLua对ref和out函数使用基本一致</span></span><br><span class="line"><span class="comment">--都是通过多返回值的形式来处理的</span></span><br><span class="line"><span class="comment">--如果是 out和ref函数，第一个返回值是函数的默认返回值</span></span><br><span class="line"><span class="comment">--之后的返回值就是 ref和out对应结果从左到右</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj = Test5()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj:RefFun(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">local</span> a,b,c = obj:RefFun(<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">--toLua中out函数调用和xLua有区别</span></span><br><span class="line"><span class="comment">--xLua中可省略传入out参数，但是toLua不能省略</span></span><br><span class="line"><span class="built_in">print</span>(obj:OutFun(<span class="number">20</span>,<span class="literal">nil</span>,<span class="literal">nil</span>,<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--toLua中要使用ref和out时，尽量使用out</span></span><br><span class="line"><span class="built_in">print</span>(obj:RefOutFun(<span class="number">20</span>,<span class="literal">nil</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>函数重载toLua和xLua都有相同的特点，对于重载函数的精度支持不好，因为lua中只有Number一种数值类型，导致int，float等会分不清楚</p><p>重载函数如果使用了out参数的话，通常要设置占位符来表示调用的是带out参数的函数，否则会默认调用相同参数内容的非out函数</p><p>对应的C#例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">float</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h3><p>C#上定义委托和事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test7</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction action;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> UnityAction eventAction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventAction != <span class="literal">null</span>)</span><br><span class="line">            eventAction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ClearEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventAction = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(action != <span class="literal">null</span>)</span><br><span class="line">            action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>委托</li></ul><p>委托的使用，toLua和xLua差不多，区别在于<strong>toLua中不能直接调用委托函数(开启委托)，必须通过C#上定义开启委托的方法，然后在lua上调用才行</strong></p><p>PS：toLua第一次在委托中注册函数，需要用 <code>=</code> 号而不是+号，第二次以及往后才用+号进行注册</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--委托是用来装函数的</span></span><br><span class="line"><span class="keyword">local</span> fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Lua函数Fun&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============委托中加函数===========&quot;</span>)</span><br><span class="line"><span class="comment">--Lua中没有复合运算符，所以不能用+=</span></span><br><span class="line"><span class="comment">--第一次往委托中加函数，由于是nil，所以第一次要用=而不是+</span></span><br><span class="line">obj.action = fun</span><br><span class="line">obj.action = obj.action + fun</span><br><span class="line">obj.action = obj.action + <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;新加入的函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--xLua可以直接通过obj.action()执行，但是toLua不行</span></span><br><span class="line"><span class="comment">--只能在C#上定义一个开启委托的方法，然后在lua这边调用</span></span><br><span class="line">obj:DoAction()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============委托中减函数===========&quot;</span>)</span><br><span class="line">obj.action = obj.action - fun</span><br><span class="line">obj.action = obj.action - fun</span><br><span class="line">obj:DoAction()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============委托中清空函数===========&quot;</span>)</span><br><span class="line">obj.action = <span class="literal">nil</span></span><br><span class="line">obj:DoAction()</span><br><span class="line">obj.action = fun</span><br><span class="line">obj:DoAction()</span><br></pre></td></tr></table></figure><ul><li>事件</li></ul><p>事件的使用，toLua和xLua差别比较大，xLua是通过 <code>对象:事件名 +/- 函数</code>，而toLua是通过 <code>对象.事件名 + 函数</code>来实现的</p><p>PS：与委托不同的是，toLua中事件第一次添加函数，不能使用&#x3D;号，而是使用<code>+</code>号进行</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fun2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;事件要加的函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============事件中加函数===========&quot;</span>)</span><br><span class="line"><span class="comment">--toLua中事件加减函数和委托差不多，区别在于要遵循C#中的规则</span></span><br><span class="line"><span class="comment">--也就是不能和委托一样初始用 = ，第一次添加直接用 +即可</span></span><br><span class="line">obj.eventAction = obj.eventAction + fun2</span><br><span class="line">obj.eventAction = obj.eventAction + <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;事件添加的新的函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">obj:DoEvent()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============事件中减少函数===========&quot;</span>)</span><br><span class="line">obj.eventAction = obj.eventAction - fun2</span><br><span class="line">obj:DoEvent()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============事件中清空函数===========&quot;</span>)</span><br><span class="line">obj:ClearEvent()</span><br><span class="line">obj:DoEvent()</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>toLua调用C#协程比xLua要更加方便，因为可以直接使用Unity协程的相似方法进行直接使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--toLua提供了开启协程的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> coDeplay = <span class="literal">nil</span></span><br><span class="line">StartDelay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">--toLua提供的开启协程的方法</span></span><br><span class="line">    coDeplay = StartCoroutine(Delay)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Delay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> c = <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始协程：&quot;</span>..c)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="comment">--直接使用类似Unity中的协程相关内容</span></span><br><span class="line">        WaitForSeconds(<span class="number">1</span>)</span><br><span class="line">        <span class="comment">--Yield(0)</span></span><br><span class="line">        <span class="comment">--WaitForFixedUpdate()</span></span><br><span class="line">        <span class="comment">--WaitForEndOfFrame()</span></span><br><span class="line">        <span class="built_in">print</span>(c)</span><br><span class="line">        c = c+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">5</span> <span class="keyword">then</span></span><br><span class="line">            StopDeplay()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">StopDeplay = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">    StopCoroutine(coDeplay)</span><br><span class="line">    coDeplay = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">StartDelay()</span><br></pre></td></tr></table></figure><p>但要使用这种方式，还要有前提条件，需要<strong>在解析器管理器下进行lua协程的注册：</strong></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240721215748742.png" alt="image-20240721215748742"></p><p>这样就完成了整体协程的调用，通过这种方式就可以直接调用协程的相关方法内容了</p><p>最后总结一下解析器控制器的初始化内容，其本身要实现委托，协程等都要进行相关的初始化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化 唯一的 luaState</span></span><br><span class="line">luaState = <span class="keyword">new</span> LuaState();</span><br><span class="line">luaState.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托初始化相关</span></span><br><span class="line"><span class="comment">//想要C#和Lua相互访问使用委托 必须要在初始化时 把委托工厂初始化了 不然没法使用委托</span></span><br><span class="line">DelegateFactory.Init();</span><br><span class="line"></span><br><span class="line"><span class="comment">//协程相关</span></span><br><span class="line"><span class="comment">//如果要让toLua的协程跑起来 必须添加一个脚本</span></span><br><span class="line">LuaLooper loop = <span class="keyword">this</span>.gameObject.AddComponent&lt;LuaLooper&gt;();</span><br><span class="line"><span class="comment">//将我们声明的解析器和lualooper绑定起来，就可以让协程跑起来了</span></span><br><span class="line">loop.luaState = luaState;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lua协程注册</span></span><br><span class="line">LuaCoroutine.Register(luaState,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lua使用Unity中的类相关</span></span><br><span class="line">LuaBinder.Bind(luaState);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>框架整理</title>
      <link href="/2024/07/14/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/"/>
      <url>/2024/07/14/%E6%A1%86%E6%9E%B6%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>耦合与内聚</p><p>耦合通常来说就是对象、类的双向引用、循环引用；内聚就是相同类型的代码放在一起</p><p>在框架层面上要注意到对象之间的交互以及模块化，通常来说，对象之间的交互有三种：</p><ul><li><strong>方法调用</strong><ul><li>A需要持有B才能调用B的方法</li></ul></li><li><strong>委托或者回调</strong><ul><li>A需要持有B才能注册B的委托（相当于B通知A）</li></ul></li><li><strong>消息或事件</strong><ul><li>A不需要持有B</li></ul></li></ul><p>模块化一般也有三种：</p><ul><li><strong>单例</strong></li><li><strong>IOC</strong></li><li><strong>分层（MVC）</strong></li></ul><p>一般通过父节点来引用子节点，子节点要调用父节点的方法时，可以使用事件或委托</p><p>这里就是使用委托的方式来实现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameStartPanel</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Enemies;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;Start&quot;</span>).GetComponent&lt;Button&gt; ().onClick.AddListener(()=&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">            Enemies.SetActive(<span class="literal">true</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当涉及到跨模块，比如UI层面与业务逻辑实现层面要进行关联的时候，如上边在按钮启动的时候调用了父节点(本质上是业务逻辑模块的内容)，这时候我们应该采用事件来实现不同模块下互不干扰的情况</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">GameStartEvent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action onEvents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action Event</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents += Event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">Action Event</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents -= Event; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 开启事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StartEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候再业务模块上新添内容，实现事件的添加，比如开启自身内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameStartEvent.Register(BuildAllEnemies);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BuildAllEnemies</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;CubeList&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameStartEvent.Unregister(BuildAllEnemies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在回到UI模块下的对应位置下开启事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform.Find(<span class="string">&quot;Start&quot;</span>).GetComponent&lt;Button&gt; ().onClick.AddListener(()=&gt;</span><br><span class="line">      &#123;</span><br><span class="line">          gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">          </span><br><span class="line">          GameStartEvent.StartEvent();</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>同样的，相同类型的事件，可以通过泛型 + 继承的方式来定义，这样可以更快地设置好新的事件，达到不同的效果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action onEvents;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action Event</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents += Event;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Unregister</span>(<span class="params">Action Event</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents -= Event; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> </span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 开启事件</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StartEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        onEvents?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><p>在学习之前要先了解两个概念：</p><ul><li>交互逻辑</li><li>表现逻辑</li></ul><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240714174851315.png" alt="image-20240714174851315"></p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240714175050075.png" alt="image-20240714175050075"></p><p>这也就意味着：</p><p><strong>交互逻辑：View → Model</strong></p><p><strong>表现逻辑：Model → View</strong></p><p>在正常的开发过程中，不会真正的去使用MVC开发架构，而是使用表现(View)和数据(Model)分离的思想，只需要搞清楚交互逻辑和表现逻辑如何实现的就可以</p><p>而在开发脚本的时候也是如此，在挂载到对应的对象身上的脚本(继承了MonoBehaviour)一般就是对应的ViewController，而不是单纯的View，因为它本身既有View的职责又有Controller的职责</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;()</span><br><span class="line">            .onClick.AddListener(() =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//交互逻辑</span></span><br><span class="line">                 CounterModel.Count++;</span><br><span class="line">                 <span class="comment">//表现逻辑</span></span><br><span class="line">                 UpdateView();</span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而同样的，一般View对象只需要监听Model的数据变化即可，这时候就可以使用对象之间的相互引用的<strong>第二种方式（委托&amp;回调）</strong>，在Model设置数据变化时开启委托</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> mCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Action&lt;<span class="built_in">int</span>&gt; OnCountChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">value</span> != mCount)</span><br><span class="line">            &#123;</span><br><span class="line">                mCount = <span class="keyword">value</span>;</span><br><span class="line">                </span><br><span class="line">                OnCountChanged?.Invoke(<span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.OnCountChanged += countChanged;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;()</span><br><span class="line">            .onClick.AddListener(() =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//交互逻辑：这个会自动触发表现逻辑</span></span><br><span class="line">                 CounterModel.Count++;</span><br><span class="line">                </span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">         CounterModel.OnCountChanged -= countChanged;                     </span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countChanged</span>(<span class="params"><span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;CountText&quot;</span>).GetComponent&lt;Text&gt;().text = newCount.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时框架就是为：</p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240715150251738.png" alt="image-20240715150251738"></p><p>紧接着，对象之间的交互的第三种实现方式（事件）的实现，首先也是先创建服务于Model数据变化时要开启的事件内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnCountChangedEvent</span>: <span class="title">Event</span>&lt;<span class="title">OnCountChangedEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在Model里边的代码修改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> mCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">value</span> != mCount)</span><br><span class="line">            &#123;</span><br><span class="line">                mCount = <span class="keyword">value</span>;</span><br><span class="line">                </span><br><span class="line">                OnCountChangedEvent.Trigger();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewController里边的代码修改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnCountChangedEvent += countChanged;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;()</span><br><span class="line">            .onClick.AddListener(() =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//交互逻辑：这个会自动触发表现逻辑</span></span><br><span class="line">                 CounterModel.Count++;</span><br><span class="line">                </span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">         OnCountChangedEvent -= countChanged;                     </span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countChanged</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;CountText&quot;</span>).GetComponent&lt;Text&gt;().text = CounterModel.mCount.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以做一个总结：</p><p>如果不采用MVC框架来搭建我们的逻辑交互，以最开始的方法调用，也就是实现交互逻辑后手动调用一次表现逻辑，如果有更多数据，那这种方式会造成更多的代码调用，而且容易出现疏忽忘记等问题，同时还有这种缺点：</p><ul><li>表现逻辑需要交互逻辑之后主动调用，容易增加开发者的负担</li><li>当数据更多的时候容易让Controller变得臃肿，增加维护成本</li></ul><p>而采用刚才的两种方式，委托和事件来实现交互逻辑与表现逻辑，可以发现代码精简了很多，比如按钮被点击的时候，我们只需要考虑让数据发生变化即可，不用关心其表现逻辑是怎么样的，<strong>当数据变化时就会自然触发表现逻辑，这就是所谓的数据驱动</strong>。通过上述比较和分析就可以知道，表现逻辑的实现更适合使用 委托&#x2F;回调 或者 事件 </p><p>而对比第二种方法和第三种方法，它们在什么情况下实际应用哪个呢？</p><p>如果是单个数值变化，那么用委托的方式更加合适，比如金币、分数、等级等等，如果是颗粒度比较大的更新则用事件更加合适，比如从服务器拉取一个任务列表数据，然后将任务列表数据存到Model，此任务列表数据发生了变更，这时候就要向View发送事件更加合适</p><h1 id="BindableProperty"><a href="#BindableProperty" class="headerlink" title="BindableProperty"></a>BindableProperty</h1><p>再回到Model里边，可以发现其每一个数据都要定义一个变量，一个对应的委托，还有值比较的代码，是比较繁琐的，所以引入一个新的工具类，让其来绑定属性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BindableProperty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IEquatable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T mValue = <span class="literal">default</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> mValue; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">value</span>.Equals(Value))</span><br><span class="line">            &#123;</span><br><span class="line">                OnValueChanged?.Invoke(Value);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnValueChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次回到Model和View分别对其数据定义和相关逻辑进行更改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BindableProperty&lt;<span class="built_in">int</span>&gt; Count = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()&#123;</span><br><span class="line">        <span class="comment">//这里填写默认值</span></span><br><span class="line">     Value = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CountModel.Count.OnValueChanged += countChanged;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;()</span><br><span class="line">            .onClick.AddListener(() =&gt;</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="comment">//交互逻辑：这个会自动触发表现逻辑</span></span><br><span class="line">                 CounterModel.Count.Value++;</span><br><span class="line">                </span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        CountModel.Count.OnValueChanged -= countChanged;                     </span><br><span class="line">    &#125;</span><br><span class="line">                                 </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countChanged</span>(<span class="params"><span class="built_in">int</span> newCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;CountText&quot;</span>).GetComponent&lt;Text&gt;().text = newCount.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>我们定义的BindablePropert是 <strong>数据 ＋ 数据变更事件</strong> 的集合体，它既存储了数据充当C#中的属性这样的角色，也可以从别的地方监听它的数据变更事件，这样会减少大量的样板代码（样板代码就是像之前Model里边定义的mCount以及相关内容）</p><p>我们知道子节点调用父节点可以用委托和事件，而Model和View也是底层和上层的关系，一般Model存储数据，而数据就是一个项目的底层，所以也可以下一个结论：</p><p><strong>自底向上的逻辑可以用委托或者事件，而自顶向下的逻辑可以用方法调用</strong></p><h1 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h1><p>在以下的代码交互逻辑中：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span>：<span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//按钮添加</span></span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt;                                                        &#123;</span><br><span class="line"><span class="comment">//交互逻辑：会自动触发表现逻辑</span></span><br><span class="line">            CounterModel.Count.Value++;</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中目前只实现了一个交互逻辑，但在实际开发中，我们或许会由于该脚本挂载在一个物体上，要实现很多个相应的交互逻辑：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span>：<span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//按钮添加</span></span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt;                                                        &#123;</span><br><span class="line"><span class="comment">//交互逻辑：会自动触发表现逻辑</span></span><br><span class="line">            CounterModel.Count.Value++;</span><br><span class="line">       &#125;)</span><br><span class="line">            </span><br><span class="line">       <span class="comment">//按钮删除</span></span><br><span class="line">       trans.....</span><br><span class="line">       <span class="comment">//实现传送</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">//实现其他功能...</span></span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当Controller写了很多的交互逻辑，就会越来越臃肿，越来越难以维护，所以需要有个方式来解决：</p><p>这里就开始引入命令模式<code>Command</code>来解决</p><p>定义ICommand接口，定义里边的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例实现接口的脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameModel.KillCount.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> SubCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameModel.KillCount.Value--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里定义类实现了ICommand接口，可以用class也可以用struct，只是因为游戏里边如果交互逻辑有很多，每用一个都去new一个class的话会造成更多性能消耗，而使用struct内存管理效率就要高很多，像unity中的vector3&#x2F;2都是用struct实现的</p><p>这样就可以回到Controller层下把相应的交互逻辑修改了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterViewController</span>：<span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//按钮添加</span></span><br><span class="line">        transform.Find(<span class="string">&quot;BtnAdd&quot;</span>).GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt;                                                        &#123;</span><br><span class="line"><span class="comment">//交互逻辑：会自动触发表现逻辑</span></span><br><span class="line">            <span class="keyword">new</span> AddCountCommand().Execute;</span><br><span class="line">       &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        transform.Find(<span class="string">&quot;BtnSub&quot;</span>).GetComponent&lt;Button&gt;().onClick.AddListener(()=&gt;                                                        &#123;</span><br><span class="line"><span class="comment">//交互逻辑：会自动触发表现逻辑</span></span><br><span class="line">            <span class="keyword">new</span> SubCountCommand().Execute;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Command符合读写分离原则(CQRS)。<strong>Command模式就是逻辑的调用和执行是分离的</strong>，我们知道一个方法的调用和执行是不分离的，因为一旦调用方法，方法也就执行了，但是Command模式能够做到调用和执行在空间和时间上是可以分离的</p><p>而Command模式有了该特点，我们就可以通过不同的数据结果去组织Command调用，比如命令队列等</p><p><strong>总结：</strong></p><p>在引入了Command模式后，就相当于完成了底层系统与表现层的搭建了，这时候看的话，ViewController就是对应的表现层，而其他的诸如Model、Command等都是属于底层系统，这样也就意味着底层系统不变的情况下，我们可以使用不同的表现层来体现我们的逻辑，也就是可以快速地移植到不同的系统上</p><p>框架搭建到这里，此时整体框架遵循以下规则：</p><ul><li>事件由系统层 向 表现层 发送</li><li>表现层只能用Command改变底层系统层的状态(数据)</li><li>表现层可以直接查询数据</li></ul><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>模块化可以从以下两个角度去分析：</p><ul><li><strong>模块对象如何获取</strong></li><li><strong>如何增加一个模块</strong></li></ul><p>以当前框架举例：</p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240725153612663.png" alt="image-20240725153612663"></p><p>能满足模块化需求的只有Model层可以算作一个代码模块。因为Command算作操作，且Command对象是不可以获取的，而Model是共享的，可以被很多地方引用且自身也有状态，所以可以当做为一个代码模块</p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240725154122559.png" alt="image-20240725154122559"></p><p>这里的Model是一个静态类，从模块化的角度出发：</p><ul><li>静态类可以直接获取</li><li>扩展一个静态类 ＝ 加上一个static关键字</li></ul><p>但是还要考虑到静态类如果要模块化，目前会遇到的问题有：</p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240725154407182.png" alt="image-20240725154407182"></p><p>而为此我们需要解决</p><ul><li>静态类没有访问限制</li><li>static扩展模块，模块的识别度不高</li></ul><p>为了很好地解决以上问题，我们就需要用到单例模式，通过泛型单例来实现我们的模块化处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（四）</title>
      <link href="/2024/07/08/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/07/08/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="道具表"><a href="#道具表" class="headerlink" title="道具表"></a>道具表</h1><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240710151501203.png" alt="image-20240710151501203"></p><h1 id="打图集"><a href="#打图集" class="headerlink" title="打图集"></a>打图集</h1><p>前提：已经安装有<code>2D Sprite</code></p><p>就可以通过Create- &gt; 2D-&gt;Sprite Atlas创建图集了，将需要在同一个图集的图片添加进去即可完成打图集的操作</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240710150234166.png" alt="image-20240710150234166"></p><p>图集完成后要为其创建一个到时候要对应打包上去的命名</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240710150354474.png" alt="image-20240710150354474"></p><p>同时在道具表上，我们也可以通过对应图集的名字加上物品的编号来填进道具表对应的字段下，方便后续数据操作能够找到对应物品对应的图片是什么样的</p><p>通过将道具表(excel)转换为json数据：<a href="https://www.bejson.com/json/col2json/">https://www.bejson.com/json/col2json/</a></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240710151546285.png" alt="image-20240710151546285"></p><p>再定义存储json的包，将每个json数据都存储在其中，方便接下来的操作，同时也要为json数据也定义一个AB包命名，后续也要进行打包操作</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240710152558085.png" alt="image-20240710152558085"></p><h1 id="通过Lua读取json表"><a href="#通过Lua读取json表" class="headerlink" title="通过Lua读取json表"></a>通过Lua读取json表</h1><p>通过打包完成或者拉取对应的AB包后，接下来就是通过Lua来读取AB包中的json数据，将其解析出来获取我们需要的道具表</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--先把json表从 AB包中加载出来</span></span><br><span class="line"><span class="comment">--加载的Json文件  —— TextAsset对象</span></span><br><span class="line"><span class="keyword">local</span> txt = ABMgr:LoadRes(<span class="string">&quot;json&quot;</span>,<span class="string">&quot;ItemData&quot;</span>,typeof(TextAsset))</span><br><span class="line"><span class="comment">--获取它的文本信息进行json解析</span></span><br><span class="line"><span class="built_in">print</span>(txt.text)</span><br><span class="line"><span class="keyword">local</span> itemList = Json.decode(txt.text)</span><br></pre></td></tr></table></figure><h1 id="面板逻辑"><a href="#面板逻辑" class="headerlink" title="面板逻辑"></a>面板逻辑</h1><p>Lua脚本编写逻辑的步骤基本上是一致的：</p><ol><li>实例化面板对象</li><li>找到对象的组件</li><li>添加对应事件</li><li>逻辑处理</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--只要是个新的对象 我们就一定要新建一张表</span></span><br><span class="line">MainPanel = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--让别人在看到这个lua代码时 可以知道这个表(对象)有什么变量</span></span><br><span class="line"><span class="comment">--关联的面板对象</span></span><br><span class="line">MainPanel.panelObj = <span class="literal">nil</span></span><br><span class="line"><span class="comment">--对应面板的组件</span></span><br><span class="line">MainPanel.btnPlay = <span class="literal">nil</span></span><br><span class="line">MainPanel.btnSkill = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--需要做实例化面板对象</span></span><br><span class="line"><span class="comment">--为这个面板处理对应的逻辑 —— 按钮点击</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainPanel:Init</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">--面板对象没有实例化过 才去实例化处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">self</span>.panelObj == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="comment">--1.实例化面板对象 ABMgr + 设置父对象</span></span><br><span class="line">        <span class="built_in">self</span>.panelObj = ABMgr:LoadRes(<span class="string">&quot;ui&quot;</span>,<span class="string">&quot;MainPanel&quot;</span>,typeof(GameObject))</span><br><span class="line">        <span class="built_in">self</span>.panelObj.transform:SetParent(Canvas,<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">--2.找到对应控件</span></span><br><span class="line">        <span class="comment">--找到子对象 再找到身上挂载的 我们接下来需要用到的脚本/组件</span></span><br><span class="line">        <span class="built_in">self</span>.btnPlay = <span class="built_in">self</span>.panelObj.transform:Find(<span class="string">&quot;btnPlay&quot;</span>):GetComponent(typeof(Button))</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">self</span>.btnPlay)</span><br><span class="line">        <span class="comment">--3.为组件加上事件监听，进行点击等的逻辑处理</span></span><br><span class="line">        <span class="comment">--这里不能通过直接.来传入自己的函数，否则无法使用self获取内容</span></span><br><span class="line">        <span class="comment">--需要使用匿名函数</span></span><br><span class="line">        <span class="built_in">self</span>.btnPlay.onClick:AddListener(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">            <span class="built_in">self</span>:btnPlayOnClick()</span><br><span class="line">        <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainPanel:ShowPanel</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>:Init()</span><br><span class="line">    <span class="built_in">self</span>.panelObj:SetActive(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainPanel:HideShow</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">self</span>.panelObj:SetActive(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MainPanel:btnPlayOnClick</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123456</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式基类</title>
      <link href="/2024/06/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%B1%BB/"/>
      <url>/2024/06/28/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（三）</title>
      <link href="/2024/06/27/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/06/27/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="xLua"><a href="#xLua" class="headerlink" title="xLua"></a>xLua</h1><p>unity中的Lua热更新方案的本质：</p><p>为Unity提供Lua编程能力</p><p><strong>让C#和Lua可以相互调用访问</strong>（C# 调用 Lua，Lua 调用 C#）</p><p>xLua的前置安装内容：</p><ol><li><strong>安装XLua</strong></li></ol><p>通过Github下载对应的xLua包后，把对应的这两个文件夹拖到工程里边去</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240627225747362.png" alt="image-20240627225747362"></p><p>在工程的标签上边就能看到XLua选项了,可以先让其生成一下内容：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240627230112278.png" alt="image-20240627230112278"></p><ol start="2"><li>安装AB包</li></ol><h1 id="C-调用Lua"><a href="#C-调用Lua" class="headerlink" title="C#调用Lua"></a>C#调用Lua</h1><p>C#调用Lua的前提是要先创建一个<strong>Lua解析器</strong>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lua解析器，</span></span><br><span class="line">LuaEnv env = <span class="keyword">new</span> LuaEnv();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行Lua语言</span></span><br><span class="line">env.DoString(<span class="string">&quot;print(&#x27;Hello World&#x27;)&quot;</span>)</span><br></pre></td></tr></table></figure><p>命名空间也要导入<code>using XLua</code></p><p>对应的其他方法还有：</p><ul><li>env.Tick()</li><li>env.Dispose()</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除Lua中没有被手动释放的对象  ————&gt; 垃圾回收</span></span><br><span class="line">       <span class="comment">//一般用于帧更新 或者 场景切换时执行</span></span><br><span class="line">       env.Tick();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//销毁Lua解析器</span></span><br><span class="line">       env.Dispose();</span><br></pre></td></tr></table></figure><p>同时我们知道在Lua语言中可以通过<code>require</code>来进行多脚本的执行，所以我们也可以通过解析器里边利用Lua语言来实现多个脚本执行的语句，这时候就要知道C#该如何去查找到对应的其他要调用的Lua内容在哪里？</p><p>默认来说都是在<code>Resources</code>资源包下来查找的，所以我们要在那里定义我们要调用的Lua脚本内容：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240628164357292.png" alt="image-20240628164357292"></p><p><strong>重点：由于Unity中读取文档类型的内容不支持.lua，所以我们如果通过lua编辑工具编辑.lua的脚本后，放到unity上需要为其添加一个.txt后缀！</strong></p><p>最后是回到C#上去调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Lua语言实现 多脚本执行</span></span><br><span class="line">env.DoString(<span class="string">&quot;require(&#x27;Main&#x27;)&quot;</span>);</span><br></pre></td></tr></table></figure><p>这样就能够实现我们Lua语言的多脚本执行内容了，但是同样的，由于热更新本身也是在Resources文件夹下进行下载和加载的，所以正常来说，我们还需要自定义文件加载的路径</p><h2 id="文件加载重定向"><a href="#文件加载重定向" class="headerlink" title="文件加载重定向"></a>文件加载重定向</h2><p>通过使用Lua解析器提供的<code>AddLoader</code>方法来实现文件加载重定向：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xlua提供的一个 路径重定向 的方法</span></span><br><span class="line"><span class="comment">//允许我们自定义加载Lua文件的规则</span></span><br><span class="line"><span class="comment">//当我们执行Lua语言调用require时，它就会执行我们自定义传入的这个函数</span></span><br><span class="line">env.AddLoader(MyCustomLoader);</span><br><span class="line"></span><br><span class="line">env.DoString(<span class="string">&quot;require(&#x27;Main&#x27;)&quot;</span>);</span><br></pre></td></tr></table></figure><p>由于AddLoader方法本质上是一个委托，所以可以传入多个回调函数的，这些回调函数模板就是这样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动调用  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">byte</span>[] <span class="title">MyCustomLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//处理相关逻辑</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>所以通过这个方法，当我们需要用到require找到其他lua脚本的时候，该方法就会执行我们自定义传入的这个函数，从而找到需要的内容，它们也遵循这样的顺序，当中途找到的话会直接弹回，不会继续往下找了：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240628181136548.png" alt="image-20240628181136548"></p><p>完整的回调函数方法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">byte</span>[] <span class="title">MyCustomLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//传入的参数是require执行的lua脚本文件名</span></span><br><span class="line">       <span class="comment">//拼接要加载的文件所在路径</span></span><br><span class="line">       <span class="built_in">string</span> path = Application.dataPath + <span class="string">&quot;/Lua/&quot;</span> + filePath + <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line">       Debug.Log(path);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//有路径就加载对应的文件</span></span><br><span class="line">       <span class="comment">//通过文件读写类来实现</span></span><br><span class="line">       <span class="keyword">if</span>(File.Exists(path))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> File.ReadAllBytes(path); </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(<span class="string">&quot;MyCustomLoader重定向失败&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同时要注意的是，这次我们重定向的要执行的Lua脚本，不再需要将其后缀名多加一个.txt了，而是直接使用.lua即可。（在后续进行完整性功能开发的时候，这块还是要改成以.txt为结尾）</p><p>接下来就是要从AB包中去加载lua文件了</p><h2 id="Lua解析器管理器"><a href="#Lua解析器管理器" class="headerlink" title="Lua解析器管理器"></a>Lua解析器管理器</h2><p>在实际开发中，我们不可能通过每一个脚本内容在里边定义一个解析器再进行Lua脚本的编写与使用，同时我们也知道解析器一般情况下是唯一的，所以这时候就要定义一个Lua解析器管理器来统一进行管理并维护唯一的解析器：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> XLua;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LuaManager</span> : <span class="title">BaseManager</span>&lt;<span class="title">LuaManager</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解析器</span></span><br><span class="line">    <span class="keyword">private</span> LuaEnv luaEnv;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 初始化解析器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (luaEnv != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        luaEnv = <span class="keyword">new</span> LuaEnv();</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        luaEnv.AddLoader(MyCustomLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">byte</span>[] <span class="title">MyCustomLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//传入的参数是require执行的lua脚本文件名</span></span><br><span class="line">        <span class="comment">//拼接要加载的文件所在路径</span></span><br><span class="line">        <span class="built_in">string</span> path = Application.dataPath + <span class="string">&quot;/Lua/&quot;</span> + filePath + <span class="string">&quot;.lua&quot;</span>;</span><br><span class="line">        Debug.Log(path);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有路径就加载对应的文件</span></span><br><span class="line">        <span class="comment">//通过文件读写类来实现</span></span><br><span class="line">        <span class="keyword">if</span> (File.Exists(path))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> File.ReadAllBytes(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;MyCustomLoader重定向失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 执行Lua语言</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;str&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoString</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.DoString(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 释放资源</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Tick</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.Tick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        luaEnv.Dispose();</span><br><span class="line">        luaEnv = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重定向定位到AB包中"><a href="#重定向定位到AB包中" class="headerlink" title="重定向定位到AB包中"></a>重定向定位到AB包中</h2><p>Lua脚本会放在AB包，最终我们要通过加载AB包，然后再加载其中的Lua脚本资源</p><p>AB包中如果要加载Lua内容，则后缀还是要改为以.txt为结尾！</p><p>然后先尝试将修改完成后的lua脚本进行打包：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240629142515134.png" alt="image-20240629142515134"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240629142010050.png" alt="image-20240629142010050"></p><p>这时候进行打包实际上会报错，一般来说是因为XLua的内容和资源没有被清空。所以要先对XLua进行清空 <code>XLua → Clear Generated Code</code></p><p>打包成功：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240629143111082.png" alt="image-20240629143111082"></p><p>这时候就可以重新编写一个新的从AB包中重定向的方法内容了：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定向加载AB包路径</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="built_in">byte</span>[] <span class="title">MyCustomABLoader</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> filePath</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/加载AB包</span></span><br><span class="line">        <span class="comment">//string path = Application.streamingAssetsPath + &quot;/lua&quot;;</span></span><br><span class="line">        <span class="comment">//AssetBundle ab = AssetBundle.LoadFromFile(path);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/加载Lua文件并返回byte[]</span></span><br><span class="line">        <span class="comment">//TextAsset tx = ab.LoadAsset&lt;TextAsset&gt;(filePath + &quot;.lua&quot;);</span></span><br><span class="line">        <span class="comment">//return tx.bytes;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过前边自定义的资源管理器来进行加载           —— 要用同步加载！</span></span><br><span class="line">        TextAsset lua = ABMgr.GetInstance().LoadRes&lt;TextAsset&gt;(<span class="string">&quot;lua&quot;</span>, filePath + <span class="string">&quot;.lua&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (lua != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> lua.bytes;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Debug.Log(<span class="string">&quot;MyCustomABLoader重定向失败，文件名为：&quot;</span> + filePath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样就完成了两个重定向的方法内容，一个对应的是我们Unity里边默认我们创建好的放置lua脚本文件的内容，一个对应的是实际应该打包后从AB包中去重定向对应lua脚本的方法。</p><p>在实际的开发测试中，尤其是在开发的同时要进行测试阶段，这个时候我们一般实际上是采用第一种方式，也就是从默认的放置lua脚本文件的重定向方法里边去进行测试，因为我们不会在测试的时候还要先打包再进行测试，这样会拉长开发的周期</p><h2 id="全局变量获取"><a href="#全局变量获取" class="headerlink" title="全局变量获取"></a>全局变量获取</h2><p>获取方式：<strong>LuaEnv中的 Global变量</strong></p><p>通过在我们自定义的Lua脚本存放的文件下进行lua脚本的编写，然后通过C#来测试能否获取里边对应的变量，这里就要用到Lua语言里边的_G表的内容了，因为Lua中 _G 表记录了该脚本下所有的属性信息，这里就可以在解析器管理器中也定义一个可以获取的属性来记录 _G 表：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 得到lua中的_G</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> LuaTable Global</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (luaEnv == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;LuaEnv未初始化，自动初始化&quot;</span>);</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> luaEnv.Global; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一个就是回到Lua脚本里边去定义一个新的方法，或者在原先的Main.lua里边编写，这里要注意的是我们其实可以只重定向一个lua脚本，只要再其调用的lua脚本里边再次通过<code>require</code>在lua里边直接调用其他的脚本就可以了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一个重定向的Lua脚本&quot;</span>)</span><br><span class="line"><span class="comment">-- Unity中写Lua执行</span></span><br><span class="line"><span class="comment">-- xLua帮我们处理</span></span><br><span class="line"><span class="comment">-- 只要是执行lua脚本 都会自动的进入我们重定向的函数中找对应的文件</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)  <span class="comment">--比如这里就定义了一个新的lua脚本 test.lua</span></span><br></pre></td></tr></table></figure><p>text.lua的变量以及C#中测试调用的变量：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240629155934274.png" alt="image-20240629155934274"></p><p>最后测试结果：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240629160034806.png" alt="image-20240629160034806"></p><p><strong>PS：</strong>同时根据上述测试，可以发现double也可以修饰lua中的float变量，这也意味着：虽然Lua中只有Number、Float数值类型，但是我们可以根据它具体的值(范围)来用对应的C#遍历类型进行存储</p><p>在C#中尝试去修改Lua脚本中变量的值：</p><p>我们不可以直接通过获取到的值来直接进行修改，而是仍然要通过 _G 表的方法才可以真正实现Lua脚本中该变量值的更改：</p><p>修改方法 <strong><code>Global.Set()</code></strong></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//值拷贝 改变i不会影响原来Lua中的值</span></span><br><span class="line">      <span class="built_in">int</span> i = LuaManager.GetInstance().Global.Get&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;firstNum&quot;</span>);</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">      Debug.Log(<span class="string">&quot;firstNum：&quot;</span> + i); <span class="comment">//值没有更改</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//真正改变lua的值： 通过解析器Global的Set方法</span></span><br><span class="line">      LuaManager.GetInstance().Global.Set(<span class="string">&quot;firstNum&quot;</span>, <span class="number">66</span>);</span><br><span class="line">      <span class="built_in">int</span> i2 = LuaManager.GetInstance().Global.Get&lt;<span class="built_in">int</span>&gt;(<span class="string">&quot;firstNum&quot;</span>);</span><br><span class="line">Debug.Log(<span class="string">&quot;firstNum：&quot;</span> + i2); <span class="comment">//值变成了66</span></span><br></pre></td></tr></table></figure><p>另外一个要注意的点：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- C#无法直接获取本地局部变量</span></span><br><span class="line"><span class="keyword">local</span> testLoacal = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>C#也无法获取Lua中本地局部变量</p><h2 id="全局函数获取"><a href="#全局函数获取" class="headerlink" title="全局函数获取"></a>全局函数获取</h2><p>主要分为以下几个类型的全局函数定义：</p><ul><li><p>无参无返回</p><p>Lua函数定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--无参无返回</span></span><br><span class="line">testFun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无参无返回&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#方法里边获取并使用该函数：</p><ul><li>自定义委托</li><li>Action （C#自带）</li><li>UnityAction（Unity自带）</li><li>LuaFunction</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参无返回值的委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomCall</span>()</span>;</span><br><span class="line"></span><br><span class="line">主类下：</span><br><span class="line"> <span class="comment">//无参无返回的获取</span></span><br><span class="line">        <span class="comment">//委托来接取</span></span><br><span class="line">        CustomCall call = LuaManager.GetInstance().Global.Get&lt;CustomCall&gt;(<span class="string">&quot;testFun&quot;</span>);</span><br><span class="line">        call();</span><br><span class="line">        <span class="comment">//另外两种写法：          UnityAction，Action</span></span><br></pre></td></tr></table></figure></li><li><p>有参有返回</p><p>Lua函数定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--有参有返回</span></span><br><span class="line">testFun2 = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;有参有返回&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#方法里边获取并使用该函数：</p><ul><li>自定义委托</li><li>Func</li><li>LuaFunction</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参有返回的委托</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CustomCall2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br><span class="line"></span><br><span class="line">主类下：</span><br><span class="line">     <span class="comment">//有参有返回的获取</span></span><br><span class="line">        CustomCall2 call2 = LuaManager.GetInstance().Global.Get&lt;CustomCall2&gt;(<span class="string">&quot;testFun2&quot;</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;有参有返回：&quot;</span> + call2(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到这里的时候进行测试，会发现其结果报错，也就是说C#此时并没有成功获取到Lua对应的该有参有返回的函数，这是因为前边无参无返回相当于默认的函数，能够被获取到，而有参有返回以及接下来的其他类型函数都属于我们利用C#自定义的委托类型，所以要在对应的委托上边多添加一个标签<code>[CSharpCallLua]</code>,除此之外，要确保XLua有运行过&#96;&#96;</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在XLua命名空间里边提供的，所以记得加 using XLua</span></span><br><span class="line">[<span class="meta">CSharpCallLua</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CustomCall2</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>多返回值</p><p>Lua函数定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--多返回</span></span><br><span class="line">testFun3 = <span class="function"><span class="keyword">function</span><span class="params">(a)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;多返回值&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="literal">false</span>,<span class="string">&quot;123&quot;</span>,a</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#方法里边获取并使用该函数：</p><ul><li>自定义委托<ul><li>Out</li><li>Ref</li></ul></li><li>LuaFunction</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多返回值的委托</span></span><br><span class="line"><span class="comment">//对应out</span></span><br><span class="line">[<span class="meta">CSharpCallLua</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CustomCall3</span>(<span class="params"><span class="built_in">int</span> a, <span class="keyword">out</span> <span class="built_in">int</span> b, <span class="keyword">out</span> <span class="built_in">bool</span> c, <span class="keyword">out</span> <span class="built_in">string</span> s, <span class="keyword">out</span> <span class="built_in">int</span> e</span>)</span>;</span><br><span class="line"><span class="comment">//对应ref</span></span><br><span class="line">[<span class="meta">CSharpCallLua</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">CustomCall4</span>(<span class="params"><span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b, <span class="keyword">ref</span> <span class="built_in">bool</span> c, <span class="keyword">ref</span> <span class="built_in">string</span> s, <span class="keyword">ref</span> <span class="built_in">int</span> e</span>)</span>;</span><br><span class="line"></span><br><span class="line">主类下：</span><br><span class="line"><span class="comment">//多返回值的获取</span></span><br><span class="line">        <span class="comment">//使用 out 和 ref 接收</span></span><br><span class="line">        <span class="comment">//out</span></span><br><span class="line">        CustomCall3 call3 = LuaManager.GetInstance().Global.Get&lt;CustomCall3&gt;(<span class="string">&quot;testFun3&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> b;</span><br><span class="line">        <span class="built_in">bool</span> c;</span><br><span class="line">        <span class="built_in">string</span> d;</span><br><span class="line">        <span class="built_in">int</span> e;</span><br><span class="line">        Debug.Log(<span class="string">&quot;第一个返回值：&quot;</span> + call3(<span class="number">100</span>, <span class="keyword">out</span> b, <span class="keyword">out</span> c, <span class="keyword">out</span> d, <span class="keyword">out</span> e));</span><br><span class="line">        Debug.Log(<span class="string">&quot;其他返回值：&quot;</span>+b+<span class="string">&quot; &quot;</span>+c+<span class="string">&quot; &quot;</span>+d+<span class="string">&quot; &quot;</span>+e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ref</span></span><br><span class="line">        CustomCall4 call4 = LuaManager.GetInstance().Global.Get&lt;CustomCall4&gt;(<span class="string">&quot;testFun4&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> b1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bool</span> c1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">string</span> d1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">int</span> e1 = <span class="number">0</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;第一个返回值：&quot;</span> + call4(<span class="number">100</span>, <span class="keyword">ref</span> b1, <span class="keyword">ref</span> c1, <span class="keyword">ref</span> d1, <span class="keyword">ref</span> e1));</span><br><span class="line">        Debug.Log(<span class="string">&quot;其他返回值：&quot;</span> + b1 + <span class="string">&quot; &quot;</span> + c1 + <span class="string">&quot; &quot;</span> + d1 + <span class="string">&quot; &quot;</span> + e1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//另外一种方式： XLua(不常用)</span></span><br><span class="line">        LuaFunction lf3 = LuaManager.GetInstance().Global.Get&lt;LuaFunction&gt;(<span class="string">&quot;testFun3&quot;</span>);</span><br><span class="line">        <span class="built_in">object</span>[] objs = lf3.Call(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;objs.Length;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;该返回值为：&quot;</span> + objs[i]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>变长参数</p><p>Lua函数定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--变长参数</span></span><br><span class="line">testFun4 = <span class="function"><span class="keyword">function</span><span class="params">(a,...)</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变长参数&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>C#方法里边获取并使用该函数：</p><ul><li>自定义委托</li><li>LuaFunction</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变长参数的委托</span></span><br><span class="line">[<span class="meta">CSharpCallLua</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomCall5</span>(<span class="params"><span class="built_in">string</span> a, <span class="keyword">params</span> <span class="built_in">int</span>[] args</span>)</span>;<span class="comment">//变长参数的类型 是根据实际情况来传入的</span></span><br><span class="line"></span><br><span class="line">主类下</span><br><span class="line">        <span class="comment">//变长参数</span></span><br><span class="line">        CustomCall5 call5 = LuaManager.GetInstance().Global.Get&lt;CustomCall5&gt;(<span class="string">&quot;testFun4&quot;</span>);</span><br><span class="line">        call5(<span class="string">&quot;123&quot;</span>,<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">55</span>, <span class="number">6621</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//另外一种方式：XLua</span></span><br><span class="line">        LuaFunction lf4 = LuaManager.GetInstance().Global.Get&lt;LuaFunction&gt;(<span class="string">&quot;testFun4&quot;</span>);</span><br><span class="line">        lf4.Call(<span class="string">&quot;456&quot;</span>, <span class="number">63</span>, <span class="number">54</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">96</span>, <span class="number">666</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要通用的传入值的话，一般可以使用<code>params object[]</code></p></li></ul><h2 id="不同方式映射table"><a href="#不同方式映射table" class="headerlink" title="不同方式映射table"></a>不同方式映射table</h2><h3 id="List和Dictionary映射"><a href="#List和Dictionary映射" class="headerlink" title="List和Dictionary映射"></a>List和Dictionary映射</h3><p>Lua定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--List</span></span><br><span class="line">testList = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">testList2 = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;65&quot;</span>,<span class="literal">true</span>,<span class="number">1.5</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">--Dictionary</span></span><br><span class="line">testDic = &#123;</span><br><span class="line">[<span class="string">&quot;1&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">[<span class="string">&quot;2&quot;</span>] = <span class="number">2</span>,</span><br><span class="line">[<span class="string">&quot;3&quot;</span>] = <span class="number">3</span>,</span><br><span class="line">[<span class="string">&quot;4&quot;</span>] = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testDic2 = &#123;</span><br><span class="line">[<span class="string">&quot;1&quot;</span>] = <span class="number">1</span>,</span><br><span class="line">[<span class="literal">true</span>] = <span class="number">1</span>,</span><br><span class="line">[<span class="literal">false</span>] = <span class="literal">true</span>,</span><br><span class="line">[<span class="string">&quot;123&quot;</span>] = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#脚本进行调用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同类型List</span></span><br><span class="line">       List&lt;<span class="built_in">int</span>&gt; list = LuaManager.GetInstance().Global.Get&lt;List&lt;<span class="built_in">int</span>&gt;&gt;(<span class="string">&quot;testList&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.Count; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(list[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//不同类型List</span></span><br><span class="line">       List&lt;<span class="built_in">object</span>&gt; list2 = LuaManager.GetInstance().Global.Get&lt;List&lt;<span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;testList2&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list2.Count; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(list2[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//同类型Dictionary</span></span><br><span class="line">       Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; dic = LuaManager.GetInstance().Global.Get&lt; Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;&gt; (<span class="string">&quot;testDic&quot;</span>);</span><br><span class="line">       <span class="keyword">foreach</span>(<span class="built_in">string</span> item <span class="keyword">in</span> dic.Keys)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(item + <span class="string">&quot;-&quot;</span> + dic[item]);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//不同类型Dictionary</span></span><br><span class="line">       Dictionary&lt;<span class="built_in">object</span>, <span class="built_in">object</span>&gt; dic2 = LuaManager.GetInstance().Global.Get&lt;Dictionary&lt;<span class="built_in">object</span>, <span class="built_in">object</span>&gt;&gt;(<span class="string">&quot;testDic2&quot;</span>);</span><br><span class="line">       <span class="keyword">foreach</span> (<span class="built_in">object</span> item <span class="keyword">in</span> dic2.Keys)</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(item + <span class="string">&quot;-&quot;</span> + dic2[item]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>PS：这里在C#中对获取到的List和Dictionary进行改变并不会导致Lua中定义的值，属于浅拷贝</p><h3 id="类映射"><a href="#类映射" class="headerlink" title="类映射"></a>类映射</h3><p>如果要把Lua中的表映射到C#中的类对象中，就要在C#中声明一个自定义类，其中的成员变量命名要和Lua中表的自定义索引一致，但如果成员变量缺少或者增加并不会导致报错，只是赋值不了而已</p><p>Lua中定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">testClas = &#123;</span><br><span class="line">testInt = <span class="number">2</span>,</span><br><span class="line">testBool = <span class="literal">true</span>,</span><br><span class="line">testFloat = <span class="number">1.2</span>,</span><br><span class="line">testString = <span class="string">&quot;123&quot;</span>,</span><br><span class="line">testFun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;132131&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line">testInClass = &#123;</span><br><span class="line">testInInt = <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#中自定义对应的类并使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CallLuaClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在这个类中去声明成员变量</span></span><br><span class="line">    <span class="comment">//名字一定要和 Lua那边的一样</span></span><br><span class="line">    <span class="comment">//公共 私有和保护 没办法赋值</span></span><br><span class="line">    <span class="comment">//这个自定义中的 变量 可以更多也可以更少</span></span><br><span class="line">    <span class="comment">//如果变量比 lua中的少 就会忽略它</span></span><br><span class="line">    <span class="comment">//如果变量比 lua中的多 不会赋值 也会忽略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> testInt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> testBool;</span><br><span class="line">    <span class="comment">//public float testFloat;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> testString;</span><br><span class="line">    <span class="keyword">public</span> UnityAction testFun;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CallLuaInClass testInClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(testInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CallLuaInClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> testInInt;</span><br><span class="line">&#125;</span><br><span class="line">主类下：</span><br><span class="line">     CallLuaClass obj = LuaManager.GetInstance().Global.Get&lt;CallLuaClass&gt;(<span class="string">&quot;testClas&quot;</span>);</span><br><span class="line">        Debug.Log(obj.testInt);</span><br><span class="line">        Debug.Log(obj.testBool);</span><br><span class="line">        <span class="comment">//Debug.Log(obj.testFloat);</span></span><br><span class="line">        Debug.Log(obj.testString);</span><br><span class="line">        Debug.Log(obj.i);</span><br><span class="line">        Debug.Log(<span class="string">&quot;嵌套：&quot;</span> + obj.testInClass.testInInt);</span><br><span class="line">        obj.testFun();</span><br><span class="line">        <span class="comment">//值拷贝 改变了它 不会改变Lua表里的内容</span></span><br><span class="line">        obj.testInt = <span class="number">100</span>;</span><br><span class="line">        CallLuaClass obj2 = LuaManager.GetInstance().Global.Get&lt;CallLuaClass&gt;(<span class="string">&quot;testClas&quot;</span>);</span><br><span class="line">        Debug.Log(obj2.testInt);</span><br></pre></td></tr></table></figure><p>PS：类映射本质上也是浅拷贝，所以不会改变Lua中定义的值</p><h3 id="接口映射"><a href="#接口映射" class="headerlink" title="接口映射"></a>接口映射</h3><p>接口映射的方式和类也很相似，区别在于我们在进行自定义接口构建的时候，由于接口的形式导致我们只能在里边定义属性来获取Lua中的变量，多了少了不会报错，还有一个区别在于接口映射需要用到特性<code>[CSharpCallLua]</code>，使用该特性要注意当我们对C#的该接口进行属性的更改时要通过XLua重新生成代码</p><p>Lua中的定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">testClas2 = &#123;</span><br><span class="line">testInt = <span class="number">2</span>,</span><br><span class="line">testBool = <span class="literal">true</span>,</span><br><span class="line">testFloat = <span class="number">1.2</span>,</span><br><span class="line">testString = <span class="string">&quot;123&quot;</span>,</span><br><span class="line">testFun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;132131&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C#中自定义接口并使用：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接口中是不允许有成员变量的 </span></span><br><span class="line"><span class="comment">//我们用属性来接受</span></span><br><span class="line"><span class="comment">//接口和类规则一样 其中的属性多了少了 不影响结果 无非就是忽略他们</span></span><br><span class="line"><span class="comment">//嵌套几乎和类一样 无非 是要遵循接口的规则</span></span><br><span class="line">[<span class="meta">CSharpCallLua</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICSharpCallInterface</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> testInt</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> testBool</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/float testFloat</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/&#123;</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/    get;</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/    set;</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>/&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> testString</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UnityAction testFun</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">float</span> testFloat222</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>;</span><br><span class="line">        <span class="keyword">set</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">主类下：</span><br><span class="line">       ICSharpCallInterface obj = LuaManager.GetInstance().Global.Get&lt;ICSharpCallInterface&gt;(<span class="string">&quot;testClas2&quot;</span>);</span><br><span class="line">        Debug.Log(obj.testInt);</span><br><span class="line">        Debug.Log(obj.testBool);</span><br><span class="line">        Debug.Log(<span class="string">&quot;新加的：&quot;</span> + obj.testFloat222);</span><br><span class="line">        Debug.Log(obj.testString);</span><br><span class="line">        obj.testFun();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接口拷贝 是引用拷贝 改了值 lua表中的值也变了</span></span><br><span class="line">        obj.testInt = <span class="number">10000</span>;</span><br><span class="line">        ICSharpCallInterface obj2 = LuaManager.GetInstance().Global.Get&lt;ICSharpCallInterface&gt;(<span class="string">&quot;testClas2&quot;</span>);</span><br><span class="line">        Debug.Log(obj2.testInt);</span><br></pre></td></tr></table></figure><p><strong>PS：接口映射是深拷贝，在C#中对对应的值进行更改时，Lua中对应的属性内容也会发生更改！</strong></p><h3 id="LuaTable映射"><a href="#LuaTable映射" class="headerlink" title="LuaTable映射"></a>LuaTable映射</h3><p>LuaTable就是XLua提供给我们的类来获取Lua中的表和改变量，直接通过Get和Set来获得</p><p>但是通常不建议使用LuaTable映射的方式，效率比较低</p><p>同时LuaTable每次使用后都要使用Dispose，否则很容易造成内存浪费</p><h3 id="CSharpCallLua特性"><a href="#CSharpCallLua特性" class="headerlink" title="CSharpCallLua特性"></a>CSharpCallLua特性</h3><p>通常用于：</p><ul><li>自定义委托（常用于全局函数获取）</li><li>接口映射</li></ul><h1 id="▲Lua调用C"><a href="#▲Lua调用C" class="headerlink" title="▲Lua调用C#"></a>▲Lua调用C#</h1><p>因为Lua没法直接访问C#，所以前提是先从C#调用Lua脚本后再把核心逻辑交给Lua来编写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LuaManager.GetInstance().Init();</span><br><span class="line">LuaManager.GetInstance().DoLuaFile(<span class="string">&quot;Main&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="类，类对象，类方法"><a href="#类，类对象，类方法" class="headerlink" title="类，类对象，类方法"></a>类，类对象，类方法</h3><p>Lua调用C#的固定用法为：**<code>CS.命名空间.类名</code>**</p><p>eg： CS.UnityEngine.GameObject</p><p>实例化对象则是通过类名括号的形式来代替 new，因为Lua中没有new操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = CS.UnityEngine.GameObject()</span><br></pre></td></tr></table></figure><p>同时这里有个优化的技巧（面试考点之一），也是一个实用技巧：<strong>通过定义别名(全局变量)来方便存储C#中的类，同时也可以节约性能</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject = CS.UnityEngine.GameObject</span><br><span class="line"><span class="keyword">local</span> obj3 = GameObject(<span class="string">&quot;新的物体1&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>静态方法和静态变量：</strong><code>CS.命名空间.类名.方法/变量</code></p><p><strong>成员变量和成员方法：</strong></p><ul><li><p><strong>实例化对象.变量名</strong></p></li><li><p><strong>实例化对象:方法名</strong></p></li></ul><p>注意成员方法的调用是要用<strong>冒号</strong>！！！</p><p>同时，如果C#中有自定义的类：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;test1:&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyCustomClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义类，前边包括了一个自定义的命名空间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;test2:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Lua中也可以正常调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用C#的自定义类</span></span><br><span class="line"><span class="keyword">local</span> t1 = CS.Test()</span><br><span class="line">t1:Speak(<span class="string">&quot;测试test自定义类&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t2 = CS.MyCustomClass.Test2()</span><br><span class="line">t2:Speak(<span class="string">&quot;测试test2自定义类&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>另外一个内容就是xLua不支持无参泛型函数，所以我们要使用 <code>AddComponent(Type)</code>来实现为对象挂载脚本的操作：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--继承了Mono的类 是不能直接new</span></span><br><span class="line"><span class="keyword">local</span> obj5 = GameObject(<span class="string">&quot;加脚本测试&quot;</span>)</span><br><span class="line"><span class="comment">--通过GameObject的AddComponent添加脚本</span></span><br><span class="line"><span class="comment">--xlua提供了一个重要方法 typeof来得到类的Type</span></span><br><span class="line"><span class="comment">--xlua中不支持无参泛型函数，所以用使用其另外一个重载</span></span><br><span class="line">obj5:AddComponent(typeof(CS.LuaCallCSharp))</span><br></pre></td></tr></table></figure><h3 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h3><ul><li><strong>枚举</strong></li></ul><p>枚举的使用和类的使用一致，只是不用实例化，通过<code>CS.命名空间.枚举名.枚举成员</code></p><p>即可，其中自定义的枚举类型也是相同的方式</p><p>定义好测试用的枚举</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="meta">#<span class="keyword">region</span> CallEnum</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> E_myEnum</span><br><span class="line">&#123;</span><br><span class="line">    Idle,</span><br><span class="line">    Walk,</span><br><span class="line">    Atk</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endregion</span></span></span><br></pre></td></tr></table></figure><p>Lua中定义：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--枚举的调用规则和类的调用规则一致</span></span><br><span class="line"><span class="comment">--CS.命名空间.枚举名.枚举成员</span></span><br><span class="line"><span class="comment">--也支持取别名</span></span><br><span class="line">PrimitiveType = CS.UnityEngine.PrimitiveType</span><br><span class="line">GameObject = CS.UnityEngine.GameObject</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj = GameObject.CreatePrimitive(PrimitiveType.Cube)</span><br><span class="line"></span><br><span class="line"><span class="comment">--自定义枚举 注意命名空间即可</span></span><br><span class="line">E_NewEnum = CS.E_NewEnum</span><br><span class="line"><span class="keyword">local</span> c = E_NewEnum.Idle</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">--枚举转换</span></span><br><span class="line"><span class="comment">--数值转枚举</span></span><br><span class="line"><span class="keyword">local</span> a = E_NewEnum.__CastFrom(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">--字符串转枚举</span></span><br><span class="line"><span class="keyword">local</span> b = E_NewEnum.__CastFrom(<span class="string">&quot;Atk&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><ul><li><strong>数组、List和Dictionary</strong></li></ul><p>数组、List和Dictionary的使用在Lua中也遵循C#的规则</p><p>其中List和字典的创建后还要先进行一次实例化，第一步是设置别名，第二步才算是实例化</p><p><strong>数组的创建：<code>CS.System.Array.CreateInstance(数组类型，长度)</code></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--Lua中创建一个C#数组 可以使用Array类中的静态方法即可</span></span><br><span class="line"><span class="keyword">local</span> array2 = CS.System.Array.CreateInstance(typeof(CS.System.Int32),<span class="number">10</span>) </span><br><span class="line"><span class="built_in">print</span>(array2.Length)</span><br><span class="line"><span class="built_in">print</span>(array2[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(array2[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.array2[<span class="number">0</span>])</span><br><span class="line"><span class="comment">--遍历元素</span></span><br><span class="line"><span class="comment">--虽然lua中索引是从1开始的，但是数组是C#的规则，所以要按C#的来！</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,obj.array2.Length<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(obj.array2[i])</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>List的创建：<code>CS.System.Collections.Generic.List(类型)</code></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在Lua中创建一个List对象</span></span><br><span class="line"><span class="comment">--这里相当于得到一个别名，还需要进行实例化</span></span><br><span class="line"><span class="keyword">local</span> List_String = CS.System.Collections.Generic.List(CS.System.String)</span><br><span class="line"><span class="comment">--实例化</span></span><br><span class="line"><span class="keyword">local</span> list3 = List_String()</span><br><span class="line">list3:Add(<span class="string">&quot;==454984==&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(list3[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>PS：List和字典的添加操作由于都是成员变量，所以使用对应的方法的时候要记得使用<code>：</code></p><p><strong>Dictionary的创建：<code>CS.System.Collections.Generic.Dictionary(类型，类型)</code></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在Lua中创建一个字典对象</span></span><br><span class="line"><span class="comment">--相当于得到了一个Dictionary&lt;string，vector3&gt;的一个别名，还要进行实例化</span></span><br><span class="line"><span class="keyword">local</span> Dic_String_Vector3 = CS.System.Collections.Generic.Dictionary(CS.System.String,CS.UnityEngine.Vector3)</span><br><span class="line"><span class="comment">--实例化</span></span><br><span class="line"><span class="keyword">local</span> dic2 = Dic_String_Vector3()</span><br><span class="line">dic2:Add(<span class="string">&quot;123&quot;</span>,CS.UnityEngine.Vector3.right)</span><br><span class="line"><span class="comment">--遍历</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(dic2) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>PS：由于字典的特殊性，Lua中无法通过直接[键]的方式获取到对应的值，需要通过其他方法来获取或修改键</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在Lua中创建的字典 直接通过[键]是得不到值的，只会是nil！</span></span><br><span class="line"><span class="built_in">print</span>(dic2[<span class="string">&quot;123&quot;</span>])</span><br><span class="line"><span class="comment">--如果要通过键来获取值，要通过：</span></span><br><span class="line"><span class="built_in">print</span>(dic2:get_Item(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="comment">--设置对应键的值</span></span><br><span class="line">dic2:set_Item(<span class="string">&quot;123&quot;</span>,<span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">print</span>(dic2:get_Item(<span class="string">&quot;123&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h3><p>Lua可以使用C#中的拓展方法，只是需要在拓展方法对应的静态类前边加上特性<code>LuaCallCSharp</code>然后让Lua生成代码</p><p><strong>PS：该特性也可以提升Lua访问C#类的性能，所以只要Lua中要用到的C#类都建议加上该特性</strong></p><p>C#定义对应的类和内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//想要在Lua中使用拓展方法 一定要在工具类前边加上特定的标签</span></span><br><span class="line"><span class="comment">//建议在 Lua中要使用的类都使用这个特性，可以提升性能</span></span><br><span class="line">[<span class="meta">LuaCallCSharp</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Move</span>(<span class="params"><span class="keyword">this</span> Test4 obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(obj.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test4</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name = <span class="string">&quot;测试拓展方法内容&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;饮食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Lua上就可以进行调用相应的拓展方法了：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--静态方法</span></span><br><span class="line">Test4 = CS.Test4</span><br><span class="line">Test4.Eat()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj = Test4()</span><br><span class="line"><span class="comment">--成员方法</span></span><br><span class="line">obj:Speak(<span class="string">&quot;132132&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用拓展方法</span></span><br><span class="line">obj:Move()</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><strong>ref和out</strong></li></ul><p>如果Lua使用C#中带有ref和out的函数，都是以多返回值的形式使用的，在传参时要遵循：</p><p>ref需要用值占位，out可以忽略不传</p><p>返回时，如果函数默认有返回值，第一个返回值就是函数的返回值，之后的返回值从左到右一一对应！</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test5</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RefFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">ref</span> <span class="built_in">int</span> b,<span class="keyword">ref</span> <span class="built_in">int</span> c,<span class="built_in">int</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = a + d;</span><br><span class="line">        c = a - d;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">OutFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> b,<span class="keyword">out</span> <span class="built_in">int</span> c,<span class="built_in">int</span> d</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = a;</span><br><span class="line">        c = d;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">222</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">RefOutFun</span>(<span class="params"><span class="built_in">int</span> a,<span class="keyword">out</span> <span class="built_in">int</span> b,<span class="keyword">ref</span> <span class="built_in">int</span> c</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = a * <span class="number">10</span>;</span><br><span class="line">        c = a * <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua调用对应的函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Test5 = CS.Test5;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==================测试ref===================&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> obj = Test5()</span><br><span class="line"><span class="comment">--ref参数 会以多返回值的形式返回给lua</span></span><br><span class="line"><span class="comment">--如果函数存在返回值 那么第一个值就是该返回值</span></span><br><span class="line"><span class="comment">--之后的返回值就是ref的结果，从左到右一一对应</span></span><br><span class="line"><span class="comment">--ref参数需要传入一个默认值</span></span><br><span class="line"><span class="keyword">local</span> a,b,c = obj:RefFun(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==================测试out===================&quot;</span>)</span><br><span class="line"><span class="comment">--out参数</span></span><br><span class="line"><span class="comment">--out参数不需要传占位置的值</span></span><br><span class="line"><span class="keyword">local</span> a,b,c = obj:OutFun(<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==================测试混合使用===================&quot;</span>)</span><br><span class="line"><span class="comment">--混合使用</span></span><br><span class="line"><span class="comment">--ref需要占位 out不用</span></span><br><span class="line"><span class="comment">--第一个是函数的返回值</span></span><br><span class="line"><span class="keyword">local</span> a,b,c = obj:RefOutFun(<span class="number">20</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><ul><li><strong>重载</strong></li></ul><p>Lua支持调用C#的重载函数，但是要注意：</p><p>Lua在调用的时候存在精度分不清的问题，因为Lua中数值类型只有Number，所以在声明C#重载函数的时候，不要重载参数个数相同而精度不同的情况！</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test6</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">float</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">float</span> a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua中使用这些重载方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = CS.Test6()</span><br><span class="line"></span><br><span class="line"><span class="comment">--Lua不支持写重载函数  但是 Lua支持调用C#中的重载函数</span></span><br><span class="line"><span class="built_in">print</span>(obj:Calc())</span><br><span class="line"><span class="built_in">print</span>(obj:Calc(<span class="number">10</span>,<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--Lua中的数值类型只有Number，对于C#中多精度的重载函数支持不太好</span></span><br><span class="line"><span class="comment">--使用时可能会出现问题</span></span><br><span class="line"><span class="built_in">print</span>(obj:Calc(<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(obj:Calc(<span class="number">10.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--解决重载函数含糊的问题 (多精度无法正确判断)</span></span><br><span class="line"><span class="comment">--xLua提供了解决方案 ——  反射机制</span></span><br><span class="line"><span class="comment">--1.通过Type得到C#函数</span></span><br><span class="line"><span class="comment">--2.通过xlua.tofunction转为lua函数然后使用</span></span><br><span class="line"><span class="comment">--成员方法 第一个参数传对象     静态方法  不用传对象</span></span><br><span class="line"><span class="comment">--但是这种方法只要了解即可，尽量不要使用</span></span><br></pre></td></tr></table></figure><h3 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h3><p>委托在Lua中和C#中的使用都差不多，但是在Lua中初始情况下要先进行赋值处理后续才可以通过加号和减号进行相关操作</p><p>C#上定义委托和事件相关的方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test7</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction del;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> UnityAction eventAction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(eventAction != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            eventAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        eventAction = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua上调用委托的方法内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">local</span> obj = CS.Test7()</span><br><span class="line"></span><br><span class="line"><span class="comment">--委托是用来装函数的</span></span><br><span class="line"><span class="comment">--使用C#中的委托就是用来装Lua函数的</span></span><br><span class="line"><span class="keyword">local</span> fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Lua函数fun&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--Lua中没有复合运算符，不可以使用+=</span></span><br><span class="line"><span class="comment">--如果第一次往委托中加函数，会因为最初是nil所以不能使用 +</span></span><br><span class="line"><span class="comment">--所以第一次使用就要使用 = </span></span><br><span class="line">obj.del = fun</span><br><span class="line"></span><br><span class="line"><span class="comment">--第二次以及接下来添加就可以使用添加</span></span><br><span class="line">obj.del = obj.del + fun</span><br><span class="line">obj.del()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==============委托减少函数==============&quot;</span>)</span><br><span class="line">obj.del = obj.del - fun</span><br><span class="line"><span class="comment">--obj.del = obj.del - fun</span></span><br><span class="line">obj.del()</span><br><span class="line"><span class="comment">--清空所有存储的函数</span></span><br><span class="line">obj.del = <span class="literal">nil</span></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PS：由于Lua中不支持 +&#x3D; 和 -&#x3D; ，同时在第一次使用委托的时候，第一次要直接使用 &#x3D; 号进行赋值，相当于注册第一个函数，其次才能通过加和减来进行其他函数的注册</p><p>Lua上调用事件的方法内容：</p><p>要注意事件在Lua上的定义和操作都不太相同，其中是把事件的函数当做是成员方法来调用从而注册下去的。语法就要采用<code>:</code>号了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> fun2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;事件加的函数fun2&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--事件加减函数 和委托完全不一样</span></span><br><span class="line"><span class="comment">--类似成员方法，要使用冒号，冒号事件名(&quot;+&quot;,函数名)</span></span><br><span class="line">obj:eventAction(<span class="string">&quot;+&quot;</span>,fun2)</span><br><span class="line">obj:eventAction(<span class="string">&quot;+&quot;</span>,fun2)</span><br><span class="line"></span><br><span class="line">obj:DoEvent()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;============事件减少函数================&quot;</span>)</span><br><span class="line">obj:eventAction(<span class="string">&quot;-&quot;</span>,fun2)</span><br><span class="line">obj:DoEvent()</span><br><span class="line"></span><br><span class="line"><span class="comment">--事件想要清空所有函数，不可以像委托一样之间设置nil就可以清空</span></span><br><span class="line"><span class="comment">--在C#上定义情空的函数，再在lua中直接调用即可</span></span><br><span class="line">obj:clearEvent()</span><br><span class="line">obj:DoEvent()</span><br></pre></td></tr></table></figure><p>然后是事件的清空，委托可以直接在Lua中为其置空从而达到清除委托中所有函数的目的，而事件不能，但是可以通过在C#上自定义一个清空的方法，然后回到Lua上调用该方法，换种方式进行了清空</p><h3 id="特殊问题"><a href="#特殊问题" class="headerlink" title="特殊问题"></a>特殊问题</h3><ul><li><strong>二维数组</strong></li></ul><p>二维数组的调用并不能直接通过C#那种数组访问方法来进行访问，但是我们可以通过Lua中另外的一种方式来获取对应数组的元素：<code>类对象.数组名:GetLength()</code></p><p>C#定义二维数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test8</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[,] array = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>, <span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">56</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua调用二维数组：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = CS.Test8()</span><br><span class="line"></span><br><span class="line"><span class="comment">--获取长度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取行：&quot;</span>..obj.array:GetLength(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;获取列：&quot;</span>..obj.array:GetLength(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--获取元素</span></span><br><span class="line"><span class="comment">--不能通过[0][0]或者[0,0]访问元素 会报错</span></span><br><span class="line"><span class="built_in">print</span>(obj.array:GetValue(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(obj.array:GetValue(<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">0</span>,obj.array:GetLength(<span class="number">0</span>)<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">for</span> j=<span class="number">0</span>,obj.array:GetLength(<span class="number">1</span>)<span class="number">-1</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(obj.array:GetValue(i,j))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><strong>null和nil的比较</strong></li></ul><p>Lua中C#的null没办法和nil进行比较，所以可以使用以下三种方法来解决这个问题：</p><ol><li>对象:Equals(nil)</li></ol><p>​       前提：传入的对象本身是个object而不是为空</p><ol start="2"><li><p>第二种：在Lua中封装一个全局方法判空</p></li><li><p>第三种：在C#中为Object定义一个拓展方法判空</p></li></ol><p>第一种方法并不常用，第二种的话具体实现就是：</p><p>比如在第一个加载的Lua脚本定义需要的全局函数判空</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--判断全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsNull</span><span class="params">( obj )</span></span></span><br><span class="line"><span class="keyword">if</span> obj == <span class="literal">nil</span> <span class="keyword">or</span> obj:Equals(<span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>然后在被调用的另外一个lua脚本中需要使用判空的时候进行对应操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> IsNull(rig) <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;添加组件成功&quot;</span>)</span><br><span class="line">rig = obj:AddComponent(typeof(Rigidbody))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第三种方法的具体实现：</p><p>首先在C#上定义为Lua准备的拓展方法，记得要在类前边添加对应的特性</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓展一个为Object判空的方法，给Lua用</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsNull</span>(<span class="params"><span class="keyword">this</span> Object obj</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> obj == <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后在Lua上进行调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rig:IsNull() <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;添加组件成功&quot;</span>)</span><br><span class="line">rig = obj:AddComponent(typeof(Rigidbody))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="让系统类型和Lua能互相访问"><a href="#让系统类型和Lua能互相访问" class="headerlink" title="让系统类型和Lua能互相访问"></a><strong>让系统类型和Lua能互相访问</strong></h4><p>上边知道Lua如果要调用C#的内容需要用到相关的特性</p><p>CSharpCellLua ： 委托 和 接口</p><p>LuaCallCSharp：拓展方法时</p><p>但是无法为系统类或者第三方库代码添加上这两个特性</p><p>比如这种情况：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GameObject = CS.UnityEngine.GameObject</span><br><span class="line">UI = CS.UnityEngine.UI</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> slider = GameObject.Find(<span class="string">&quot;Slider&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(slider)</span><br><span class="line"><span class="keyword">local</span> sliderScript = slider:GetComponent(typeof(UI.Slider))</span><br><span class="line"><span class="built_in">print</span>(sliderScript)</span><br><span class="line"><span class="comment">--添加监听事件</span></span><br><span class="line">sliderScript.onValueChanged:AddListener(<span class="function"><span class="keyword">function</span><span class="params">(f)</span></span></span><br><span class="line"><span class="built_in">print</span>(f)</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这时候就要用到系统类里边的UnityAction<Float>方法了，但是已知Lua调用C#委托必须使用特性，所以会产生报错，这时候就要了解如何解决无法为其系统类添加特性的问题：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#region 系统类型加特性</span><br><span class="line">public static class Test10</span><br><span class="line">&#123;</span><br><span class="line">    [CSharpCallLua]</span><br><span class="line">    public static List&lt;Type&gt; csharpCallLuaList = new List&lt;Type&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        typeof(UnityAction&lt;float&gt;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    [LuaCallCSharp]</span><br><span class="line">    public static List&lt;Type&gt; luaCallCsharpList = new List&lt;Type&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        typeof(GameObject)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：一定是在静态类中，一定要重新生成代码，把所有特性汇总在此处！</strong></p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>Lua中用C#协程开启和关闭规则和C#中一样，C#中的yield return相当于Lua中的coroutine.yield</p><p>Lua中定义和调用协程：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--C#中协程启动都是通过继承了Mono的类 通过里边的启动函数StartCoroutine</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--xLua提供的一个工具表</span></span><br><span class="line">util = <span class="built_in">require</span>(<span class="string">&quot;xlua.util&quot;</span>)</span><br><span class="line"></span><br><span class="line">GameObject = CS.UnityEngine.GameObject</span><br><span class="line">WaitForSeconds = CS.UnityEngine.WaitForSeconds</span><br><span class="line"><span class="comment">--在场景中新建一个空物体 然后挂载一个脚本上去 脚本继承mono使用它来开启协程</span></span><br><span class="line"><span class="keyword">local</span> obj = GameObject(<span class="string">&quot;Coroutine&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> mono = obj:AddComponent(typeof(CS.LuaCallCSharp))</span><br><span class="line"></span><br><span class="line"><span class="comment">--用来被开启的协程函数</span></span><br><span class="line">fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">--lua中 不能直接使用C#中的 yield return</span></span><br><span class="line"><span class="comment">--但是可以使用lua中的协程返回</span></span><br><span class="line"><span class="built_in">coroutine</span> <span class="built_in">yield</span>(WaitForSeconds(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = a+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> a&gt;<span class="number">10</span> <span class="keyword">then</span></span><br><span class="line"><span class="comment">--停止协程 和C#一样</span></span><br><span class="line">mono:StopCoroutine(b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--不能直接将lua函数传入到开启协程中！</span></span><br><span class="line"><span class="comment">--mono:StartCoroutine()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--真正的写法： 必须先调用xlua中的cs_generator(lua函数)</span></span><br><span class="line">mono:StartCoroutine(util.cs_generator(fun))</span><br></pre></td></tr></table></figure><p>最重要的一个点就是：<strong>开启协程必须先调用xlua提供的一个工具表util</strong></p><p>另外一个就是协程函数定义的时候，不可以直接使用C#中的yield return，但是可以使用lua自带的<code>coroutine.yield</code>！</p><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>Lua调用C#的泛型函数，默认情况下只支持调用有约束有参数的泛型函数</p><p>C#上定义不同的泛型函数：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITest</span> &#123; &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestFather</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestChild</span>:<span class="title">TestFather</span>,<span class="title">ITest</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun1</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a,T b</span>) <span class="keyword">where</span> T:TestFather</span></span><br><span class="line">   &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;有参数有约束的泛型方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun2</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;有参数 没有约束的泛型方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun3</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T:TestFather</span></span><br><span class="line">   &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;有约束，但是没有参数的泛型方法&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestFun4</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a</span>) <span class="keyword">where</span> T:ITest</span></span><br><span class="line">   &#123;</span><br><span class="line">       Debug.Log(<span class="string">&quot;有约束有参数，但是约束条件是接口&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在Lua中调用泛型函数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> obj = CS.Test11()</span><br><span class="line"><span class="keyword">local</span> child = CS.Test11.TestChild()</span><br><span class="line"><span class="keyword">local</span> father = CS.Test11.TestFather()</span><br><span class="line"></span><br><span class="line"><span class="comment">--Lua支持有约束有参数的泛型函数</span></span><br><span class="line">obj:TestFun1(child,father)</span><br><span class="line"></span><br><span class="line"><span class="comment">--lua中不支持 没有约束的泛型函数</span></span><br><span class="line"><span class="comment">--obj:TestFun2(child)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lua中不支持 有约束但是没有参数的泛型函数</span></span><br><span class="line"><span class="comment">--obj:TestFun3()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--lua中不支持 非class的约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--有一定的使用限制</span></span><br><span class="line"><span class="comment">--Mono打包 这种方式就支持使用</span></span><br><span class="line"><span class="comment">--il2cpp打包 如果泛型参数是引用类型才能使用</span></span><br><span class="line">obj:TestFun4(child)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（二）</title>
      <link href="/2024/06/20/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/06/20/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua语言"><a href="#Lua语言" class="headerlink" title="Lua语言"></a>Lua语言</h1><p><img src="/./../images/%E8%A7%92%E8%89%B23C/image-20240828235521778.png" alt="image-20240828235521778"></p><p>初尝试：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">第二种</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p><code>Ctrl + B运行</code></p><p><strong>变量类型主要有：</strong></p><p>简单变量类型</p><ul><li><strong>nil</strong></li><li><strong>number</strong></li><li><strong>bool</strong></li><li><strong>string</strong></li></ul><p>复杂变量类型</p><ul><li><strong>function 函数</strong></li><li><strong>table 表</strong></li><li><strong>userdata 数据结果</strong></li><li><strong>thread 协同程序</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua中的简单变量</span></span><br><span class="line"><span class="comment">-- nil number string boolean</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua中的变量不需要声明        相当于c#的var</span></span><br><span class="line"><span class="comment">lua中的一个变量 可以被随意赋值  lua会自动识别类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">type函数可以返回当前数值的类型，type返回的内容本质上是string类型</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">a = <span class="number">1.5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment">-- 这意味着number类型就包含了跟数值有关的其他类型，包括float，double，int等</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==================================&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment">-- 这意味着lua里边没有char类型</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua中使用一个未被声明的变量，不会报错，初始是nil</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>需要注意的一个点是：Lua中可以直接使用没有初始化的变量，默认为nil</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Lua字符串基础的操作包括：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--字符串长度 通过#符号来表示</span></span><br><span class="line">s = <span class="string">&quot;abcDEF&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;abc你好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s)</span><br><span class="line"><span class="comment">-- 中文一个字占3个长度，英文占1个长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串多行打印</span></span><br><span class="line"><span class="comment">-- 第一种方式：常规转义字符换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\nabc&quot;</span>)</span><br><span class="line"><span class="comment">-- 第二种方式：中括号打印</span></span><br><span class="line">s = <span class="string">[[</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">~~~</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串的拼接：</strong></p><p>字符串的拼接主要通过<code>..</code>符号来进行的，这也意味着如果用了这个符号，表示的就是进行字符串类型的拼接</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串的拼接</span></span><br><span class="line"><span class="comment">-- 第一种方式  通过 .. </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>..<span class="string">&quot;123&quot;</span>)</span><br><span class="line">s1 = <span class="number">123</span></span><br><span class="line">s2 = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(s1..s2)</span><br><span class="line"><span class="comment">-- 第二种方式 string.format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;我是大学生，今年大%d&quot;</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;大学生%s&quot;</span>,<span class="string">&quot;是我&quot;</span>))</span><br><span class="line"><span class="comment">-- %d：与数字拼接</span></span><br><span class="line"><span class="comment">-- %a：与任何字符拼接</span></span><br><span class="line"><span class="comment">-- %s：与字符配对</span></span><br><span class="line"><span class="comment">-- ......</span></span><br></pre></td></tr></table></figure><p>要注意如果通过<code>string.format</code>进行拼接的话，采用的转义字符不同，拼接的类型也不同</p><p><strong>字符串的公共方法：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串提供的公共方法</span></span><br><span class="line">str = <span class="string">&quot;abcDefG&quot;</span></span><br><span class="line"><span class="comment">-- 小写转大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 翻转字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">reverse</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 字符串索引查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;Def&quot;</span>)) <span class="comment">-- 4 6</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;D&quot;</span>)) <span class="comment">-- 4 4</span></span><br><span class="line"><span class="comment">-- find函数查找会返回两个数值，对应起始位置和最终位置，同时要注意Lua的下标都是从1开始，而不是从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串截取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str,<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">rep</span>(str,<span class="number">2</span>))</span><br><span class="line"><span class="comment">-- 字符串修改</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(str,<span class="string">&quot;bcD&quot;</span>,<span class="string">&quot;**&quot;</span>))</span><br><span class="line"><span class="comment">-- 字符转 ASCII码</span></span><br><span class="line">t = <span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="comment">-- ASCII码 转字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(t))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中有几个点要注意到：</p><ol><li>字符串的方法，如upper，lower，reverse等都<strong>不会对原先的字符串造成改变</strong></li><li>字符串索引查找返回的会是两个数值，分别是初始和最终位置</li><li><strong>Lua语言的下标都是默认从1开始的，而不是从0开始的！</strong></li><li>字符串的截取方法也有重载方式，如果单纯输入一个数字，那就会截取数字之后到末尾这一段的内容</li><li>字符串修改，如果打印输出结果的话会有一个数值，该数值表示的是其中修改了几次</li></ol><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>Lua语言中，不支持自增与自减，同时也不支持复合运算符</p><p>但是Lua语言中自带可以在运算过程中把字符串自动转成运算需要的数值number</p><p>同时Lua语言还支持<strong>幂运算</strong>，通过<code>^</code>符号来实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********算数运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中没有自增自减 ++ --</span></span><br><span class="line"><span class="comment">-- Lua中没有复合运算符 += -= *= /= %=</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加法运算：&quot;</span>.<span class="number">.1</span>+<span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="comment">-- Lua语言中，字符串如果与数值进行运算的话，会自动转成number类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;减法运算：&quot;</span>.<span class="number">.1</span><span class="number">-2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span><span class="number">-1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span><span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;乘法运算：&quot;</span>.<span class="number">.1</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;除法运算：&quot;</span>.<span class="number">.1</span>/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取余运算：&quot;</span>.<span class="number">.1</span>%<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>%<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;幂运算：&quot;</span>.<span class="number">.2</span>^<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>^<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>条件运算符、逻辑运算符在Lua的使用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********条件运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- &gt; &lt; &gt;= &lt;= == ~=</span></span><br><span class="line"><span class="comment">-- 在Lua语言中, != 是用 ~= 来实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********逻辑运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- &amp;&amp;   ||   !   </span></span><br><span class="line"><span class="comment">-- and  or   not</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 短路</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>) <span class="keyword">and</span> <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>Lua中不支持位运算符和三目运算符</p><p><strong>条件分支语句：</strong></p><p>注意的是，Lua语言中没有 switch 语句</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********条件分支语句************&quot;</span>)</span><br><span class="line">a = <span class="number">9</span></span><br><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 双分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">6</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">7</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">8</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;8&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>循环语句：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 循环语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================while=====================&quot;</span>)</span><br><span class="line"><span class="comment">-- while ....... do .......end</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num&lt;<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================do while=====================&quot;</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="comment">-- repeat ....... until .......    PS：条件是结束条件，而不是进入条件</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> num &gt; <span class="number">5</span>  <span class="comment">-- 结束条件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================for=====================&quot;</span>)</span><br><span class="line"><span class="comment">-- for ....... do ...... end</span></span><br><span class="line"><span class="comment">-- Lua语言中，for里边是默认递增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span> <span class="comment">-- 默认递增+1</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span> <span class="keyword">do</span> <span class="comment">-- 自定义每次增加是2</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span> <span class="comment">-- 自定义递减</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Lua语言中的循环语句与其他语法都不太一样，尤其是do while以及for循环</p><p>其中 do while 变为了 repeat until，并且最本质的区别在于：</p><p>前者在其他语言，条件都是相当于<strong>输入条件</strong>，而后者变成了条件是<strong>结束条件</strong></p><p>最后是Lua语言的for循环，其中对应的定义，条件，递增&#x2F;递减直接通过三个数值两个逗号即可表示完整</p><p>Lua repeat util</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240714113030778.png" alt="image-20240714113030778"></p><p>C# do while</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240714113043506.png" alt="image-20240714113043506"></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Lua语言中函数的使用更加简便，其中函数的传参</p><p><strong>函数的定义：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================函数==============================&quot;</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">两种写法：</span></span><br><span class="line"><span class="comment">第一种 </span></span><br><span class="line"><span class="comment">function function_name()</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二种</span></span><br><span class="line"><span class="comment">a = function()</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用了函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F1() <span class="comment">-- 使用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种方式有点类似于 C#中的 委托和事件</span></span><br><span class="line">a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二种调用&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中函数的有参、有返回区别很大，要注意其在Lua的使用：</p><ul><li><strong>函数传参时</strong><ul><li>个数多了或少了，不会报错</li><li>多了会丢弃</li><li>少了会补空</li></ul></li><li><strong>函数返回时</strong><ul><li>允许有多个返回值，外部用多个变量来接取，接多接少不影响</li><li>少了会丢弃，多了会自动赋值为nil</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================有参数==================================&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中函数的参数不需要声明类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(a)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line">test(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">test(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">-- 如果传入的参数和函数的参数不匹配，没传入或者超过个数</span></span><br><span class="line"><span class="comment">-- 不会报错，会自动补空nil  或者 丢弃</span></span><br><span class="line">test()</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================有返回值==================================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span><span class="params">(a)</span></span></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp = F3(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line">temp1 = F3(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(temp1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多返回值时，在前面声明多个变量来接取即可</span></span><br><span class="line"><span class="comment">-- 如果变量不够也不会报错，值接取对应位置的返回值</span></span><br><span class="line"><span class="comment">-- 如果变量多了也不会影响，值赋值为nil</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span><span class="params">(a)</span></span></span><br><span class="line"><span class="keyword">return</span> a,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp = F3(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line">temp2,temp3,temp4 = F3(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(temp2)</span><br><span class="line"><span class="built_in">print</span>(temp3)</span><br><span class="line"><span class="built_in">print</span>(temp4)</span><br><span class="line"><span class="built_in">print</span>(temp5)</span><br></pre></td></tr></table></figure><p>函数的类型就是function，和其他语法不一样，Lua中函数只有function一种</p><p>Lua中函数也不支持重载：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua中 函数不支持重载</span></span><br><span class="line"><span class="comment">-- 默认调用最后一个声明的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无参函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">(str)</span></span></span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F6()</span><br></pre></td></tr></table></figure><p>Lua中函数也可以定义变长参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================变长参数==============================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F7</span><span class="params">(...)</span></span></span><br><span class="line"><span class="comment">-- 变长参数使用 一个表 来存起来</span></span><br><span class="line"><span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#<span class="built_in">arg</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">arg</span>[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F7(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>可以发现其变长参数，如果传入的参数类型都不相同，依旧不影响其正常使用，同时表格存储的数据也会跟着对应的类型</p><p>Lua语言的函数嵌套：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F8</span><span class="params">(x)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f8 = F8(<span class="number">10</span>)</span><br><span class="line">f8()</span><br></pre></td></tr></table></figure><p>同时这块还有一个面试知识点：<strong>闭包</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F9</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">--改变传入参数的生命周期</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(y)</span></span></span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f9 = F9(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(f9(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>其本质就是让传入的参数的生命周期发生了变化，从而就实现了闭包</p><h3 id="★表-Table"><a href="#★表-Table" class="headerlink" title="★表(Table)"></a>★表(Table)</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--所有复杂类型都是table（表）</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">--lua中索引从 1开始</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>])</span><br><span class="line"><span class="comment">--打印长度会忽略空</span></span><br><span class="line"><span class="built_in">print</span>(#a)</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="literal">nil</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">--如果表中(数组中)某一位变成nil 会影响#获取的长度</span></span><br><span class="line"><span class="built_in">print</span>(#b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 数组的遍历</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 二维数组</span></span><br><span class="line">a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line">b = a[i]</span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span>,#b <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(b[j])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 自定义索引</span></span><br><span class="line">c = &#123;[<span class="number">0</span>]=<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">-1</span>]=<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>])</span><br><span class="line"><span class="comment">-- 自定义索引不会影响原来数组的顺序，如c数组塞了两个，实际上 1 2 3 5 7仍然是按顺序排列的</span></span><br></pre></td></tr></table></figure><p>PS： 表中某个元素如果为nil且后续还有其他元素取长度时nil以及之后都不会被计算在内</p><p>通过测试就会发现：</p><p>Lua中通过<code>#</code>直接获取长度并进行遍历会出现&lt;&#x3D;0索引的情况下无法完全遍历整体的数组，还会出现数组中断的后果，所以Lua语言还提供了迭代器遍历的方式</p><ul><li><strong>ipairs</strong></li><li><strong>pairs</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 迭代器遍历</span></span><br><span class="line"><span class="comment">-- ipairs</span></span><br><span class="line"><span class="comment">-- ipairs遍历仍然是从 1开始往后遍历的 &lt;=0的索引的值都得不到</span></span><br><span class="line"><span class="comment">-- 只能找到连续索引的键 如果中间断续了 也无法得到后续的内容</span></span><br><span class="line">   <span class="comment">-- 这里连续索引被中断的意思，指的相当于 1 2 3 [5]=-1   这时候索引4直接被跳过了，就相当于中断了</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">ipairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键值：&quot;</span>..i..<span class="string">&quot;-&quot;</span>..k)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- pairs</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键值：&quot;</span>..i..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 遍历键</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">pairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键：&quot;</span>..i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过比较可以发现两者的区别，这也是面试的一个知识点：</p><p><strong>ipairs</strong>跟原始的用#进行遍历的方式一样，都会遇到相同的问题，存在丢失后续数组内容，在里边插入了自定义索引的情况下</p><p>而<strong>pairs</strong>最全面，其可以找到所有的数组元素</p><p>通过表可以定义复杂数据类型：</p><ul><li><strong>字典</strong></li><li><strong>类</strong></li></ul><p>字典的定义与操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;====================字典============================&quot;</span>)</span><br><span class="line"><span class="comment">-- 字典是由键值对构成</span></span><br><span class="line">a = &#123;[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;测试字典&quot;</span>,[<span class="string">&quot;age&quot;</span>]=<span class="number">1145</span>,[<span class="string">&quot;233&quot;</span>]=<span class="literal">true</span>&#125;</span><br><span class="line"><span class="comment">-- 第一种字典访问方式</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;233&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种字典访问方式 通过.成员变量方式获取值</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"><span class="built_in">print</span>(a.age)</span><br><span class="line"><span class="comment">-- 这种方式有一个缺陷，不能使用.数字来获取</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;233&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;waou&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line">a.name = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增添</span></span><br><span class="line">a.sex = <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(a.sex)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="comment">-- 直接赋值为nil即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========字典遍历==============&quot;</span>)</span><br><span class="line"><span class="comment">-- 一定要用pairs</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获得键</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>类的定义与操作：</strong></p><p>类成员变量的声明</p><ul><li>表内部声明</li><li>表外部声明</li></ul><p>类成员函数的声明</p><ul><li><p>表内部声明</p></li><li><p>表外部声明</p><ul><li>变量的形式</li><li>function + 名字的形式</li></ul><p>在表内部函数要访问表内部的变量或方法时，要先知道他们来自于哪里</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;====================类和结构体============================&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中默认没有面向对象，需要自己实现</span></span><br><span class="line">Student = &#123;</span><br><span class="line">age = <span class="number">10</span>,</span><br><span class="line">sex = <span class="string">&quot;male&quot;</span>,</span><br><span class="line"><span class="comment">--函数</span></span><br><span class="line">Up = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">-- 如果要在方法里边调用类里边的属性的话，要通过表名.成员变量/函数来声明</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成长&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">Learn = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="comment">-- 第二种方式就是</span></span><br><span class="line"><span class="comment">-- 把自己作为一个参数传进来，让其在内部能被访问</span></span><br><span class="line"><span class="built_in">print</span>(t.sex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经验&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line">Student.Up()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明表后，可以在表外去声明变量和方法</span></span><br><span class="line">Student.name = <span class="string">&quot;test&quot;</span></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数的第三种声明方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Talk</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;聊天&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Student.Speak()</span><br><span class="line">Student.Talk()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 面试考点之一： .和:的区别！</span></span><br><span class="line">Student.Learn(Student)</span><br><span class="line"><span class="comment">-- Lua中，冒号调用方法，会默认把调用者作为第一个参数传入方法中</span></span><br><span class="line">Student:Learn()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同样的在外部声明的时候也可以直接使用冒号，这样就默认外部声明的函数有一个默认传入值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:Talk2</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">-- 这里另外一个新的内容：</span></span><br><span class="line"><span class="comment">-- 通过 self 关键字来获取默认第一个传入的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;聊天&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Student:Talk2()</span><br></pre></td></tr></table></figure><p>其中类函数定义这块有两个面试注意点：</p><ol><li><p><code>.</code>和<code>:</code>的区别</p><p><strong>冒号会把调用者作为第一个参数传入</strong></p><p>冒号也可以用来声明函数，同时这种方式声明<strong>只能是function +  名字的形式</strong></p><p><strong>冒号声明函数只能在外部进行声明</strong></p></li><li><p>self关键字</p></li></ol><p>这两个知识点都是应用在类声明的有参传入函数的使用上</p><p>表提供的一些公共方法：</p><p>主要也是增删改查，同时也提供了排序与拼接的相关操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#123;name = <span class="string">&quot;lili&quot;</span>,sex = <span class="string">&quot;male&quot;</span>&#125;,&#123;name = <span class="string">&quot;wuh&quot;</span>,age = <span class="number">14</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">t2 = &#123;name=<span class="string">&quot;lucy&quot;</span>,id=<span class="string">&quot;233&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="comment">-- 插入语句</span></span><br><span class="line"><span class="comment">-- 把t2插入给t1</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(t1,t2)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>].name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除语句</span></span><br><span class="line"><span class="comment">-- remove方法 会移除最后一个索引的元素</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- remove方法传入两个参数 根据第二个参数，移除第二个参数代表的索引位置所在的内容</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>].name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line"><span class="comment">-- 排序</span></span><br><span class="line">test = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(test)</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(test) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(test,<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="keyword">if</span> a &gt; b <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(test) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接</span></span><br><span class="line">tb = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>,<span class="string">&quot;10101&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#tb)</span><br><span class="line">str = <span class="built_in">table</span>.<span class="built_in">concat</span>( tb, <span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br></pre></td></tr></table></figure><h2 id="多脚本执行"><a href="#多脚本执行" class="headerlink" title="多脚本执行"></a>多脚本执行</h2><p>Lua语言中也分有 <strong>全局变量</strong>和<strong>本地变量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================全局变量和本地变量======================&quot;</span>)</span><br><span class="line"><span class="comment">--全局变量</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">c = <span class="string">&quot;测试全局&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">--本地(局部)变量关键字 local</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> d = <span class="string">&quot;测试本地&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>通过local来定义本地变量，这两种变量与其他语言差不多，都是代表外部和内部</p><p>lua语言中有多脚本执行的功能，这里就可以体会到全局与本地的区别：</p><p>Require.Lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多脚本执行======================&quot;</span>)</span><br><span class="line"><span class="comment">-- 关键字  require(&quot;脚本名&quot;)</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(testA)</span><br><span class="line"><span class="built_in">print</span>(localTestA)</span><br><span class="line"><span class="comment">-- 此时就可以体现出来 全局与本地的区别了，新加载的脚本的本地变量无法被获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新内容：require 执行一个脚本时，如果希望获取到需要的内容，比如新脚本的一个本地变量</span></span><br><span class="line"><span class="comment">-- 这时候就可以在新脚本的最后添加一个return 来返回需要的类型，然后这边定义一个变量来获取</span></span><br><span class="line"><span class="keyword">local</span> testLa = <span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(testLa)</span><br></pre></td></tr></table></figure><p>test.Lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试脚本&quot;</span>)</span><br><span class="line">testA = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">local</span> localTestA = <span class="string">&quot;259&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> localTestA</span><br></pre></td></tr></table></figure><p>可以看到test的本地变量无法被获取，不过这里也可以衍生出另外一个内容，那就是可以通过return的方式，然后在另外一边设置一个新的变量来接收，这样就能够获取得到</p><p>脚本卸载：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================脚本卸载======================&quot;</span>)</span><br><span class="line"><span class="comment">-- require加载完的脚本不会再加载第二次</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment">-- package.loaded[&quot;脚本名&quot;]</span></span><br><span class="line"><span class="comment">-- 返回值是boolean 表示脚本是否被执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="comment">-- 卸载已经执行过的脚本 只要让其为nil即可</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>大G表：_G表是一个总表(table) 它将我们声明的所有全局的变量都存储在内；本地变量(local) 不会存放到大G表中</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================大G表======================&quot;</span>)</span><br><span class="line"><span class="comment">-- _G表是一个总表(table) 它将我们声明的所有全局的变量都存储在内</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- PS： 本地变量(local) 不会存放到大G表中</span></span><br></pre></td></tr></table></figure><h2 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================特殊用法====================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多变量赋值====================&quot;</span>)</span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="string">&quot;133&quot;</span>,<span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">-- 多变量赋值 如果后面的值不够会自动补空</span></span><br><span class="line">a,b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多变量赋值 如果后面的值多了，会自动省略</span></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多返回值====================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 多返回值也同上边多变量赋值一样，多了会省略，少了不会报错</span></span><br><span class="line">a,b,c,d,e = Test()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================and or====================&quot;</span>)</span><br><span class="line"><span class="comment">-- AND OR 可以连接任何东西</span></span><br><span class="line"><span class="comment">-- 在lua中 只有nil 和 false才认为是假</span></span><br><span class="line"><span class="comment">-- &quot;短路&quot;   →  对于and 来说 有假则假 对于or来说 有真则真</span></span><br><span class="line"><span class="comment">-- 所以只需要判断第一个是否满足就会停止计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">and</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">or</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于以上该特性，可以自定义 三目运算符</span></span><br><span class="line"><span class="comment">-- 由于Lua语言本身没有三目运算符，所以只能自定义</span></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> res = (x&gt;y) <span class="keyword">and</span> x <span class="keyword">or</span> y</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> res = (x&gt;y) <span class="keyword">and</span> x <span class="keyword">or</span> y</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (x&gt;y) and x ——&gt; x</span></span><br><span class="line"><span class="comment">-- x or y ——&gt; x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (x&gt;y) and x ——&gt; (x&gt;y)</span></span><br><span class="line"><span class="comment">-- (x&gt;y) or y ——&gt; y</span></span><br></pre></td></tr></table></figure><p>这部分主要要注意的一个点就是<strong>人为构建三目运算符</strong></p><h2 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h2><p>也就是协程，但是与C#的携程不一样</p><p><strong>协程的本质是一个线程</strong>！</p><p>协程的创建有两种方式：</p><ul><li>create(函数)</li><li>wrap(函数)</li></ul><p>根据创建的方式不同，后续的启动方式也不同</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协同函数==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程创建==============================&quot;</span>)</span><br><span class="line"><span class="comment">--常用方式</span></span><br><span class="line"><span class="comment">--coroutine.create()</span></span><br><span class="line">fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun)</span><br><span class="line"><span class="comment">--协程的本质是一个线程对象！</span></span><br><span class="line"><span class="built_in">print</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co))</span><br><span class="line"></span><br><span class="line"><span class="comment">--coroutine.wrap()</span></span><br><span class="line">co2 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun)</span><br><span class="line"><span class="built_in">print</span>(co2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的运作==============================&quot;</span>)</span><br><span class="line"><span class="comment">-- 第一种方式 对应的是通过 create创建的协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="comment">-- 第二种方式</span></span><br><span class="line">co2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的挂起==============================&quot;</span>)</span><br><span class="line">fun2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">--协程的挂起函数</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">co3 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun2)</span><br><span class="line"><span class="comment">-- 这里就可以看出与C#的携程有所不同</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">co4 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun2)</span><br><span class="line">co4()</span><br><span class="line">co4()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协程的yield也可以有返回值，同时也能够被获取得到</span></span><br><span class="line">fun3 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">--协程的挂起函数</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test1 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun3)</span><br><span class="line"><span class="comment">-- 这样就能直接获取到协程返回的内容了</span></span><br><span class="line"><span class="comment">-- 该方式默认第一个返回值一定是bool类型的值，表示启动成功或者失败</span></span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun3)</span><br><span class="line"><span class="comment">-- 这种方式也有返回值，且没有默认第一个是bool类型返回值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的状态==============================&quot;</span>)</span><br><span class="line"><span class="comment">-- coroutine.status(协程对象)</span></span><br><span class="line"> <span class="comment">-- dead 结束</span></span><br><span class="line"> <span class="comment">-- suspended 暂停</span></span><br><span class="line"> <span class="comment">-- running 进行中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co3))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- coroutine.running()</span></span><br><span class="line"><span class="comment">-- 该函数可以得到当前正在运行的协程的线程号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><p>概述：</p><p>任何<strong>表变量</strong>都可以作为另一个表变量的元表<br>任何表变量都可以有自己的元表（父亲），当子表中进行一些特定操作时，会执行元表中的内容</p><p>首先是元表的创建(定义：)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================元表======================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================元表概念======================&quot;</span>)</span><br><span class="line"><span class="comment">--任何表变量都可以作为另一个表变量的元表</span></span><br><span class="line"><span class="comment">--任何表变量都可以有自己的元表（父亲）</span></span><br><span class="line"><span class="comment">--当子表中进行一些特定操作时</span></span><br><span class="line"><span class="comment">--会执行元表中的内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================设置元表======================&quot;</span>)</span><br><span class="line">meta = &#123;&#125;</span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="comment">--设置元表函数</span></span><br><span class="line"><span class="comment">--第一个参数 子表</span></span><br><span class="line"><span class="comment">--第二个参数 元表(父亲)</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)</span><br></pre></td></tr></table></figure><p>元表的特定操作：</p><p>这块主要要了解的是</p><ul><li><strong>__toString</strong></li><li><strong>__call</strong></li></ul><p>分别对应了子表被当做字符串以及函数来使用，使用会比较多一些</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作======================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================__toString======================&quot;</span>)</span><br><span class="line">meta2 = &#123;</span><br><span class="line"><span class="comment">-- 当子表要被当做字符串使用时 会默认调用这个元表中的tostring方法</span></span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myTable2 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2,meta2)</span><br><span class="line"><span class="comment">--当字符串</span></span><br><span class="line"><span class="built_in">print</span>(myTable2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================__call======================&quot;</span>)</span><br><span class="line">meta3 = &#123;</span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当子表被当做一个函数来使用时，会默认调用这个__call中的内容</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable3 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable3,meta3)</span><br><span class="line"><span class="comment">--当函数</span></span><br><span class="line">myTable3()</span><br><span class="line"></span><br><span class="line">meta4 = &#123;</span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当子表被当做一个函数来使用,同时还有参数传入的话，需要注意：</span></span><br><span class="line"><span class="comment">--此时第一个参数会默认是该子表本身！</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable4 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable4,meta4)</span><br><span class="line">myTable4(<span class="number">233</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作-运算符重载======================&quot;</span>)</span><br><span class="line">meta5 = &#123;</span><br><span class="line"><span class="comment">--相当于运算符重载 当子表使用&quot;+&quot;运算符时 会调用该方法</span></span><br><span class="line"><span class="comment">-- +</span></span><br><span class="line"><span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age + t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当使用&quot;-&quot;运算符时 会调用该方法</span></span><br><span class="line"><span class="comment">-- -</span></span><br><span class="line"><span class="built_in">__sub</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age - t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- *</span></span><br><span class="line"><span class="built_in">__mul</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age * t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- /</span></span><br><span class="line"><span class="built_in">__div</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age / t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- %</span></span><br><span class="line"><span class="built_in">__mod</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age % t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- ^</span></span><br><span class="line"><span class="built_in">__pow</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age ^ t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- ==</span></span><br><span class="line"><span class="built_in">__eq</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- &lt;</span></span><br><span class="line"><span class="built_in">__lt</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age &lt; t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- &lt;=</span></span><br><span class="line"><span class="built_in">__le</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age &lt;= t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--这里要注意：lua语言这个模块下，只有&lt;和&lt;=相关的，但是没有&gt;和&gt;=</span></span><br><span class="line"><span class="comment">-- ..</span></span><br><span class="line"><span class="built_in">__concat</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myTable5 = &#123;age=<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable5,meta5)</span><br><span class="line">myTable6 = &#123;age=<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myTable5 + myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 - myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 * myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 / myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 % myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 ^ myTable6)</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果要用条件运算符来比较两个对象</span></span><br><span class="line"><span class="comment">--这两个对象的元表一定要一致才能调用！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--不一致情况下：</span></span><br><span class="line"><span class="built_in">print</span>(myTable5 == myTable6)</span><br><span class="line"><span class="comment">--一致情况下：</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable6,meta5)</span><br><span class="line"><span class="built_in">print</span>(myTable5 == myTable6)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>元表另外两个比较重要的特定操作：</strong></p><ul><li><strong>__index</strong></li><li><strong>newindex</strong></li></ul><p>这两个操作可以实现类似于继承的操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作-__index和__newindex======================&quot;</span>)</span><br><span class="line">meta6Father = &#123;</span><br><span class="line">age = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">meta6Father.<span class="built_in">__index</span> = meta6Father</span><br><span class="line">meta6 = &#123;</span><br><span class="line"><span class="comment">--age = 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--__index的赋值最好写在表外边来初始化</span></span><br><span class="line">meta6.<span class="built_in">__index</span> = meta6</span><br><span class="line"></span><br><span class="line">myTable7 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(meta6,meta6Father)</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable7,meta6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--__index 当子表中找不到一个属性时 会到元表中的__index指定的表去找</span></span><br><span class="line"><span class="built_in">print</span>(myTable7.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--newindex 当赋值时，如果赋值一个不存在的索引，那会把这个值赋值到newindex所指向的表中，而不会修改自己</span></span><br><span class="line">meta7 = &#123;&#125;</span><br><span class="line">meta7.<span class="built_in">__newindex</span> = &#123;&#125;</span><br><span class="line">myTable8 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable8,meta7)</span><br><span class="line">myTable8.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable8.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">--元表的其他方法</span></span><br><span class="line"><span class="comment">--rawget 使用时会去找当前表自己的身上有没有这个变量    可以绕开__index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable8,<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--rawset 可以绕开newindex</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="★面向对象"><a href="#★面向对象" class="headerlink" title="★面向对象"></a>★面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>表就是实现类的一种形式</p><p>封装主要是实现了new方法</p><ul><li>本质上是创建了一个空表</li><li>元表</li><li>__index</li></ul><p>实现面向对象：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一个类（表）</span></span><br><span class="line"><span class="keyword">local</span> Animal = &#123;&#125;</span><br><span class="line">Animal.<span class="built_in">__index</span> = Animal  <span class="comment">-- 设置元表的 __index 元方法指向类自身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal:new</span><span class="params">(name, sound)</span></span></span><br><span class="line">    <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, Animal)  <span class="comment">-- 创建新对象，并将其元表设置为 Animal</span></span><br><span class="line">    instance.name = name <span class="keyword">or</span> <span class="string">&quot;Unnamed&quot;</span></span><br><span class="line">    instance.sound = sound <span class="keyword">or</span> <span class="string">&quot;Unknown sound&quot;</span></span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal:makeSound</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">self</span>.name .. <span class="string">&quot; makes a sound: &quot;</span> .. <span class="built_in">self</span>.sound)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象</span></span><br><span class="line"><span class="keyword">local</span> cat = Animal:new(<span class="string">&quot;Cat&quot;</span>, <span class="string">&quot;Meow&quot;</span>)</span><br><span class="line"><span class="keyword">local</span> dog = Animal:new(<span class="string">&quot;Dog&quot;</span>, <span class="string">&quot;Woof&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用对象的方法</span></span><br><span class="line">cat:makeSound()  <span class="comment">-- 输出 &quot;Cat makes a sound: Meow&quot;</span></span><br><span class="line">dog:makeSound()  <span class="comment">-- 输出 &quot;Dog makes a sound: Woof&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更完整的面向对象方式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">class</span><span class="params">(className,super)</span></span></span><br><span class="line"><span class="comment">--构造类</span></span><br><span class="line"><span class="comment">--定义类名，super为父类   需要继承时可以通过构造类的同时实现继承</span></span><br><span class="line"><span class="keyword">local</span> clazz = &#123;__cname = className,super = super&#125;</span><br><span class="line"><span class="comment">--当有继承时：</span></span><br><span class="line"><span class="keyword">if</span> super <span class="keyword">then</span></span><br><span class="line"><span class="comment">--设置类的元表，此类没有的话，可以到父类查找是否含有</span></span><br><span class="line"><span class="built_in">setmetatable</span>(clazz,&#123;<span class="built_in">__index</span> = super&#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--new方法</span></span><br><span class="line">clazz.new = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line"><span class="comment">--构建对象</span></span><br><span class="line"><span class="keyword">local</span> instance = &#123;&#125;</span><br><span class="line"><span class="comment">--设置对象的元表</span></span><br><span class="line"><span class="built_in">setmetatable</span>(instance,&#123;<span class="built_in">__index</span> = clazz&#125;)</span><br><span class="line"><span class="comment">--定义构造函数</span></span><br><span class="line"><span class="keyword">if</span> clazz.ctor <span class="keyword">then</span></span><br><span class="line">clazz.ctor(instance,...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> clazz</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================面向对象==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================封装==============================&quot;</span>)</span><br><span class="line"><span class="comment">--面向对象，类，都是基于 table来实现</span></span><br><span class="line">Object = &#123;&#125;</span><br><span class="line">Object.id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--冒号 会自动将调用这个函数的对象作为第一个参数传入</span></span><br><span class="line"><span class="comment">--定义new方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">--self 代表默认传入的第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--对象就是变量，相当于要返回一个新的变量</span></span><br><span class="line"><span class="comment">--返回出去的内容其实就是该表的对象</span></span><br><span class="line"><span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line"><span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> newObj = Object:new()</span><br><span class="line"><span class="built_in">print</span>(newObj.id)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================继承==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================多态==============================&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承与封装不同的是需要调用_G表来创建一个新表&#x2F;类</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================继承==============================&quot;</span>)</span><br><span class="line"><span class="comment">--写一个用于继承的方法</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line"> <span class="comment">--_G 是总表，所有声明的全局变量都以键值对的形式存在其中</span></span><br><span class="line"> <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line"> <span class="comment">--写相关继承的规则</span></span><br><span class="line"> <span class="comment">--用到元表</span></span><br><span class="line"> <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line"> <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line"> <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于Person表继承了Object表</span></span><br><span class="line">Object:subClass(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Person)</span><br><span class="line"><span class="built_in">print</span>(Person.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p1 = Person:new()</span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>相同方法名，不同处理逻辑</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================多态==============================&quot;</span>)</span><br><span class="line"><span class="comment">--相同方法 不同执行逻辑</span></span><br><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line">GameObject.posX = <span class="number">0</span>;</span><br><span class="line">GameObject.posY = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.posX)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.posY)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span></span><br><span class="line"> <span class="comment">--base指的是GameObject表</span></span><br><span class="line"> <span class="comment">--如果要执行父类逻辑，不要使用冒号，而是使用逗号，将自己作为第一个参数</span></span><br><span class="line"><span class="built_in">self</span>.base.Move(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p1 = Player:new()</span><br><span class="line">p1:Move()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p2 = Player:new()</span><br><span class="line">p2:Move()</span><br></pre></td></tr></table></figure><p>复习视频：<a href="https://www.bilibili.com/video/BV1iA411n7oQ?p=21&amp;vd_source=2120a503db4ff85e38e1bba833eae2e6">https://www.bilibili.com/video/BV1iA411n7oQ?p=21&amp;vd_source=2120a503db4ff85e38e1bba833eae2e6</a></p><h2 id="自带库"><a href="#自带库" class="headerlink" title="自带库"></a>自带库</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================自带库======================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================时间======================&quot;</span>)</span><br><span class="line"><span class="comment">--系统时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"><span class="comment">--自己传入参数 得到时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2024</span>,month=<span class="number">8</span>,day=<span class="number">11</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> nowTime = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(nowTime) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(nowTime.hour)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================数学运算======================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--绝对值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">abs</span>(<span class="number">-11</span>))</span><br><span class="line"><span class="comment">--弧度转角度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">deg</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>))</span><br><span class="line"><span class="comment">--三角函数 math.cos(math.pi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--向上取整 math.floor</span></span><br><span class="line"><span class="comment">--向下取整 math.ceil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--最大值 math.max</span></span><br><span class="line"><span class="comment">--最小值 math.min</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--小数分离 分成整数和小数部分 math.modf</span></span><br><span class="line"><span class="comment">--幂运算 math.pow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--随机数 先设置随机数种子 math.randomseed(os.time()) math.random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--开方 math.sqrt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================路径======================&quot;</span>)</span><br><span class="line"><span class="comment">--lua脚本加载路径</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">path</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/2024/06/11/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/06/11/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>如果C++中使用<code>scanf</code>和<code>printf</code>显示报错的话，可以在iostream源文件前边添加上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><ol><li><strong>先划分分界点</strong></li><li><strong>进行排序，使左边 &lt; 分界点，右边 &gt; 分界点</strong></li><li><strong>递归左右区间</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ol><li><strong>先划分分界点</strong></li><li><strong>递归左右区间</strong></li><li><strong>归并 —— 合二为一 （双指针）</strong></li></ol><p>[L , R] &#x3D;&gt; [L，mid]，[mid+1，R]</p><p>递归排序[L，mid]和[mid+1，R]</p><p>归并，合二为一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt; q[j]) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span> temp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l,j=<span class="number">0</span>; i &lt;= r; i++,j++)</span><br><span class="line">&#123;</span><br><span class="line">q[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序（Quick Sort）</strong>:</p><ul><li><strong>平均时间复杂度</strong>: O(nlog⁡n)</li><li><strong>最坏时间复杂度</strong>: O(n^2)（当输入数据是有序的或者逆序的情况下，最坏情况出现）</li><li><strong>最优时间复杂度</strong>: O(nlog⁡n)（平均情况下的性能）</li></ul><p><strong>归并排序（Merge Sort）</strong>:</p><ul><li><strong>平均时间复杂度</strong>: O(nlog⁡n)</li><li><strong>最坏时间复杂度</strong>: O(nlog⁡n)</li><li><strong>最优时间复杂度</strong>: O(nlog⁡n)（总是分成两半进行递归排序）</li></ul><h2 id="▲求逆序对的数量"><a href="#▲求逆序对的数量" class="headerlink" title="▲求逆序对的数量"></a>▲求逆序对的数量</h2><p>首先要知道一个前提：</p><p>在计算数组的逆序对的过程中，将原数组排序并不会改变原数组的逆序对数量</p><p>视频讲解：<a href="https://www.acwing.com/video/230/">https://www.acwing.com/video/230/</a></p><p>注意其本质上可以通过归并来直接实现，在排序的时候就可以进行计算了，左区间，右区间，左右出现逆序对三种情况下，都可以在递归的时候就完成整体的排序与寻找对应的逆序对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> temp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//归排</span></span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//先分化</span></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j]) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = q[j++];</span><br><span class="line">res += mid - i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后归并，合二为一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">q[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><p>两个模板（对应<strong>整数</strong>）：</p><ul><li>第一个对应的是：求右区间的左边界</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;...&#125; <span class="comment">//检查x是否满足需要的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;  <span class="comment">//判断是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二个对应的是：求左区间的右边界</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;...&#125; <span class="comment">//检查x是否满足需要的性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search_1</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span>&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;  <span class="comment">//判断是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>口诀：对于mid，答案在左边就不加1，答案在右边就要加1</p><p>同时用到这两个模板的练习题有：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>PS：如果是针对浮点数的话，对应的细节都要进行修改，比如边界值不能直接通过<code>+1</code>或者<code>-1</code>来进行，否则出现小数点的情况就会被直接忽略了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">double</span> l = <span class="number">-10000</span>, r = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">//注意，由于要求为保留6位小数，最好的保险方式就是多往后移动两位小数来保证判断的准确性</span></span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid * mid * mid &gt;= n) r = mid;</span><br><span class="line">       <span class="comment">//这里的边界值也可以根据题目保留的小数来移动，同check()判断条件一致</span></span><br><span class="line"><span class="keyword">else</span> l = mid; <span class="comment">//也可以 l = mid + 1e-8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//%lf 用于输出 double 型，有效数位是 15 ~16 位，默认保留6位小数，位数不够则用 ‘0’ 补全。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, l);</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>例子：<a href="https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/reverse-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><p><strong>要知道n的二进制表示其第k位的数字是几</strong></p><ol><li><strong>先吧第k位移动到最后一位，也就是移动到个位数 → n &gt;&gt; k;</strong></li><li><strong>看个位是几 → x &amp; 1</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> t = <span class="number">10</span>;</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">31</span>;k&gt;=<span class="number">0</span>;k--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//cout&lt;&lt;((n&gt;&gt;k)&amp;1);</span></span><br><span class="line">           path.<span class="built_in">push_back</span>((n&gt;&gt;k)&amp;<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">       <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">       &#123;</span><br><span class="line">           res += path[i]&lt;&lt;i;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="单个数二进制中1的个数"><a href="#单个数二进制中1的个数" class="headerlink" title="单个数二进制中1的个数"></a>单个数二进制中1的个数</h2><p>题目：<a href="https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/number-of-1-bits/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><p><strong>给定一个长度为 n 的数列，求出数列中每个数的二进制表示中 1 的个数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过补码的方式来确定</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每次减去x的最后一位</span></span><br><span class="line">        <span class="keyword">while</span>(x) x -= <span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异或运算-求数组-x2F-集合只有一个元素出现了一次"><a href="#异或运算-求数组-x2F-集合只有一个元素出现了一次" class="headerlink" title="异或运算(求数组&#x2F;集合只有一个元素出现了一次)"></a>异或运算(求数组&#x2F;集合只有一个元素出现了一次)</h2><p>异或符号<code>^=</code>，异或运算的特性：</p><ul><li>两个相同数字做异或运算，结果为0。这个结果可以帮我们排除掉成对的数字；</li><li>0和任何数字进行异或运算，都得到这个数字本身。</li></ul><p>题目：<a href="https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">   &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：这种情况下，其他重复元素必须都是出现 偶数 次数！</strong></p><p>所以有变种题，其中重复元素都是出现3次的情况：<a href="https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/single-number-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><p>此时就要切换回最初的位运算，已知每个重复数字的出现次数都一致，那么只要收集齐32位的1的数字，让其%3，此时整个32位记录1的数字进行转换为十进制，就可以得到最终答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">remind</span><span class="params">(<span class="number">32</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> num:nums)</span><br><span class="line">       &#123;</span><br><span class="line">           remind[i] += (num&gt;&gt;i) &amp; <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">   &#123;</span><br><span class="line">       remind[i] %= <span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       res += remind[i]&lt;&lt;i;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">head: 表示头结点的下标</span></span><br><span class="line"><span class="comment">e[i]：表示节点i的值</span></span><br><span class="line"><span class="comment">ne[i]：表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">idx：存储当前已经用到了哪个点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> head, e[n], ne[n], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从第k-1个位置后插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> stack[N];</span><br><span class="line"><span class="type">int</span> hh;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line">stack[++hh] = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//empty</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= <span class="number">0</span>) is empty</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">not</span> is empty</span><br><span class="line">    </span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line">hh--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//query</span></span><br><span class="line"><span class="keyword">return</span> stack[hh];</span><br></pre></td></tr></table></figure><h1 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> queue[N];</span><br><span class="line"><span class="type">int</span> hh,tt = <span class="number">-1</span>;  <span class="comment">//hh表示队头，tt表示队尾PS：队尾初始为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line">queue[++tt] = n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//empty</span></span><br><span class="line"><span class="keyword">if</span>(hh &lt;= tt) <span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span> empty</span><br><span class="line">    </span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//query</span></span><br><span class="line"><span class="keyword">return</span> queue[hh];</span><br></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p><strong>应用场景：</strong></p><p><strong>给定一个序列，求每个数左边离它最近的(比它小&#x2F;比它大的)数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> hh;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(hh &amp;&amp; stk[hh]&gt;=x)hh--;</span><br><span class="line">        <span class="keyword">if</span> (hh) cout &lt;&lt; stack[hh] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">stack[++hh] = x;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>力扣类似题目：<a href="https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p>洛谷类似题目：<a href="https://www.luogu.com.cn/problem/P5788">https://www.luogu.com.cn/problem/P5788</a></p><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>对应滑动窗口</p><p>应用场景：</p><ul><li><strong>求窗口里边的极值</strong></li><li><strong>找出各个元素距离其最近的最大&#x2F;最小值</strong></li></ul><p>思路：</p><p><img src="/./../images/%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0/image-20240927203716834.png" alt="image-20240927203716834"></p><p>题目链接：<a href="https://www.acwing.com/problem/content/156/">https://www.acwing.com/problem/content/156/</a></p><p><img src="/./../../../typora-images/image-20240831160747132-1725091689152-2.png" alt="image-20240831160747132"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="comment">//q数组存储的是目标数组下标</span></span><br><span class="line"><span class="type">int</span> q[N],a[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滑动窗口最小值</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i+k<span class="number">-1</span>) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&gt;=a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//滑动窗口最大值</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>,tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; q[hh] &lt; i+k<span class="number">-1</span>) hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;endl; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应力扣上的题目有：<a href="https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked">https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&amp;envId=top-100-liked</a></p><p>视频讲解版：<a href="https://www.bilibili.com/video/BV1H5411j7o6">https://www.bilibili.com/video/BV1H5411j7o6</a></p><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>针对的题目类型：字符串匹配</p><p>题目链接：<a href="https://www.acwing.com/problem/content/833/">https://www.acwing.com/problem/content/833/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>,M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[M],p[N]; <span class="comment">//s表示字符串，p表示模式串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ne就是next数组: 指模式串在 p[0…i] 中前缀 p[0…k] 等于后缀 p[i-k…i] 的最大的 k</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">eg：&quot;abababab&quot;</span></span><br><span class="line"><span class="comment">    ne[1] = 0</span></span><br><span class="line"><span class="comment">    ne[2] = 0</span></span><br><span class="line"><span class="comment">    ne[3] = 1</span></span><br><span class="line"><span class="comment">    ne[4] = 2</span></span><br><span class="line"><span class="comment">    ne[5] = 3</span></span><br><span class="line"><span class="comment">    ne[6] = 4</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//注意相等的前缀、后缀在原字串中不能是 p[0…i] 本身</span></span><br><span class="line"><span class="comment">//在下标从1开始的写法中，找不到相等的前后缀，就令 next[i] = 0</span></span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//+1代表下标从1开始的写法</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理next数组  ——&gt;  相当于 两个模式串 进行比对</span></span><br><span class="line">    <span class="comment">//在下标从1开始的写法中，找不到相等的前后缀，就令ne[i]=0;   所以至少从下标2开始才有可能公共前后缀</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//前后缀匹配不成功</span></span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="comment">//设置ne[i]</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//kmp匹配</span></span><br><span class="line">    <span class="comment">//重要！！！每个匹配过程为：p的下一个字符（j+1）与s当前的字符（i） 比较         </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//匹配成功</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>高效地存储和查找<strong>字符串集合</strong>的<strong>数据结构</strong></p><p><img src="/./../images/%E6%A1%86%E6%9E%B6/image-20240803160840153.png" alt="image-20240803160840153"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;</span><br><span class="line"><span class="comment">//son数组表示存储所有节点，每个节点都可能存在子节点，子节点对应所有小写字母(a - z)</span></span><br><span class="line"><span class="comment">//cnt表示以当前节点为结尾的字符串有多少个</span></span><br><span class="line"><span class="comment">//idx为标记，对应节点的编号</span></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//相当于根节点</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">//对应编号0-26</span></span><br><span class="line">        <span class="comment">//如果没有找到，则更新新的节点(通过idx编号更新来表示)</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> t;</span><br><span class="line">        cin&gt;&gt;t&gt;&gt;str;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(str)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过使用struct定义节点的方式来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Trie</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="built_in">sizeof</span>(next));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Trie* node = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                    node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                node = node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Trie* node = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                node = node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="差分-≈前序和的逆序-l，r-c"><a href="#差分-≈前序和的逆序-l，r-c" class="headerlink" title="差分(≈前序和的逆序)[l，r] + c"></a>差分(≈前序和的逆序)[l，r] + c</h1><p><strong>最主要的性质：</strong></p><p><strong>差分数组求前缀和结果等于原数组</strong></p><p>一维差分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//b是差分数组，a是b的前缀和      ai = b1 + b2 +...+bi      而   b1 = a1,b2 = a2-a1,bn = an - an-1</span></span><br><span class="line"><span class="type">int</span> b[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要理解差分数组中，本质的式子就是</span></span><br><span class="line"><span class="comment">[l,r] + c  转换为  b[l]+c  b[r+1]-c</span></span><br><span class="line"><span class="comment">    由于差分数组中，对应的只要b[l]+c，那么在区间【l，n】上，每个数都会多加一个c</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    eg：</span></span><br><span class="line"><span class="comment">    最初</span></span><br><span class="line"><span class="comment">    b:   0  0  0  0  0  0  0  0</span></span><br><span class="line"><span class="comment">    a:   0  0  0  0  0  0  0  0</span></span><br><span class="line"><span class="comment">    在下标为1的差分数组，也就是b[1]进行+1操作，此时</span></span><br><span class="line"><span class="comment">    b:   0  1  0  0  0  0  0  0</span></span><br><span class="line"><span class="comment">    a:   0  1  1  1  1  1  1  1</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="comment">//先通过a差分自己，相当于 i下标的数组，对应的b[i]前缀和 就是通过 【i,i】+a[i]来实现</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)b[i] += b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题：<a href="https://leetcode.cn/problems/corporate-flight-bookings/">https://leetcode.cn/problems/corporate-flight-bookings/</a></p><p><a href="https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&amp;envId=top-interview-150">https://leetcode.cn/problems/h-index/description/?envType=study-plan-v2&amp;envId=top-interview-150</a></p><p><strong>二维差分</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">累加得到原数组：</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            b[i][j] += b[i<span class="number">-1</span>][j]+b[i][j<span class="number">-1</span>]-b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂-A-B"><a href="#快速幂-A-B" class="headerlink" title="快速幂(A^B)"></a>快速幂(A^B)</h1><p>思路：<br>1、当指数是偶数时，我们可以让指数除以2，底数乘以底数<br>2、当指数是奇数时，我们可以将指数变为偶数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a,<span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指数不为0情况</span></span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//指数为偶数</span></span><br><span class="line">        <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//底数*底数</span></span><br><span class="line">            a *= a;</span><br><span class="line">            <span class="comment">//指数/2</span></span><br><span class="line">            b /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指数为奇数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//ans乘以底数</span></span><br><span class="line">            ans*=a;</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>双指针一般有两种形态：</p><ol><li>左右指针在起点出发（i++，j++）</li><li>左右指针各自在起点和终点出发（i++，j–）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; i&amp;&amp;<span class="built_in">check</span>(i,j))j++;</span><br><span class="line">    <span class="comment">//具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>递归结束条件的选择+状态标记+递归后的恢复</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> used[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归结束条件的选择</span></span><br><span class="line"><span class="keyword">if</span> (u == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, path[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!used[i])</span><br><span class="line">&#123;</span><br><span class="line">path[u] = i;</span><br><span class="line">            <span class="comment">//状态标记</span></span><br><span class="line">used[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//递归后的恢复</span></span><br><span class="line">used[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度 O(h)</p><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>模拟队列 q[N], d[N] 使用d数组标记状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> grid[N][N];</span><br><span class="line"><span class="comment">//模拟队列</span></span><br><span class="line">PII q[N*N];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    q[<span class="number">0</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = t.second + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp;grid[x][y] == <span class="number">0</span>&amp;&amp; d[x][y]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以直接使用二维数组即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> grid[N][N]; <span class="comment">//初始地图</span></span><br><span class="line"><span class="type">int</span> dp[N][N];<span class="comment">//标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(&#123; r,c &#125;);</span><br><span class="line">dp[r][c] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> newR = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> newC = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (newR &gt;= <span class="number">0</span> &amp;&amp; newR &lt; n &amp;&amp; newC &gt;= <span class="number">0</span> &amp;&amp; newC &lt; m &amp;&amp; dp[newR][newC]==<span class="number">0</span> &amp;&amp; grid[newR][newC] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(&#123; newR,newC &#125;);</span><br><span class="line">dp[newR][newC] = dp[cur.first][cur.second]+<span class="number">1</span>;</span><br><span class="line">grid[newR][newC] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度 O(2^h)</p><h1 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h1><p>树是一种特殊的图，是一种无环有向图</p><p>而有向图的存储方式通常有两种：</p><ul><li><strong>邻接矩阵</strong> —— 二维数组(grid[a，b]        a → b)</li><li><strong>邻接表</strong> —— 链表</li></ul><p>PS：一般来说，<strong>边多用矩阵，点多则用表！</strong>比如Dij算法，会给边的权重，所以一定要用到边，故而用矩阵；拓扑排序并不需要知道边的权重，一般只要知道点与点的联系，所以用表</p><p>邻接表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = N*<span class="number">2</span>;</span><br><span class="line"><span class="comment">//h表示有多少个节点(头结点) e存储所有边 ne表示下一个节点</span></span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化所有头结点</span></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>有向无环图 也被称为 拓扑图</p><p>拓扑排序通常采用BFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = N*<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//存储节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">   <span class="comment">//先找到入度为0的节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) q[++tt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span>(hh&lt;=tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="comment">//删除边   → 相当于连接的点的入度-1</span></span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="comment">//入度为0的话则加入到队列上</span></span><br><span class="line">            <span class="keyword">if</span>(!d[j]) q[++tt] = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过STL库中的vector，queue等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">//记录每个点的入度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; grid;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">grid[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">inDegree[b]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="comment">//结果集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="comment">//首先找到入度为0的作为起点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path = grid[cur];</span><br><span class="line">res.<span class="built_in">push_back</span>(cur);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">inDegree[path[i]]--;</span><br><span class="line"><span class="keyword">if</span> (inDegree[path[i]] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(path[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (res.<span class="built_in">size</span>() == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dijkstra-解决最短路问题"><a href="#Dijkstra-解决最短路问题" class="headerlink" title="Dijkstra(解决最短路问题)"></a>Dijkstra(解决最短路问题)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> grid[N][N];</span><br><span class="line"><span class="type">int</span> minDist[N];</span><br><span class="line"><span class="type">bool</span> stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(minDist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> minDist);</span><br><span class="line"><span class="comment">//取第一个点作为起始点</span></span><br><span class="line">minDist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!stk[j] &amp;&amp; (cur == <span class="number">-1</span> || minDist[cur] &gt; minDist[j]))</span><br><span class="line">&#123;</span><br><span class="line">cur = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入路径中并标记</span></span><br><span class="line">stk[cur] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新cur节点连接的其他节点的最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">minDist[j] = <span class="built_in">min</span>(minDist[j], minDist[cur] + grid[cur][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (minDist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> minDist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(grid, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> grid);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="comment">//如果存在重边或自环情况下，保留最小值</span></span><br><span class="line">grid[a][b] = <span class="built_in">min</span>(grid[a][b], c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">305</span>;</span><br><span class="line"><span class="type">int</span> s[N];<span class="comment">//前缀和 数组</span></span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="comment">//dp[i][j]表示在区间[i-j]合并成一堆的所有方案集合的最小代价dp[i][j] </span></span><br><span class="line"><span class="comment">//而要求的当前范围的最小代价的递推式子相当于dp[i][k] + dp[k+1][j] + s[j] - s[i-1];</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; s[i], s[i] += s[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间dp问题通常遍历顺序为：1.先遍历区间长度(区间) 2.再遍历区间左端点 3.区间右端点</span></span><br><span class="line"><span class="comment">//先推区间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//再推区间左端点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//右端点</span></span><br><span class="line"><span class="type">int</span> j = i + len - <span class="number">1</span>;</span><br><span class="line">dp[i][j] = <span class="number">1e8</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + s[j] - s[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>奥德赛&#x2F;赛车           </p><p>Lua高阶题</p><p>AB包</p><p>HR话术</p><p>真实面经 → 实习</p><p>箭头优先级最高，然后方块</p><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>本质上是动态规划</p><p>核心就是：dfs里边套用dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记忆化搜索     →  本质上就是dfs里边套了dp </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> grid[N][N];</span><br><span class="line"><span class="comment">//dp数组，dp[i][j]表示 以grid[i][j]为起点的滑雪路径最大值为dp[i][j]</span></span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//核心语句：</span></span><br><span class="line">    <span class="type">int</span> &amp;v = dp[r][c];</span><br><span class="line">    <span class="comment">//被走过的就是最终该点的最优结果了</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化当前位置dp，作为起点，此时滑雪路径为1</span></span><br><span class="line">    v = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> newR = r + dir[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> newC = c + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(newR&gt;=<span class="number">1</span>&amp;&amp;newR&lt;=n&amp;&amp;newC&gt;=<span class="number">1</span>&amp;&amp;newC&lt;=m&amp;&amp;grid[newR][newC]&lt;grid[r][c])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//核心语句：dp数组的状态计算</span></span><br><span class="line">            v = <span class="built_in">max</span>(v,<span class="built_in">dfs</span>(newR,newC)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;grid[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化dp数组，同时也可以作为标记  -1表示未被记录过        </span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span> dp);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">dfs</span>(i,j));</span><br><span class="line">            </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树类型"><a href="#二叉树类型" class="headerlink" title="二叉树类型"></a>二叉树类型</h1><h2 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h2><p>一般路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//中序   处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="comment">//如果到叶节点  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理结果</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给定和路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode*root, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    sum -= root-&gt;val;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum, path);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非自顶向下"><a href="#非自顶向下" class="headerlink" title="非自顶向下"></a>非自顶向下</h2><p>思路：</p><p>设计一个辅助函数maxpath，调用自身求出<strong>以一个节点为根节点</strong>的<strong>左侧最长路径left和右侧最长路径right</strong>，那么经过该节点的最长路径就是<strong>left+right</strong><br>接着只需要从根节点开始dfs,不断比较更新全局变量即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxPath</span><span class="params">(TreeNode *root)</span> <span class="comment">//以root为路径起始点的最长路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left=<span class="built_in">maxPath</span>(root-&gt;left);</span><br><span class="line">    <span class="type">int</span> right=<span class="built_in">maxPath</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">//中间逻辑</span></span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">max</span>(res, left + right + root-&gt;val); <span class="comment">//更新全局变量  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left, right);   <span class="comment">//返回左右路径较长者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：</strong></p><p>1、left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等</p><p>2、全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0</p><p>3、注意两点之间路径为1，因此一个点是不能构成路径的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（一）</title>
      <link href="/2024/06/11/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/06/11/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是热更新"><a href="#什么是热更新" class="headerlink" title="什么是热更新"></a>什么是热更新</h1><p>热更新（Hot Update）是指在应用程序运行期间，不停止或重新启动程序而进行更新的一种技术。通过热更新，开发者可以修复 bug、添加新功能、优化性能等，而不需要用户重新下载和安装整个应用</p><p>热更新的流程：</p><ul><li>准备更新资源<ul><li>常见的方法包括： AssetBundle、Lua</li></ul></li><li>上传更新资源<ul><li>将准备好的更新资源上传到服务器，通常是HTTP服务器。这样客户端可以在运行时从服务器下载这些资源</li></ul></li><li>客户端检查更新<ul><li>客户端启动时，检查服务器上是否有新的更新</li></ul></li><li>下载更新资源</li><li>加载和应用更新资源</li><li>更新本地版本号</li></ul><p>热更新的好处：</p><ul><li>迅速修复bug </li><li>提升玩家留存率</li><li></li></ul><h1 id="AssetBundle-AB包"><a href="#AssetBundle-AB包" class="headerlink" title="AssetBundle(AB包)"></a>AssetBundle(AB包)</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>AB包是什么？</p><p>AssetBundle即<strong>资源包</strong>，类似压缩文件，它可以把多个游戏对象或者资源以二进制形式保存到AssetBundle文件中，里边单个资源也称之为Asset</p><p>AB包支持unity的格式有：模型、贴图、预制体、音效、材质球等</p><p><strong>AB包的作用：</strong></p><ul><li><strong>相对Resources下的资源，更好管理</strong> (管理资源)<ul><li>将资源打包放到远程服务器上，需要的时候再进行下载</li></ul></li><li><strong>减小包体大小</strong></li><li><strong>热更新的前提</strong></li></ul><p>热更新</p><p><img src="/./../../../typora-images/image-20240627100137737-1719456566128-1.png" alt="image-20240627100137737"></p><h2 id="资源打包"><a href="#资源打包" class="headerlink" title="资源打包"></a>资源打包</h2><p>首先要去Unity下载一个工具<code>Asset Bundle Brower</code>:(通过URL手动安装)</p><p><a href="https://github.com/Unity-Technologies/AssetBundles-Browser.git">https://github.com/Unity-Technologies/AssetBundles-Browser.git</a></p><p>然后便可在Window列表下找到 AB包 可视化界面，可以查看是否有资源打包了</p><p><img src="/./../../../typora-images/image-20240621204345692-1719456566129-5.png" alt="image-20240621204345692"></p><p><strong>PS：C#脚本不能被AB包打包进去！！！预制体绑定的脚本被打包后本质上不是脚本也被打包了，而单纯只是一个绑定的脚本的编号而已</strong></p><p><img src="/./../../../typora-images/image-20240620215126986-1719456566129-3.png" alt="image-20240620215126986"></p><p><img src="/./../../../typora-images/image-20240620220659721-1719456566129-7.png" alt="image-20240620220659721"></p><p>Build页签下各个属性值的作用：</p><ul><li>Clear Folders：是否情况文件夹，重新打包</li><li>Copy to StreamingAssets：是否拷贝到StreamingAssets文件夹</li><li><strong>Compression</strong><ul><li><strong>NoCompression：不压缩，解压快，但是包很大（不推荐）</strong></li><li><strong>LZMA：1. 压缩最小，解压慢  2. 用一个资源，会解压所有</strong></li><li><strong>LZ4：1. 压缩，相对LZMA大一点  2. 用什么就解压什么，内存占用低（推荐）</strong></li></ul></li></ul><p>最后是AB包生成的文件：</p><p><img src="/./../../../typora-images/image-20240620221616069-1719456566129-2.png" alt="image-20240620221616069"></p><p><img src="/./../../../typora-images/image-20240621204505059-1719456566129-6.png" alt="image-20240621204505059"></p><p><img src="/./../../../typora-images/image-20240621222651254-1719456566129-4.png" alt="image-20240621222651254"></p><ul><li><strong>AB包文件</strong> （也就是资源文件）</li><li><strong>manifest文件</strong> (固定文件)<ul><li>AB包文件信息</li><li>当加载时，提供的关键信息，资源信息，依赖信息等等</li></ul></li><li><strong>关键AB包</strong>（和目录名一样的包）<ul><li>主包</li><li>AB包依赖关键信息</li></ul></li></ul><p>其中主包的名字就是对应在打包过程中<code>Output Path</code>的值</p><p>详细讲解：<a href="https://blog.csdn.net/qq_36804363/article/details/121084431">https://blog.csdn.net/qq_36804363/article/details/121084431</a></p><h2 id="资源加载与卸载"><a href="#资源加载与卸载" class="headerlink" title="资源加载与卸载"></a>资源加载与卸载</h2><p>资源的加载主要分为几个步骤：</p><ul><li><p><strong>加载AB包</strong></p><ul><li>通过<code>AssetBundle.LoadFromFile(Path)</code>语句进行</li></ul></li><li><p><strong>加载AB包中的资源</strong></p><p>有两种方式进行加载：</p><ul><li><p>泛型加载</p><p>xx.LoadAsset<T>(Name)</p><p>其中xx对应的是前边获取加载的AB包的对象，然后&lt;&gt;填写要加载的资源类型，最后Name则填写对应的该资源的名称</p></li><li><p>Type指定类型加载</p><p>xx.LoadAsset(Name,typeof(类型))</p></li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//第一步：加载AB包</span></span><br><span class="line">       AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line">       <span class="comment">//第二步：加载AB包中的资源</span></span><br><span class="line">           <span class="comment">//有三种方式进行加载，一般采用其中两种：</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//泛型加载</span></span><br><span class="line">           GameObject obj = ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Type指定类型加载</span></span><br><span class="line">           <span class="comment">//GameObject obj = ab.LoadAsset(&quot;Cube&quot;, typeof(GameObject)) as GameObject;</span></span><br><span class="line">       Instantiate(obj);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同时常用的还有<strong>异步加载</strong>，也就是通过携程来完成资源的异步加载</p><p>异步加载的话需要使用携程，所以一般要创建一个对应的携程，然后传入的参数和前边一样，要有对应加载的AB包的Pat以及AB包要加载的资源的Name</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadABRes</span>(<span class="params"><span class="built_in">string</span> ABName,<span class="built_in">string</span> resName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一步 加载AB包</span></span><br><span class="line">        AssetBundleCreateRequest abcr = AssetBundle.LoadFromFileAsync(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + ABName);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abcr;</span><br><span class="line">        <span class="comment">//第二部 加载资源</span></span><br><span class="line">        AssetBundleRequest abq = abcr.assetBundle.LoadAssetAsync(resName,<span class="keyword">typeof</span>(GameObject));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abq;</span><br><span class="line">        <span class="comment">//abq.asset as GameObject</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>资源加载也有其他几种不同的方式：<a href="https://blog.csdn.net/wlqchengzhangji/article/details/107301970">https://blog.csdn.net/wlqchengzhangji/article/details/107301970</a></p><p><strong>PS：AB包不能够重复加载，否则报错</strong></p><p><strong>问题一：如何解决AB包不允许重复加载的问题？</strong></p><p>资源的卸载主要有两种方式：</p><ul><li><p>单个加载的AB包卸载</p><p>使用<code>xx.Unload(bool)</code>语句</p><p>​参数一般默认填写false，这样就只会卸载AB包，而不会卸载掉AB包的资源；如果填写true，则会把AB包加载的资源也一并卸载了</p></li><li><p>卸载所有加载的AB包</p></li></ul><p>​使用<code>AssetBundle.UnloadAllAssetBundles(bool)</code>语句</p><p>​参数同Unload一样，会影响是否连带着卸载AB包加载的资源</p><h2 id="AB包依赖"><a href="#AB包依赖" class="headerlink" title="AB包依赖"></a>AB包依赖</h2><p>在包中，如果一个包里边的某个资源使用了另外一个新的资源，那么该新资源也会被打包进去</p><p>此时如果把新的资源放到另外一个包中，启动就会发现因为缺少资源而导致出现相应的错误</p><p><img src="/./../../../typora-images/image-20240621215539747-1719456566129-8.png" alt="image-20240621215539747"></p><p>这时候就意味着需要用到AB包依赖：</p><p>AB包依赖：当一个资源身上用到了别的AB包中的资源，这个时候通过它创建对象就会出现资源丢失的情况，这时候就要把依赖包一起加载了才能恢复正常，相当于只要加载对应依赖的AB包即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要使用的物体</span></span><br><span class="line">AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该物体要依赖的其他的AB包</span></span><br><span class="line">        AssetBundle ab2 = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;shader&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是这种方式是建立在已知当前资源的依赖有哪些的情况下，那么如果不清楚的情况下，又该如何实现AB包的依赖？</p><p>这时候我们就要<strong>通过主包来获取依赖信息</strong>：</p><ol><li>加载主包</li></ol><p>​ <code>AssetBundle.LoadFromFile(Path)</code>，这里要注意路径使用的是主包的路径</p><ol start="2"><li><p>加载主包中的固定文件</p><p><code>LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;)</code></p></li><li><p>从固定文件中得到依赖信息</p></li><li><p>加载依赖包</p><p>最终代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖包的关键点：利用主包获取依赖信息</span></span><br><span class="line">       <span class="comment">//加载主包</span></span><br><span class="line">       AssetBundle abMain = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;StandaloneWindows&quot;</span>);</span><br><span class="line">       <span class="comment">//加载主包中的固定文件(一样的ID，在文件夹中查看就是后缀.manifest)</span></span><br><span class="line">       AssetBundleManifest abManifest = abMain.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line">       <span class="comment">//从固定文件中得到依赖信息</span></span><br><span class="line">       <span class="built_in">string</span>[] strs = abManifest.GetAllDependencies(<span class="string">&quot;model&quot;</span>);</span><br><span class="line">       <span class="comment">//得到依赖包的名字并加载</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; strs.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + strs[i]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="★AB包加载管理器"><a href="#★AB包加载管理器" class="headerlink" title="★AB包加载管理器"></a>★AB包加载管理器</h2><p>作用：<strong>目的是让外部更方便的进行资源加载，同时也是预防AB包被重复加载同时产生错误</strong></p><p>通常设置该管理器为单例模式，然后通过字典来存储加载过的AB包，以此来判断该AB包是否被加载过</p><p>这里继承的是一个泛型单例模式，具体内容可以查看之前<em>3D项目</em>初试里边的讲解，有提到过该模式的定义等</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240627112955393.png" alt="image-20240627112955393"></p><p><strong>同步加载：</strong></p><p>同步加载首先依然得要先得到一个主包和一个依赖包对应的配置文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AssetBundle mainAB = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> AssetBundleManifest manifest = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>而主包的加载通过<code>AssetBundle.LoadFromFile(Path)</code>，我们知道Path对应的是主包的路径，同时对应的一个是streamingAsset包的位置以及主包的名字，所以为了让其管理器能够正确加载对应的AB主包，仍需设定新的属性来让其使用的时候可以灵活更改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AB包存放路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> PathUrl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Application.streamingAssetsPath+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主包名，方便修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> MainABName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> UNITY_IOS</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;IOS&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">elif</span> UNITY_ANDROID</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;Android&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;PC&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以先进行包的加载：</p><p><img src="/./../../../typora-images/image-20240623111356608-1719456566129-11.png" alt="image-20240623111356608"></p><p>最后再通过资源的加载即可：</p><p><img src="/./../../../typora-images/image-20240623112059732-1719456566129-12.png" alt="image-20240623112059732"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">loadAB</span>(<span class="params">String abName,String resName</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先加载主包</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mainAB == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">mainAB = AssetBundle.LoadFromFile(PathUrl+mainName);</span><br><span class="line"></span><br><span class="line">manifest = mainAB.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AssetBundle ab = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过主包获取的配置文件，再根据要加载的目标包从配置文件找到对应的所有依赖包并加载</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span>[] strs = manifest.GetAllDependencies(abName)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; strs.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//避免重复加载AB包</span></span><br><span class="line">           <span class="keyword">if</span>(!abDir.ContainKey(strs[i]))</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">               ab = AssetBundle.LoadFromFile(PathUrl + strs[i]);</span><br><span class="line"></span><br><span class="line">               abDir.<span class="keyword">add</span>(str[i],ab);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载目标AB包</span></span><br><span class="line"> <span class="keyword">if</span>(!abDir.ContainKey(abName))</span><br><span class="line"></span><br><span class="line">          &#123;</span><br><span class="line"></span><br><span class="line">               ab = AssetBundle.LoadFromFile(PathUrl + strs[i]);</span><br><span class="line"></span><br><span class="line">               abDir.<span class="keyword">add</span>(abName,ab);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后加载该AB包资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> abDir[abName].LoadAsset(resName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，正常来说要传入一个泛型类型来表示我们要加载的资源类型，所以可以修改为：</p><p>这种方式会适用于到时候的Lua与C#交互</p><p><img src="/./../../../typora-images/image-20240623112521695-1719456566129-10.png" alt="image-20240623112521695"></p><p>或者</p><p>这种方式会适用于单纯通过C#来加载</p><p><img src="/./../../../typora-images/image-20240623112806638-1719456566129-13.png" alt="image-20240623112806638"></p><p>最后是对AB包和资源包的卸载，同样也分为单个卸载和所有包卸载：</p><p><img src="/./../../../typora-images/image-20240623113322426-1719456566129-15.png" alt="image-20240623113322426"></p><p><strong>异步加载：</strong></p><p>这里的异步加载指的是<strong>资源的异步加载</strong>，其AB包加载方式不变，资源的加载就要发生变化，这里就要用到委托的方式，通过委托来传递给外部，让外部去使用，同样的也有三种重载的方式：</p><p>根据名字异步加载</p><p><img src="/./../../../typora-images/image-20240623145547340-1719456566129-16.png" alt="image-20240623145547340"></p><p>根据Type异步加载</p><p><img src="/./../../../typora-images/image-20240623145842880-1719456566129-14.png" alt="image-20240623145842880"></p><p>根据泛型异步加载</p><p><img src="/./../../../typora-images/image-20240623150338877-1719456566129-17.png" alt="image-20240623150338877"></p><h1 id="Addressables"><a href="#Addressables" class="headerlink" title="Addressables"></a>Addressables</h1><p>Addressables是可以用于替代AssetBundle的高阶资源管理系统</p><p>Addressables的优点主要有：</p><ul><li>自动化管理AB包打包、发布、加载</li><li>可以更方便的进行本地、远程资源的加载</li><li>系统会自动处理资源关联性</li><li>内存管理更方便</li><li>迭代更方便</li></ul><p><img src="/./../../../typora-images/image-20240624172418547-1719456566129-19.png" alt="image-20240624172418547"></p><p>Addressables也是外部包，所以要先进行导入才能使用</p><p><img src="/./../../../typora-images/image-20240624173540221-1719456566129-18.png" alt="image-20240624173540221"></p><p>同时还要创建Addressables的配置文件，这里主要有两种方式来进行创建相关的配置文件：</p><p><img src="/./../../../typora-images/image-20240624173829970-1719456566129-20.png" alt="image-20240624173829970"></p><p>第二种方式就是直接在资源的Inspector标签下点击Addressable即可自动创建以及生成相关的配置文件，最后是配置文件的截图：</p><p><img src="/./../../../typora-images/image-20240624174053902-1719456566129-21.png" alt="image-20240624174053902"></p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><h3 id="可寻址资源设置"><a href="#可寻址资源设置" class="headerlink" title="可寻址资源设置"></a>可寻址资源设置</h3><p>可寻址资源设置：当创建物体并作为预制体存入到资源文件夹<code>Resources</code>下，如果我们要让其被Addressable管理器进行管理，那么在勾选其对应选项后，它就会变成可寻址资源并被移动至新的<code>Resources_moved</code>文件夹下</p><p><img src="/./../../../typora-images/image-20240624174744195-1719456566129-22.png" alt="image-20240624174744195"></p><p>原因：由于Resources文件夹下资源会最终打包出去，如果变为寻址资源意味着想通过Addressables进行管理，那么就没有必要通过Resources方式去加载和打包，所以会自动迁移避免重复打包导致浪费空间</p><p><strong>PS：C#脚本无法作为可寻址资源！</strong></p><p>最后寻址资源可以在Addressables Groups上看到，同样的也可以选择直接把要变为寻址资源的内容直接拖拽过去，这样也能达到一样的效果</p><p>Addressables Groups上各个资源信息的意思：</p><p><img src="/./../../../typora-images/image-20240624215742049-1719456566129-23.png" alt="image-20240624215742049"></p><p>GroupName\Addressable Name：分组名\可寻址名（可重名）</p><p>Path：路径（不可重复)</p><p>Labels：标签（可重复，用于区分资源种类）</p><p>创建分组相关：</p><p>通过Create → Group → Packed Assets可以创建打包资源分组，每一个组可以作为一个或多个AB包</p><p>分组会比较常用，其可以按规则将资源分组，比如角色、怪物、UI等等</p><p>Tools工具：</p><p><img src="/./../../../typora-images/image-20240624221125774-1719456566129-24.png" alt="image-20240624221125774"></p><p>Play Mode Script：</p><p><img src="/./../../../typora-images/image-20240624221406037-1719456566129-26.png" alt="image-20240624221406037"></p><h3 id="指定资源加载"><a href="#指定资源加载" class="headerlink" title="指定资源加载"></a>指定资源加载</h3><p><strong>前提：首先要在前边设置完成可寻址的资源</strong></p><p>通过Addressables中的资源标识类来进行使用，将需要用到的资源包进行绑定，在C#脚本下调用：</p><p>Addressables中的资源标识类主要有</p><ul><li>AssetReference通用资源标识类，用来加载任意类型资源</li><li>AssetReferenceAtlasedSprite   图集资源标识类</li><li>AssetReferenceGameObject    游戏对象资源标识类</li><li>AssetReferenceSprite   图片资源标识类</li><li>AssetReferenceTexture 贴图资源标识类</li><li>AssetReferenceTexture2D</li><li>AssetReferenceTexture3D</li><li>AssetReferenceT&lt;&gt;    指定类型标识类</li></ul><p>通过标识类进行对应资源绑定之后，接下来就是要加载资源</p><p>PS：所有Addressables加载相关都使用异步加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle = assetReference.LoadAssetAsync&lt;GameObject&gt;();</span><br></pre></td></tr></table></figure><p>加载成功后使用</p><ol><li>通过事件函数传入的参数判断加载是否成功</li><li>通过资源标识类对象判断并创建</li></ol><p><img src="/./../../../typora-images/image-20240625234833153-1719456566129-28.png" alt="image-20240625234833153"></p><p>通过异步加载返回值对完成进行事件的监听</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle.Completed += XX;</span><br></pre></td></tr></table></figure><h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>在实际商业项目开发中，一般来说加载什么资源都是根据配置文件决定的，这些往往都是动态加载，所以我们需要知道如何根据名字或标签去加载对应的资源，这样就可以通过读表进行加载</p><p>通过Addressables Groups界面上直接创建并管理标签，然后为各个可寻址资源绑定对应的标签，完成第一步的操作：</p><p><img src="/./../../../typora-images/image-20240626214254742-1719456566129-29.png" alt="image-20240626214254742"></p><p><img src="/./../../../typora-images/image-20240626214318611-1719456566129-25.png" alt="image-20240626214318611"></p><p>同时Labels标签是可以支持多项标签的，比如多加一个颜色的标签</p><p><img src="/./../../../typora-images/image-20240626214857384-1719456566129-27.png" alt="image-20240626214857384"></p><p><img src="/./../../../typora-images/image-20240626215041444-1719456566129-30.png" alt="image-20240626215041444"></p><p><img src="/./../../../typora-images/image-20240626215223921-1719456566129-31.png" alt="image-20240626215223921"></p><p>Label标签的作用：</p><ul><li>相同作用的不同资源（模型、贴图、材质、UI等）</li><li>可以让其资源名相同但是标签不同</li><li>通过标签Label区分他们的用途，用于后续的动态加载</li><li>利用名字和标签可以单独动态加载某个资源，也可以利用它们共同决定加载哪个资源</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（四）</title>
      <link href="/2024/06/07/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/06/07/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UI部分"><a href="#UI部分" class="headerlink" title="UI部分"></a>UI部分</h1><p>诸如血条、能量条等要显示在各个对象头上的情况下，要注意Canvas组件下的模式(Render Mode)要切换为<code>World Space</code>模式，要实现的大致效果为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220036939.png" alt="image-20240607220036939"></p><p>同时由于是3D项目，如果要使用Sprite 2D的图片内容来实现UI的话，还要先手动下载并导入<code>2D Sprite</code></p><p>将对应的UI做好之后，一般都是要通过C#脚本来调用和绑定的，这里就有个小技巧：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220613669.png" alt="image-20240607220613669"></p><p>在脚本要挂载到各个对象并要进行绑定的情况下，可以通过在文件夹下点击脚本，先把要挂载的预制体绑定起来，这样只要对象上挂载该脚本，绑定的预制体也会跟着移动过去</p><p>若要绑定在怪物头顶上，则可以通过直接在预制体创建对应的一个空容器来对应头顶的坐标，这样可以方便后续的UI绑定操作：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220946406.png" alt="image-20240607220946406"></p><p>同时对应的UI脚本初始化的属性内容也和2D有所不同：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607222348957.png" alt="image-20240607222348957"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607222752393.png" alt="image-20240607222752393"></p><p>以及血条要一直处于摄像机视角位置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607233021610.png" alt="image-20240607233021610"></p><p>同时，如果场景下怪物过多，就没必要开启所有的血条一直保持显示状态，而是可以通过创建一个计时器，在攻击的时候打开，持续几秒后就关闭，减少显示的内容过多导致的资源浪费</p><h1 id="场景切换与跨场景交互"><a href="#场景切换与跨场景交互" class="headerlink" title="场景切换与跨场景交互"></a>场景切换与跨场景交互</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（三）</title>
      <link href="/2024/06/04/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/06/04/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="人物基本属性"><a href="#人物基本属性" class="headerlink" title="人物基本属性"></a>人物基本属性</h1><p>通过Scriptable容器设置一个装基础数值的SO容器，再UI上创建SO容器对应的内容：玩家数据存储容器、怪物数据存储容器等，定义用来连接该容器的类，比如：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604191213093.png" alt="image-20240604191213093"></p><p>最后再把脚本挂载到对应的物体上，通过在物体上绑定对应的容器，就可以通过不同的操作来访问或者修改SO容器里边的数值内容了</p><h2 id="攻击实现"><a href="#攻击实现" class="headerlink" title="攻击实现*"></a>攻击实现*</h2><p>通常来说，一个游戏如果搭建有战斗系统或者比较成熟一点的武器框架，那么<strong>攻击力一般不会作为人物的基本属性来进行定义，而是单独拎出来作为一个数据容器进行定义</strong>，这样可以通过一个容器来分别代表不同类型武器或者职业，对应的攻击力、攻击CD、攻击Buff、攻击距离等内容自定义：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//近战攻击距离</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> attackRange;</span><br><span class="line">   <span class="comment">//远程攻击距离</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> skillRange;</span><br><span class="line">   <span class="comment">//间隔CD</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> coolDown;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> minDamage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> maxDamage;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//暴击倍率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> criticalMultiplier;</span><br><span class="line">   <span class="comment">//暴击几率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> criticalChance;</span><br><span class="line">... <span class="comment">//等等</span></span><br></pre></td></tr></table></figure><p>这样就可以创建该类型容器，然后为其自定义修改数值，再通过挂载的脚本进行绑定，有利于快速搭建</p><p>同时可以看到里边涉及到的有暴击率的内容，暴击率可以通过爆伤和爆率两个部分，其中演示了下暴击率的具体使用，比如可以通过<strong>Random.value</strong>方法的方式来计算本次攻击是否暴击：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604210516685.png" alt="image-20240604210516685"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">characterStart.isCritical = Random.<span class="keyword">value</span> &lt; characterStart.attackData.criticalChance;</span><br></pre></td></tr></table></figure><p>该方法随机取0.0 - 1.0的数字，只要让其满足在<strong>暴击率区间内</strong>即可判定是触发暴击了</p><p>接下来就是对攻击力进行处理，通常来说要根据自己定义的数值内容进行计算，比如游戏中的防御力、闪避率、debuff等都会影响到最终收到的伤害，所以要定义一个对应的计算公式或者一个简单的乘除方法来计算受到的伤害，攻击的内容一般也可以在Character类下进行，可以通过其本身绑定的其他容器来快捷进行计算：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">CharacterStart attacker,CharacterStart defener</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">int</span> damage = (<span class="built_in">int</span>)Mathf.Max(attacker.CurrentDamage() - defener.BaseDefence, <span class="number">0</span>);</span><br><span class="line">      currentHealth = Mathf.Max(currentHealth - damage, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CurrentDamage</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//攻击力</span></span><br><span class="line">      <span class="built_in">float</span> coreDamage = UnityEngine.Random.Range(attackData.minDamage,attackData.maxDamage);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//暴击</span></span><br><span class="line">      <span class="keyword">if</span>(isCritical)</span><br><span class="line">      &#123;</span><br><span class="line">          coreDamage *= attackData.criticalMultiplier;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">int</span>)coreDamage;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后是为其绑定触发攻击事件的方法，在定义了调用Character里边的Damage方法后，可以通过动画帧的方式来直接调用该方法：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604222555483.png" alt="image-20240604222555483"></p><p>在右上角的Function选择刚创建的造成攻击的方法即可，当然这种方法也有一些弊端，所以具体实现还是有很多不同方式可以来执行的，具体就靠个人实践了</p><p>死亡动画一般是在AnyState下连接的，这块有个要注意的设置的点：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605101155929.png" alt="image-20240605101155929"></p><p>要关闭，否则会一直播放</p><p>最后还有一些要注意到的细节点进行调整，其中一个就是到达目标点位置可能会带来的一些需要被优化的影响，如果指定一个比较大的物体，该物体模型过大可能会导致人物在即将到达目标点的时候左右移动缓慢寻找该目标点</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607135621710.png" alt="image-20240607135621710"></p><p>其中一个方式可以通过在代码中针对特定场景下调整Stopping Distance的距离，再下次移动的时候复原就行</p><h2 id="▲泛型单例模式"><a href="#▲泛型单例模式" class="headerlink" title="▲泛型单例模式"></a>▲泛型单例模式</h2><p>在制作Manager管理器相关的脚本内容的时候，通常这些管理器的脚本都要设置为单例模式来进行统一管理，方便我们进行一些功能的实现，这时候就可以使用到泛型单例模式，通过这个模式让我们节省很多创建单例的时间，而是通过一个泛型可被继承的自定义工具类来实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singletion</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singletion</span>&lt;<span class="title">T</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            instance = (T)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否创建成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> IsInitialized</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance != <span class="literal">null</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">this</span>) &#123; instance = <span class="literal">null</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接通过继承该泛型单例类来完成单例的创建：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605110020624.png" alt="image-20240605110020624"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>通过定义接口的方式来作为订阅与广播方来往的途径之一，让继承了该接口方式的类对象都作为订阅方，这样来实现观察者模式</p><p>首先定义订阅接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEndGameObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结束游戏的广播</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EndNotify</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着比如为每个怪物都绑定该接口并实现该方法，方法内容可以自定义，比如结束游戏时停止移动，停止动画等等一系列操作，接着是要在Manager管理器下来收集这些<strong>所有订阅了该方法的对象</strong>，同时定义添加和移除方法，方便让每创建一个该对象就能自动调用管理器下的这两个方法自动的添加到我们收集的列表中去：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//收集订阅方</span></span><br><span class="line">List&lt;IEndGameObserver&gt; endGameObservers = <span class="keyword">new</span> List&lt;IEndGameObserver&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddObserver</span>(<span class="params">IEndGameObserver observer</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       endGameObservers.Add(observer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveObserver</span>(<span class="params">IEndGameObserver observer</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       endGameObservers.Remove(observer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再将这些类对象脚本设置启动&#x2F;关闭时候通过管理器的两个方法自动加入&#x2F;退出该订阅列表即可，最后再回到管理器上实现广播的通知，比如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObserver</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> observer <span class="keyword">in</span> endGameObservers) </span><br><span class="line">        &#123;</span><br><span class="line">            observer.EndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>广播可以在需要触发的对象或者内容里边自己去设置和调整在什么时候开启这个广播，从而来让所有订阅方都能接收并完成后续的操作，这块就自主去制作就行</p><h1 id="多怪物设置"><a href="#多怪物设置" class="headerlink" title="多怪物设置"></a>多怪物设置</h1><p>当怪物有多个的情况下，要考虑到单纯复制会导致所有怪物都共用一个SO容器，这样就会导致一个怪物死亡其他怪物也跟着死亡的局面，这里就要了解到SO容器本质上也是一个模板，可以通过脚本的方式来复制模板给予到新创建的怪物，实现每个怪物都有单独独立的一个SO存储数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//模板</span></span><br><span class="line">   <span class="keyword">public</span> CharacterData_SO templateData;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> CharacterData_SO characterData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(templateData != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           characterData = Instantiate(templateData);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新怪物动画创建可以用一个可覆盖的动画控制器来进行重构，这样会缩短开发的时间：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605220751713.png" alt="image-20240605220751713"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605220851182.png" alt="image-20240605220851182"></p><p>这样就可以基于之前已经做好的怪物动画控制器来进行修改，也能快速的构建出来我们新的怪物动画内容，提高我们开发的效率</p><p>别的怪物素材可以选择一些免费的素材，比如<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605221112337.png" alt="image-20240605221112337">等FREE资源</p><h2 id="设置其他类型怪物效果"><a href="#设置其他类型怪物效果" class="headerlink" title="设置其他类型怪物效果"></a>设置其他类型怪物效果</h2><p>玩家碰撞时触发，把玩家击飞，在对应的动画帧里边添加对应的方法，击飞的主要来源一个就是力量，一个就是方向，通过对两个物体之间的坐标进行运算来得到一个相对坐标，再通过归一化后乘以力量，这样就能达到一个击飞的效果，像挑飞等动作大致相同，后续也可以去了解一下，这里简单看一下代码展示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KickOff</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(attackTarget != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.LookAt(attackTarget.transform);</span><br><span class="line"></span><br><span class="line">            Vector3 dir = attackTarget.transform.position - transform.position;</span><br><span class="line">            <span class="comment">//归一化</span></span><br><span class="line">            dir.Normalize();</span><br><span class="line"></span><br><span class="line">            attackTarget.GetComponent&lt;NavMeshAgent&gt;().isStopped = <span class="literal">true</span>;</span><br><span class="line">            attackTarget.GetComponent&lt;NavMeshAgent&gt;().velocity = dir*kickForce;</span><br><span class="line">            attackTarget.GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">&quot;Dizzy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时如果要更加现实一点，那么还要为动画播放的时候也绑定一个脚本，通过进入动画、动画进行中、动画结束三个阶段来实现对应的代码，从而可以实现类似被眩晕&#x2F;受伤时候无法移动的效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606172359477.png" alt="image-20240606172359477"></p><h3 id="石头砸人-▲网格碰撞体"><a href="#石头砸人-▲网格碰撞体" class="headerlink" title="石头砸人(▲网格碰撞体)"></a>石头砸人(▲网格碰撞体)</h3><p>设置怪物投石效果，具体表现为：发现玩家后丢出石头 → 石头砸到玩家 → 玩家被击退并眩晕</p><ol><li><p>第一步就是要创建对应的投掷物</p><p>首先这块需要添加刚体组件，因为我们要让石头被丢出去，且实际表现就是自由落体，所以需要刚体来实现运行轨迹</p></li></ol><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607163943339.png" alt="image-20240607163943339"></p><p>​新内容：<strong>网格碰撞体</strong> <strong>Mesh Collider</strong></p><p>​由于我们要实现石头碰到人物的时候会触发相应的代码内容，这意味着要有一个碰撞体，而对于石头这种不规则形状的3D物体，我们就需要用到一个新的组件<code>Mesh Colider</code>来实现这块内容，从而达到相同的效果：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607164331180.png" alt="image-20240607164331180"></p><ol start="2"><li><p>让石头被投掷出去</p><p>这意味着要对石头的刚体组件进行相应的操作，其实际上就是要有一个方向以及一个力，同时该内容的触发也要在动画的关键帧上去进行，单纯让石头动起来的代码大体为：</p></li></ol> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlyToTarget</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//细节修改  生成石头瞬间脱战，仍能把石头丢出去</span></span><br><span class="line">       <span class="keyword">if</span> (target == <span class="literal">null</span>)</span><br><span class="line">           target = FindObjectOfType&lt;PlayerController&gt;().gameObject;</span><br><span class="line"> </span><br><span class="line">       dir = (target.transform.position - transform.position + Vector3.up).normalized;</span><br><span class="line">       rb.AddForce(dir * force, ForceMode.Impulse);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>石头的生成并触发</p><p>石头的生成和触发可以绑定在对应的物体或者怪物身上，生成的时候使用<code>Instantiate</code>即可，同时让石头身上绑定的脚本对应的目标也赋值为当前物体要攻击的目标即可，最后是在对应的动画帧上设置Animation Event，然后选择该方法内容即可实现</p></li></ol><p>最后有一个细节需要考虑到，如果要让丢石头的时候，在石头生成再到丢出去的时间里边，如果玩家离开了攻击范围，那么这时候石头默认就不再被显示出来了，这里使用<code>FindObjectOfType&lt;PlayerController&gt;().gameObject</code>的方式直接查找到对应的Player对象解决的该问题，或许有其他方法</p><p>另外一个就是玩家会穿模石头，这块可以用为角色添加刚体组件来避免，要注意的是：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607213817812.png" alt="image-20240607213817812"></p><h2 id="正面存在敌人再进行攻击"><a href="#正面存在敌人再进行攻击" class="headerlink" title="正面存在敌人再进行攻击*"></a>正面存在敌人再进行攻击*</h2><p>新内容：<strong>扩展方法</strong></p><p><strong>概述：</strong> 在C#中，扩展方法是一种特殊的静态方法，它能够对现有类型进行增强，无需修改原始类型的情况下，添加新的方法。扩展方法是通过<strong>使用 <code>this</code> 关键字</strong>在一个<strong>非抽象的静态类</strong>中定义的，并且它<strong>必须有至少一个参数</strong>。<strong>第一个参数指定了你要扩展的类型，并且该参数前面的 <code>this</code> 关键字是不可省略的</strong></p><p>通过扩展方法的方式来进行定义，实现该内容主要就是通过敌人的正面一个扇形范围内检测是否有敌人，如果有则进行攻击，否则则继续其他操作，比如移动等</p><p>此时还要用到一个新的方法——<strong>点乘法</strong>，该方法就是用于通过扇形面积判断内容的，本质上也就是通过余弦值的大小来判断物体处于当前位置的哪个方位(正面or背面)：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606212944022.png" alt="image-20240606212944022"></p><p>可以看到官方给的实例为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606221945449.png" alt="image-20240606221945449"></p><p>这块可以通过该视频的详解：<a href="https://www.bilibili.com/video/BV1M2421u7Bm">https://www.bilibili.com/video/BV1M2421u7Bm</a></p><p>最后编写的扩展类就为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtensionMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> dotThreshold = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFacingTarget</span>(<span class="params"><span class="keyword">this</span> Transform transform,Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> vectorToTarget = target.position - transform.position;</span><br><span class="line">        vectorToTarget.Normalize();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> dot = Vector3.Dot(transform.forward,vectorToTarget);</span><br><span class="line">        <span class="keyword">return</span> dot &gt;= dotThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以方便让其他有需要的类可以直接使用扩展的方法，比如怪物类就可以采用该扩展类来进行需求判断，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(attackTarget != <span class="literal">null</span> &amp;&amp; transform.IsFacingTarget(attackTarget.transform))</span><br></pre></td></tr></table></figure><h1 id="Particle-System特效"><a href="#Particle-System特效" class="headerlink" title="Particle System特效"></a>Particle System特效</h1><p>通过Particle System实现一些特效效果，该组件的内容很多，具体内容需要去查看中文官方文档或者其他详细教程，一般在实践过程中根据需要再去了解具体实现即可</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607215316930.png" alt="image-20240607215316930"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（二）</title>
      <link href="/2024/06/02/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/06/02/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="鼠标控制人物移动"><a href="#鼠标控制人物移动" class="headerlink" title="鼠标控制人物移动"></a>鼠标控制人物移动</h1><p>通过事件的方式来实现，实际上具体的流程大致就分为：</p><p>鼠标点击的时候获取当前点位(Vector3) → 把点位传给对应的脚本进行处理，该脚本调用挂载角色身上的组件 → 赋值给组件上对应的方法，从而让人物移动到目标点位</p><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测*"></a>射线检测*</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602205859494.png" alt="image-20240602205859494"></p><p>可以直接通过该文档里的实例在实践中看到该射线</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602211958995.png" alt="image-20240602211958995"></p><p>所以只要让我们鼠标点击某个位置的时候，该射线就跟着我们的鼠标指向对应的位置，这样就可以通过射线来检测到点位了</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602212226729.png" alt="image-20240602212226729"></p><p>检测物品信息则是通过<strong>Raycast</strong>来实现的,能够被Raycast射线检测的物体的前提有：</p><ol><li><strong>具有 Collider 组件</strong>：</li></ol><ul><li>物体必须拥有 Collider 组件，如 BoxCollider, SphereCollider, MeshCollider 等，没有 Collider 的物体不会与射线发生交互。</li></ul><ol start="2"><li><strong>正确的层（Layer）设置</strong>：</li></ol><ul><li>Unity 允许你为每个物体设置层（Layer），并在执行 Raycast 时选择射线可以检测哪些层的物体，这是通过 Raycast 函数中的 Layer Mask 参数来实现的</li></ul><ol start="3"><li><strong>Collider 必须启用</strong>：</li></ol><ul><li>如果 Collider 组件被禁用，即使物体上有 Collider，射线也无法检测到它</li></ul><ol start="4"><li><strong>非触发器模式</strong>：</li></ol><ul><li>Collider 可以设置为“触发器”模式（Is Trigger 属性设置为 true）。在触发器模式下，Collider 用于触发事件而不是物理碰撞，通常射线不会检测到设置为触发器的 Collider，确保 Collider 的“Is Trigger”属性设置为 false。</li></ul><p>接着挂载对应的事件：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602211315747.png" alt="image-20240602211315747"></p><p>最后是实现脚本内容并进行测试</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新射线</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetCursorTexture</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Physics.Raycast(ray, <span class="keyword">out</span> hitInfo))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标点击移动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MouseController</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; hitInfo.collider != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hitInfo.collider.gameObject.CompareTag(<span class="string">&quot;Ground&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                OnMouseClicked?.Invoke(hitInfo.point);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时细节调整还有人物在移动和转向时的内容</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602215103663.png" alt="image-20240602215103663"></p><p>其中Stopping Distance指的是到达目标点 x 距离就停止，这种比较常用于不同长度武器下如果指向敌人要进行攻击的话，就可以运用到</p><p>Auto Braking则是刹车的意思，相当于人物到达目标点一定距离是就会平缓减速</p><p>最后实现鼠标控制移动，分别通过在角色身上挂载的角色控制脚本绑定事件，定义移动的函数，然后在Manager下挂载的对应脚本内容实现事件的注册与启用，检测鼠标点击也在该脚本下完成</p><h2 id="摄像机跟踪和后处理"><a href="#摄像机跟踪和后处理" class="headerlink" title="摄像机跟踪和后处理"></a>摄像机跟踪和后处理</h2><p>安装<code>Cinemachine</code>脚本，创建虚拟摄像机，创建完成后虚拟摄像机(<strong>CinemachineVirtualCamera</strong>)就会顶替掉Main Camera，同时这里还有个操作可以让<code>#Scene</code>视角也锁定到我们的相机视角：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602221755447.png" alt="image-20240602221755447"></p><p>然后对虚拟相机进行配置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602222144619.png" alt="image-20240602222144619"></p><p>这里要注意的是，当前跟踪相机它对准的中心点默认就是人物最底的一个点，如果要让视角在人物上某一位置的话，可以通过在人物创建一个子物体，通过调整子物体的坐标，然后再让虚拟相机跟随的视角是该子物体即可</p><p>跟随效果下还有多种效果可以实现，具体的数值更改有很多</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602231703920.png" alt="image-20240602231703920"></p><p>可以参考<a href="https://www.bilibili.com/video/BV1FN4y1G7n1">https://www.bilibili.com/video/BV1FN4y1G7n1</a></p><p><a href="https://blog.csdn.net/linxinfa/article/details/124537415">https://blog.csdn.net/linxinfa/article/details/124537415</a></p><p>同时在修改过程中，还可以通过可视化加快捷键的方式快速的对虚拟相机的角度进行更改：</p><p>选中虚拟相机 → GameObject下Align View to Selected → 鼠标或者AWSD调整新的角度 → 快捷键<code>Ctrl＋shift＋f</code>即可调整完成</p><h3 id="自由视角相机"><a href="#自由视角相机" class="headerlink" title="自由视角相机"></a>自由视角相机</h3><p>通过设置<code>FreeLook Cinema</code>来设置自由相机，对自由相机进行调整，了解里边对应的内容分别起到什么作用</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214409088.png" alt="image-20240603214409088"></p><p>这两个内容可以通过在Project Setting的Input Manager下可以查询到，只要把内容改为我们想要使用的按键即可</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214529911.png" alt="image-20240603214529911"></p><p>同时自由视角对应的三个红色圆环也可以自由设置范围大小，从而让视角更加符合实际</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214927708.png" alt="image-20240603214927708"></p><p>效果可以在实践的时候也进行调整，这时候只要把该虚拟相机里边的 Save During Play 勾选上即可实现在启动过程中也完成修改并保存的操作了</p><p>同时也可以更改相机的模式，比如让自由视角也能跟着人物的移动而发生变化或者跟着鼠标的点击而发生变化等等，只要通过<code>Binding Mode</code>里边选择类型尝试即可</p><p>如果是要实现第三人称视角且切换方向或者移动视角的时候，摄像机都是人物背后，那么可以调整为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606172757978.png" alt="image-20240606172757978"></p><h2 id="实现远近景效果"><a href="#实现远近景效果" class="headerlink" title="实现远近景效果"></a>实现远近景效果</h2><p>通过Lighting来实现画面的效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602233316296.png" alt="image-20240602233316296"></p><p>在Scene窗口模式中通过<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602233345607.png" alt="image-20240602233345607"></p><p>显示迷雾，编辑时可以选择忽略</p><h2 id="后处理-后续要深入一点"><a href="#后处理-后续要深入一点" class="headerlink" title="后处理*(后续要深入一点)"></a>后处理*(后续要深入一点)</h2><ul><li><p><strong>Volume的类型</strong></p><ul><li>Global Volume(当前选用)</li><li>Box Volume</li><li>Sphere Volume</li><li>Convex Mesh Volume</li></ul><p><img src="/./../../../typora-images/image-20240602233553204-1717343202890-14.png" alt="image-20240602233553204"></p></li><li><p><strong>Volume下的各种效果</strong>(不仅仅只有这些)</p></li></ul><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234733656.png" alt="image-20240602234733656"></p><p>其中Box Volume是区域处理，比如到达某个场景的时候出现什么效果等，所以该功能相对重要一些，后续有待再继续研究与了解</p><p>大致了解一下</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234233494.png" alt="image-20240602234233494"></p><p>Global下有多种效果可以实现，不同效果都不一样，需要配置的内容也不一样，同时，如果要实现效果，还要在<strong>相机</strong>位置进行启用：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234408214.png" alt="image-20240602234408214"></p><h2 id="遮挡剔除-后续要深入一点"><a href="#遮挡剔除-后续要深入一点" class="headerlink" title="遮挡剔除*(后续要深入一点)"></a>遮挡剔除*(后续要深入一点)</h2><p>通过创建<code>Shader Graph</code>来完成遮挡剔除的操作，创建方式：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603154017784.png" alt="image-20240603154017784"></p><p>然后基于该shader graph再创建一个material材质球，双击shader graph进入对应的编辑页面：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603154631849.png" alt="image-20240603154631849"></p><p>然后通过构建不同的效果以及数值来达到遮挡的效果，这里主要试用了Fresnel Effect、Multiply、Dither等来实现大致的效果：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603160956610.png" alt="image-20240603160956610"></p><p>其实<strong>本质上就是创建一个新的材质球</strong>，然后通过判定角色遮挡的时候调用该材质球，所以要在渲染管线位置进行条件切换的设置</p><p>PS：完成修改后要记得使用<code>Save Asset</code>选项进行保存！</p><p>回到URP渲染管线位置，在<strong>Universal Render Pipeline Asset_Renderer</strong>里进行设置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604143301027.png" alt="image-20240604143301027"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603161948511.png" alt="image-20240603161948511"></p><p>然后选择刚才创建的材质盒，同时为其设置好开启该材质盒的要求</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603162057342.png" alt="image-20240603162057342"></p><p>如图该条件表示就是通过深度来确定什么时候调整的，比如人物在树后边，则相当于经过树之后才是人物，这意味着人的深度比树的要高，所以选用greater的情况</p><p>同时不要忘了<code>Later Mask</code>也要调整起作用的图层是哪个，比如要对人物起遮挡效果，那么Later Mash就要切换为人物所在的图层</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603163249337.png" alt="image-20240603163249337"></p><p>同时还要多创建一个Render Object来让角色在没被遮挡的情况下材质为正常的材质：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603163357695.png" alt="image-20240603163357695"></p><p>最后是要修改一下树木遮挡鼠标点击，可以通过直接为树木添加一个忽略射线的图层<code>Ignore Raycast</code>，也可以通过直接删除树木里边的<code>Collider</code>组件，从而失去被射线检查到的情况</p><h1 id="怪物设定"><a href="#怪物设定" class="headerlink" title="怪物设定"></a>怪物设定</h1><p>这里有一个新的知识点，已知每个怪物到时候都要继承有一个基类，同时一些基础的组件是每个怪物都应该有的，那么就可以通过以下这种方式来实现当怪物<strong>挂载一个通用的脚本的时候同时也自动挂载其他需要的组件</strong>：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603201159185.png" alt="image-20240603201159185"></p><p>同时要注意挂载NavMeshAgent的时候也要调整一下该组件的数值，同时结合实际需求可能也要为其增加一个新的碰撞体，方便进行检查，交互等其他功能实现</p><p>同时视角遮挡也要添加怪物的层数，让怪物也不能被遮挡剔除掉，同上在Layer Mask下进行多选一层Enemy</p><h2 id="怪物范围检测"><a href="#怪物范围检测" class="headerlink" title="怪物范围检测"></a>怪物范围检测</h2><p>与2D不同的是，怪物的范围检测可以通过OverlapSphere球状检测：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603221211397.png" alt="image-20240603221211397"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> colliders = Physics.OverlapSphere(transform.position, sightRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> collider <span class="keyword">in</span> colliders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(collider.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前提是检测的人物身上也必须绑定有对应的碰撞体，这样才能检测到其身上挂载有colliders，才能进行后续内容判断</p><h2 id="怪物动画切换"><a href="#怪物动画切换" class="headerlink" title="怪物动画切换"></a>怪物动画切换</h2><p>通过不同动画图层Animator Layer管理动画，通过不同图层来实现同一时间播放不同的动画，从而得到一个比较完整的动画效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604151253055.png" alt="image-20240604151253055"></p><p>具体介绍可以参考：<a href="https://blog.csdn.net/weixin_39520967/article/details/107372810">https://blog.csdn.net/weixin_39520967/article/details/107372810</a></p><p>具体怪物动画什么时候切换在代码中进行实现，通过游戏设定的不同自己根据合理情况对动画切换的值进行更改</p><p>同时要区分Animator控制器里边Param数值类型的 <strong>Bool</strong> 和 <strong>Trigger</strong>： Trigger可以说相当于一次性的Bool，它在触发True就会自动返回false，在动画控制中也就相当于启动了一次动画，然后回到上一个动画状态</p><p>具体内容可以参考：<a href="https://blog.csdn.net/c3872931/article/details/132820214">https://blog.csdn.net/c3872931/article/details/132820214</a></p><p>怪物动画设置过程中，还有以下两个知识点记录一下：</p><p>除了通过使用Vector3.Distance来判断两点之间的距离，还可以通过<code>Vector3.SqrMagnitude</code>的方式来进行计算：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Vector3.SqrMagnitude(guardPos-transform.position)&lt;=agent.stoppingDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Walk = <span class="literal">false</span>;</span><br><span class="line">                        transform.rotation = Quaternion.Lerp(transform.rotation, guardRotation, <span class="number">0.01f</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>这种方式要比Distance的花销要小一些</p><p>第二个就是对于转向的控制，通常是使用Quaternion.Lerp进行一个缓慢转向而不是瞬间转向</p><h2 id="怪物巡逻"><a href="#怪物巡逻" class="headerlink" title="怪物巡逻"></a>怪物巡逻</h2><p>这里有个新的实用内容点：通过**OnDrawGizmosSelected()**方法来在场景里边可视化显示范围</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604171042562.png" alt="image-20240604171042562"></p><p>定义需要的巡逻实现内容，本质上就是在圈定的范围内计算随机点，当怪物到达随机点后再生成一个新的巡逻点，以此往复</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巡逻实现</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">       <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">       Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">       wayPoint = randomPoint;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>细节处理除了通过Vector3.Distance计算当前怪物与巡逻点的位置之外，还要增加<strong>对障碍物的判断</strong>，以防止随机点在障碍物必经过导致怪物重复被阻挡的情况，这时候要通过NavMesh组件下的<strong>SamplePosition</strong>方法来解决这个问题：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604163354347.png" alt="image-20240604163354347"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604163438854.png" alt="image-20240604163438854"></p><p>其中需要注意的是<code>areaMask</code>值,该值表示的是成功被过滤的区域类型，对应界面里边的：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604165246170.png" alt="image-20240604165246170"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巡逻实现</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">       <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">       Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">       <span class="comment">//修改后：</span></span><br><span class="line">       NavMeshHit hit;</span><br><span class="line">       wayPoint = NavMesh.SamplePosition(randomPoint,<span class="keyword">out</span> hit,patrolRange,<span class="number">1</span>)?hit.position:transform.position;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中填入的值为1，这意味着能够通过筛选的只有索引为0(列表下标)的区域，也就是Walkable</p><p><a href="">该索引是不是可以理解成Areas下该列表的下标值？比如第一行就是索引0，第二行就是索引1？</a></p><p>最终参考代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnemyState</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//站桩、巡逻、追击、死亡</span></span><br><span class="line">    GUARD,PATROL,CHASE,DEAD</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">RequireComponent(typeof(NavMeshAgent))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NavMeshAgent agent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EnemyState enemyState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否为站桩怪</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGUARD;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Basic Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//检测范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sightRadius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameObject attackTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Walk;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Chase;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Follow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//巡逻点到达后停留时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lookAtTime;</span><br><span class="line">    <span class="comment">//准备下一个巡逻的计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> remainLookAtTime;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Patrol State&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//巡逻范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> patrolRange;</span><br><span class="line">    <span class="keyword">private</span> Vector3 wayPoint;</span><br><span class="line">    <span class="comment">//初始点</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 guardPos;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        speed = agent.speed;</span><br><span class="line">        guardPos = transform.position;</span><br><span class="line"></span><br><span class="line">        remainLookAtTime = lookAtTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGUARD)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.GUARD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.PATROL;</span><br><span class="line">            GetNewWayPoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SwithState();   </span><br><span class="line">        SwitchAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchAnimator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Walk&quot;</span>, Walk);</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Chase&quot;</span>, Chase);</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Follow&quot;</span>, Follow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwithState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测附近是否有玩家</span></span><br><span class="line">        <span class="keyword">if</span>(FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.CHASE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(enemyState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.GUARD:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.PATROL:</span><br><span class="line">                Chase = <span class="literal">false</span>;</span><br><span class="line">                agent.speed = speed * <span class="number">0.5f</span>;</span><br><span class="line">                <span class="keyword">if</span> (Vector3.Distance(wayPoint,transform.position)&lt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Walk = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remainLookAtTime &gt; <span class="number">0</span>)</span><br><span class="line">                        remainLookAtTime -= Time.deltaTime;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        GetNewWayPoint();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Walk = <span class="literal">true</span>;</span><br><span class="line">                    agent.destination = wayPoint;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.CHASE:</span><br><span class="line">                changeToChase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.DEAD:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> colliders = Physics.OverlapSphere(transform.position, sightRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> collider <span class="keyword">in</span> colliders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(collider.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                attackTarget = collider.gameObject;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            attackTarget = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeToChase</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//追击player</span></span><br><span class="line">        <span class="comment">//在攻击范围内攻击</span></span><br><span class="line">        <span class="comment">//绑定动画</span></span><br><span class="line">        Walk = <span class="literal">false</span>;</span><br><span class="line">        Chase = <span class="literal">true</span>;</span><br><span class="line">        agent.speed = speed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回到上一个状态</span></span><br><span class="line">            Follow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(remainLookAtTime &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                agent.destination = transform.position;</span><br><span class="line">                remainLookAtTime -= Time.deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isGUARD)</span><br><span class="line">            &#123;</span><br><span class="line">                enemyState = EnemyState.GUARD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                enemyState = EnemyState.PATROL;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Follow = <span class="literal">true</span>;</span><br><span class="line">            agent.destination = attackTarget.transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//巡逻实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重置计时器</span></span><br><span class="line">        remainLookAtTime = lookAtTime;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">        <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">        Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">        <span class="comment">//修改后：</span></span><br><span class="line">        NavMeshHit hit;</span><br><span class="line">        wayPoint = NavMesh.SamplePosition(randomPoint,<span class="keyword">out</span> hit,patrolRange,<span class="number">1</span>)?hit.position:transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = Color.yellow;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position, patrolRange);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（一）</title>
      <link href="/2024/06/01/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95/"/>
      <url>/2024/06/01/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="3D建模渲染管线"><a href="#3D建模渲染管线" class="headerlink" title="3D建模渲染管线"></a>3D建模渲染管线</h1><p>手动安装URP的话，通常要在安装完成URP包后进行以下创建：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609194321333.png" alt="image-20240609194321333"></p><p>同时还要在Unity编辑器下进行渲染管线内容的绑定：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609195953223.png" alt="image-20240609195953223"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609200019263.png" alt="image-20240609200019263"></p><p>若素材因为渲染问题没有正确显示的情况下，要初始化或导入对应版本的渲染URP管线，然后在<code>Project Setting → Graphics 以及 Quality</code>下进行绑定对应的渲染URP</p><p>然后在如图的内容下进行使用，从而让建模重新被渲染</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601111222861.png" alt="image-20240601111222861"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601111426637.png" alt="image-20240601111426637"></p><p>具体的渲染内容，针对物品不同或内容不同可能需要进行不同的调整，该界面下如何使用到时候可以在遇到问题的情况下再去了解不同选择的作用，在对人物建模重新渲染这块，通过勾选<code>Material Upgrade</code>然后进行覆盖处理就能让人物建模重新显示出来了</p><h2 id="天空盒的使用与切换"><a href="#天空盒的使用与切换" class="headerlink" title="天空盒的使用与切换"></a>天空盒的使用与切换</h2><p>在<code>Window → Rendering → Lighting</code>打开可以让我们更改的页面</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601142753229.png" alt="image-20240601142753229"></p><p>在Environment选项下切换天空盒</p><p><strong>细节处理：</strong></p><p>调整阴影，通过减少渲染距离渲染阴影从而达成优化效果，节省资源开支，这部分需要切换到渲染管线位置来进行调整：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601143628824.png" alt="image-20240601143628824"></p><p>如果为了视角效果的逼真，通常阴影部分还可以添加多段层，从而来达到不同距离下看到的影子效果各不一样：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601143922397.png" alt="image-20240601143922397"></p><p>这块了解即可</p><h2 id="创建光线"><a href="#创建光线" class="headerlink" title="创建光线"></a>创建光线</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144533623.png" alt="image-20240601144533623"></p><p>以上选项对应的内容参考Unity文档手册即可</p><p>自己调整成需要的光线后点击<code>Generate Lighting</code>完成光线的编辑</p><p>接下来是环境光的设置，<strong>环境光源的类型可分为 天空盒、渐变和颜色</strong></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144917171.png" alt="image-20240601144917171"></p><p>其中天空盒是默认设置，其光源要比较自然；渐变则是一种环境光源，<strong>利用渐变来表现天空、空气、地面三种光源的颜色</strong>，可以创造出具有强烈冲击力的场景；色彩以单一颜色来表达环境光，因此可以创造出非常生动的印象</p><p>同时如果因为有天空盒，天空盒的存在也会影响环境光，导致照射的环境光的色彩不一样，这也可以进行调整，比如调整成默认的环境光，也支持自己调整对应颜色：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144851658.png" alt="image-20240601144851658"></p><p>这部分环境光的内容也可以参考：<a href="https://styly.cc/tips/unity-lighting/">https://styly.cc/tips/unity-lighting/</a></p><p>详细讲解也可以参考：<a href="https://www.youtube.com/watch?v=VnG2gOKV9dw">https://www.youtube.com/watch?v=VnG2gOKV9dw</a></p><h2 id="一些3D快捷键使用技巧"><a href="#一些3D快捷键使用技巧" class="headerlink" title="一些3D快捷键使用技巧"></a>一些3D快捷键使用技巧</h2><p>第一个是物品的摆放，一般情况下场景地图不是平坦的而是凹凸的，当我们新创建一个物品或者拖拽一个预制体进行摆放的时候，很难准确地把物品完整地与当前摆放角度摆放界面放置完整下去，这时候就可以通过**<code>V</code>键**来通过顶点快捷置入当前鼠标对应的地面</p><p>需要注意的是，该快捷键的摆放遇到凹凸不平，崎岖位置进行摆放，可能会因为顶点的偏移导致很难精准地放置到我们想要放到的斜面位置上</p><p>不过也可以通过<code>ctrl ＋ shift</code>拖动物体来与放置的位置进行缝合</p><p>第二个就是摄像机地快捷设置，在3D搭建场景里边，为了让Game窗口能够在一个比较符合我们的角度上进行摆放，通常可以在Scene先切换到一个合适地视角里，然后通过选中相机，快捷键<code>Ctrl+shift＋f</code>进行设置，这样相机的视角就是我们当前Scene下的视角了</p><h1 id="地图场景"><a href="#地图场景" class="headerlink" title="地图场景"></a>地图场景</h1><h2 id="场景快速搭建-polybrush"><a href="#场景快速搭建-polybrush" class="headerlink" title="场景快速搭建(polybrush)"></a>场景快速搭建(polybrush)</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601201010428.png" alt="image-20240601201010428"></p><p>导入成功后就可以看到多了一个Tool选项，选择PloyBrush即可打开对应的窗口，通过在窗口中进行场景编辑</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601203517685.png" alt="image-20240601203517685"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602173000978.png" alt="image-20240602173000978"></p><p>通常可以直接<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602173031063.png" alt="image-20240602173031063">基于这两个右键Material创建出对应的材质球，这样就可以继续通过Polybrush工具进行绘制了</p><p>polybrush提供了五个小功能，这些功能可以快速进行场景的搭建，具体的运用可以参考：<a href="https://blog.csdn.net/qq_57250692/article/details/132864343">https://blog.csdn.net/qq_57250692/article/details/132864343</a></p><p><a href="https://blog.csdn.net/weixin_50114337/article/details/128314370">https://blog.csdn.net/weixin_50114337/article/details/128314370</a></p><h2 id="场景地图扩大-probuilder"><a href="#场景地图扩大-probuilder" class="headerlink" title="场景地图扩大(probuilder)"></a>场景地图扩大(probuilder)</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601204630548.png" alt="image-20240601204630548"></p><p>导入成功后也在Tool下启动ProBuilder的编辑页面，通过probuilder窗口来进行场景制作</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601212525838.png" alt="image-20240601212525838"></p><p>通常是左键选择对应的内容，然后再左边的Shape Tool下选择模板，同时可以调整该场景(物体)的大小以及网格数量(1*1)</p><p>如果需要细微调动地图位置移动可以了解下<code>ProGrids</code></p><p>然后是地图(一般是用Plane图形)创建好要为其加上颜色，相当于陆地颜色，则要创建一个<code>Material</code>的材质球，然后把材质球拖动过去，进行自定义调色即可</p><p>最后是基础地形场景构建可以参考学习的内容：<a href="https://blog.csdn.net/WGYHAPPY/article/details/117851090">https://blog.csdn.net/WGYHAPPY/article/details/117851090</a></p><h1 id="地图烘焙"><a href="#地图烘焙" class="headerlink" title="地图烘焙"></a>地图烘焙</h1><p>首先还是要先下载对应的插件<code>AI Navigation</code>，然后便可以在<code>Window → AI → Navigation</code>打开对应的窗口</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602194856863.png" alt="image-20240602194856863"></p><p>该圆柱就是表示人物的大小与宽展，以及能够爬坡的角度等，然后是对当前主场景或者说主地形进行设置，让其选为可行区域(Walkable)或者不可行区域(Not Walkable)</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602195430995.png" alt="image-20240602195430995"></p><p>然后通过在<code>Bake</code>选项下进行设置应用</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602195739356.png" alt="image-20240602195739356"></p><p>这样就能在场景里看到哪部分区域是可行区域或者不可行区域了(有浅蓝色覆盖就是可行区域)，然后也要对场景里的一些物体，比如树木、巨石、城楼等实际物体的Navigation也进行调整，原理也和上边的操作一样，设置区域完成后也要记得按<code>Bake</code>进行运用，最后可以观察到：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602200316196.png" alt="image-20240602200316196"></p><p><strong>PS：</strong>该方法主要是用来设置地图场景<strong>默认本身就不能移动的物体</strong>，所以通过Navigation里边直接设置可以更加方便，但是如果我们只要让单个物品设置为障碍物不能被经过呢？</p><p>这时候可以为单独的物体添加一个障碍物的组件<strong>Nav Mesh Obstacle</strong>，通过这种方式设置的障碍物&#x2F;碰撞体本身可以允许被移动，其移动的时候不可行区域也会跟着移动</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602201745481.png" alt="image-20240602201745481"></p><p>以上两种方式分别对应了场景物体里边静态&#x2F;不可移动以及动态&#x2F;可被移动的设置，当前者物体被移动的时候，其不可行区域依然保持不变，而后者则可以跟着物体被移动</p><p>诸如此类下显示的绿色范围就是不可行区域的范围大小了，而由于默认范围大小没有调整，就是按照人物的宽展来的，所以还要对人物的宽展与大小进行设置：</p><p>为人物添加一个新的组件<strong>Nav Mesh Agent</strong></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602200742269.png" alt="image-20240602200742269"></p><p>同时在调整完成后还要对Navigation对应的Bake数值上也进行更改，其大小与宽展也要同人物该组件绑定的数值保持一致！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串篇</title>
      <link href="/2024/05/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"/>
      <url>/2024/05/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的基本操作"><a href="#字符串的基本操作" class="headerlink" title="字符串的基本操作"></a>字符串的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串输入</span></span><br><span class="line"><span class="comment">/*string str1;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; str1;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*string str2;</span></span><br><span class="line"><span class="comment">getline(cin, str2);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容量操作</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; str2.size();</span></span><br><span class="line"><span class="comment">str2.clear();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2.size();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*cout &lt;&lt; str2.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">str2.resize(10);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2 &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 将s中有效字符个数增加到10个，多出位置用&#x27;a&#x27;进行填充</span></span><br><span class="line"><span class="comment">// “aaaaaaaaaa”</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将s中有效字符个数增加到15个，多出位置用缺省值&#x27;\0&#x27;进行填充</span></span><br><span class="line"><span class="comment">// &quot;aaaaaaaaaa\0\0\0\0\0&quot;</span></span><br><span class="line"><span class="comment">// 注意此时s中有效字符个数已经增加到15个</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">15</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 将s中有效字符个数缩小到5个</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;测试 reverse&quot;</span> &lt;&lt; endl;</span><br><span class="line">s.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试reserve参数小于string的底层空间大小时，是否会将空间缩小</span></span><br><span class="line">s.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：reserve()一般和插入、operator+=配合     它只是扩充容量，size仍为原大小。</span></span><br><span class="line"><span class="comment">//resize()一般operator[]配合。                  它既扩容，又改变了size值，这样就可以通过[]访问。</span></span><br></pre></td></tr></table></figure><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string-ii/description/">https://leetcode.cn/problems/reverse-string-ii/description/</a></p><h2 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词*"></a>反转字符串里的单词*</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapString</span><span class="params">(string&amp; s, <span class="type">int</span> front, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=front,j=end; i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去掉字符串开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;s[fast] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉字符串中间多余的空格，只留下一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); fast++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[fast] == s[fast - <span class="number">1</span>] &amp;&amp; s[fast] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s[slow++] = s[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slow - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slow - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swapString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>||i==s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swapString</span>(s, start, i<span class="number">-1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>next数组的设计：</p><ul><li>初始化</li><li>前后缀不相同</li><li>前后缀相同</li><li>next更新</li></ul><h3 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h3><h2 id="int转char类型"><a href="#int转char类型" class="headerlink" title="int转char类型"></a>int转char类型</h2><p>在[0，25]数值中，转化为’a’ - ‘z’共26个小写字母</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">// = 0-25</span></span><br><span class="line"><span class="type">char</span> t = a + <span class="number">97</span>;</span><br></pre></td></tr></table></figure><h2 id="检查移除非字母数字字符-include-lt-ctype-h-gt"><a href="#检查移除非字母数字字符-include-lt-ctype-h-gt" class="headerlink" title="检查移除非字母数字字符(#include&lt;ctype.h&gt;)"></a>检查移除非字母数字字符(#include&lt;ctype.h&gt;)</h2><ul><li><strong>isalpha()：用来判断一个字符是否为字母</strong></li><li><strong>isalnum()：用来判断一个字符是否为数字或者字母</strong>，也就是说判断一个字符是否属于a~ z||A~ Z||0~9</li><li><strong>isdigit() ：用来检测一个字符是否是十进制数字0-9</strong></li><li>islower()：用来判断一个字符是否为小写字母，也就是是否属于a~z</li><li>isupper()：和islower相反，用来判断一个字符是否为大写字母</li></ul><h2 id="大写字母转小写，小写转大写"><a href="#大写字母转小写，小写转大写" class="headerlink" title="大写字母转小写，小写转大写"></a>大写字母转小写，小写转大写</h2><ul><li>整个字符串直接使用transform转换<ul><li>transform(str.begin(),str.end(),str.begin(),::tolower);</li><li>transform(str.begin(),str.end(),str.begin(),::toupper);</li></ul></li><li>手写转换<ul><li><strong>大写转小写： +&#x3D; 32</strong></li><li><strong>小写转大写： -&#x3D; 32</strong></li></ul></li><li>通过单个字符转换<ul><li><strong>tolower(char c)</strong></li><li><strong>toupper(char c)</strong></li></ul></li></ul><h1 id="cin-与-getline-共同使用的注意点"><a href="#cin-与-getline-共同使用的注意点" class="headerlink" title="cin 与 getline 共同使用的注意点"></a>cin 与 getline 共同使用的注意点</h1><p>在cin首先使用后，再次使用一个<code>cin.ignore()</code></p><p>这样就会忽略掉我们输入cin后进行过行，导致getline判定的是过行这个操作对应的字符</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="img"></p><h2 id="解题五部曲"><a href="#解题五部曲" class="headerlink" title="解题五部曲"></a>解题五部曲</h2><ul><li><strong>dp数组以及下标含义</strong></li><li><strong>递推公式</strong></li><li><strong>dp数组初始化</strong></li><li><strong>遍历顺序</strong></li><li><strong>打印数组</strong></li></ul><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>题目：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p>解题思路：</p><p>先进行五部曲分析：</p><p>1、dp数组以及下标含义——dp[i] 第i个斐波那契的dp[i]</p><p>2、递推公式</p><p>本题的斐波那契数本身的公式就是一个递推公式，即</p><p>dp[i] &#x3D; dp[i-1]+dp[i-2]</p><p>3、dp数组初始化</p><p>由于斐波那契数列本身的特性，相当于只有第一个和第二个是1，其他都是公式推算</p><p>4、遍历顺序</p><p>从前到后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>题目：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：第i阶楼梯总共有dp[i]种方式到达</p><p>2、递推公式</p><p>第一阶楼梯：1种</p><p>第二阶楼梯：2种</p><p>第三阶楼梯：3种</p><p>第四阶楼梯：5种</p><p>…</p><p>根据实际推算，以每次可以爬1-2个台阶的方式可以得出：</p><p>dp[i] &#x3D; dp[i-1]+dp[i-2]</p><p>3、dp数组初始化</p><p>这里要注意特殊情况0阶，第0阶楼梯默认1种</p><p>dp[0] &#x3D; 1，dp[1] &#x3D; 1</p><p>其他遵循递推公式</p><p>4、遍历顺序</p><p>从前往后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>题目：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：第i阶楼梯所需要的<strong>最小</strong>花费dp[i]</p><p>2、递推公式</p><p>cost[i]是i阶楼梯跳跃所需要的花费，i则是表示第i阶的楼梯</p><p>则当从第1阶楼梯进行跳跃，可以通过支付cost[1]来实现</p><p>当从第2阶楼梯进行跳跃，可以通过支付cost[2]来实现</p><p>如果要跳跃到第三阶，则有以下可能：</p><p>从第一阶楼梯支付，跳跃两层：dp[3] &#x3D; dp[1] + cost[1]</p><p>从第二阶楼梯支付，跳跃一层：dp[3] &#x3D; dp[2] + cost[2]</p><p>其中dp[1]表示到达第一阶已经花费的数量，dp[2]表示到达第二阶已经花费的数量</p><p>综上所述，可以得到递推公式为：</p><p>dp[i] &#x3D; min( (dp[i-1]+cost[i-1])，(dp[i-2]+cost[i-2]))</p><p>3、dp数组初始化</p><p>由于题目需求是可以选择从第0阶或者第1阶开始爬，所以：</p><p>dp[0] &#x3D; 0，dp[1] &#x3D; 0</p><p>4、遍历顺序</p><p>从前往后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> dp[<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i] = <span class="built_in">min</span>((dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]), (dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i ] [0]：持有股最大值</p><p>dp[i ] [1]：无持股最大值</p><p>2、递推公式</p><p>由于dp[i ] [0]表示持有股所得现金最大值，所以dp[i ] [0]最大值是在两种情况下取：</p><p>第一种情况：dp[i-1] [0]也就是之前就买入股的现金</p><p>第二种情况：- prices[i]也就是刚买入股的现金</p><p>由于dp[i ] [1]表示无持股所得现金最大值，所以dp[i ] [1]最大值是在两种情况下取：</p><p>第一种情况：dp[i-1] [1]也就是之前已经把股票售出(所以是无持股)的现金</p><p>第二种情况：dp[i ] [0]+prices[i]也就是刚售出股的现金</p><p>综上所述，递推公式即：</p><p><strong>dp[i] [1] &#x3D; max(dp[i-1] [1]，dp[i ] [0]+prices[i])</strong></p><p><strong>其中，dp[i ] [0] &#x3D; max(dp[i-1] [0]，-prices[i])</strong></p><p>3、初始化</p><p>由递推公式可知，初始要从dp[0 ] [0]，dp[0 ] [1]开始，所以初始化为：</p><p><strong>dp[0 ] [0] &#x3D; -prices[0]</strong> ， 由于dp[0 ] [0]表示持有股且它为首位，所以只能取第一天就买入股消费的现金，因为只有这样才满足我们对dp[i] [0]的定义！</p><p><strong>dp[0 ] [1] &#x3D; 0</strong>，由于dp[0 ] [1]表示无持股且它为首位，所以取第一天没买入股，也就是0</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>解题思路：</p><p>1、dp数组与I相同</p><p>2、递推公式</p><p>dp[i ] [1]表示未持有股状态，也就是之前售出或者刚售出，所以</p><p>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i] [0]+prices[i])，同I相比无变化</p><p>dp[i ] [0]表示持有股状态，也就是之前入股或者刚入股，而由于该题表示可以多次买卖股，只要当天只持有一股就行，相当于可能之前就已经售出过，处于无持股但是已经有了现金的状态，也就是dp[i-1] [1]，所以</p><p>dp[i ] [0] &#x3D; max(dp[i-1 ] [0]，dp[i-1] [1] - prices[i])，同I相比变化了</p><p>所以综上所述，递推公式为：</p><p><strong>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i] [0]+prices[i])</strong></p><p>其中，<strong>dp[i ] [0] &#x3D; max(dp[i-1 ] [0]，dp[i-1] [1] - prices[i])</strong></p><p>3、初始化与I相同</p><p>4、</p><p>5、</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//持有股的最大现金</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"><span class="comment">//无持股的最大现金</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>由于该题为至多两次买卖股票，所以dp数组用二维来方便记录如下情况：</p><p>dp[i] [0] ：不操作时现金</p><p>dp[i] [1]：第一次持有股票的最大现金</p><p>dp[i] [2]：第一次无持股的最大现金</p><p>dp[i] [3]：第二次持有股票的最大现金</p><p>dp[i] [4]：第二次无持股的最大现金</p><p>2、递推公式</p><p>dp[i] [0]：若不进行任何操作，则dp[i] [0] &#x3D; 0</p><p>dp[i] [1]为第一次持有股票的最大现金，所以有两种可能：</p><p>第一种为之前就已经第一次持有股票dp[i-1] [1]，</p><p>第二种为这次刚买入第一次股票dp[i-1] [0] - prices[i]</p><p>则<strong>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i-1] [0] - prices[i])</strong></p><p>dp[i] [2]为第一次无持股的最大现金，所以有两种可能：</p><p>第一种为之前就已经把第一次股票出售出去 ，dp[i-1] [2]，</p><p>第二种为这次刚把第一次买入的股票出售出去，dp[i-1] [1] + prices[i]</p><p><strong>dp[i] [2] &#x3D; max(dp[i-1] [2]，dp[i-1] [1] + prices[i])</strong></p><p>dp[i] [3]为第二次持有股票的最大现金，所以有两种可能：</p><p>第一种为之前就已经第二次持有股票dp[i-1] [3]，</p><p>第二种为刚买入第二次股票dp[i-1] [2] - prices[i]</p><p><strong>dp[i] [3] &#x3D; max(dp[i-1] [3]，dp[i-1] [2] - prices[i])</strong></p><p>dp[i] [4]为第二次无持股的最大现金，所以有两种可能：</p><p>第一种为之前就已经第二次无持股dp[i-1] [4]，</p><p>第二种为刚把第二次股票售出去，dp[i-1] [3] + prices[i]</p><p><strong>dp[i] [4] &#x3D; max(dp[i-1] [4]，dp[i-1] [3] + prices[i])</strong></p><p>3、初始化</p><p>dp[0] [0]：无操作，dp[0] [0] &#x3D; 0</p><p>dp[0] [1]为第一次持有股，即dp[0] [1] &#x3D; -prices[0]</p><p>dp[0] [2]为第一次不持有股，即dp[0] [1] &#x3D; 0</p><p>dp[0] [3]为第二次持有股，即dp[0] [2] &#x3D; -prices[0]</p><p>dp[0] [4]为第二次不持有股，即dp[0] [4] &#x3D; 0</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/</a></p><p>解题思路：</p><p>同买卖股票的最佳时机III，要注意</p><p>dp[0] [0]表示的是不操作</p><p>这样才可以方便后续以每次+2的情况下去推到 第x次持有股票以及第x次不持有股票的状态</p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>题目：<a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[ i] [j]：从起点到达<strong>第i行第j列</strong>共有dp[ i] [j]种方式</p><p>2、递推公式</p><p>通过画图可以清晰地发现</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p><p>相当于每个格子的到达方式是由它<strong>上一个格子向下走</strong>，<strong>左一个格子向右走</strong>得到的，所以能够得到对应的推导公式为：</p><p>dp[ i] [j] &#x3D; dp[ i-1] [j] + dp[ i] [j-1]</p><p>3、初始化</p><p>由于dp数组的含义可以知道，当起始点到同行右边任何点位的方式只有一种（只能向右走到达），起始点到同列下边任何点位的方式也只有一种（只能向下走到达），所以初始化为：</p><p>遍历第一行右边(dp[ 0] [j])都为1，只有一种方式能到达</p><p>遍历第一列下边(dp[ i] [0])都为1，只有一种方式能到达</p><p>4、遍历方式</p><p>从左到右，从上到下</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> dp[<span class="number">105</span>][<span class="number">105</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">           dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">           dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//递推公式</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">               dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>题目：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>解题思路：</p><p>1、dp数组以及下标的含义</p><p>dp[i]：小偷在第i个房间内能够取得的最高金额dp[i]</p><p>2、递推公式</p><p>由题目可以推测，假设以第三间房间来算小偷的最高金额，则有以下两种情况：</p><p>第一种，小偷进入第一间房间偷取金额dp[0]，间隔一间后偷取本间房间的金额nums[2]</p><p>第二种，小偷进入第二间房间偷取金额dp[1]，第三间为间隔所以无法偷取</p><p>所以第三间的金额计算就是 max(dp[0]，(dp[1]+nums[2]))</p><p>再以第四间房间来算，则两种情况分别是第三间的最高金额dp[2]与第二间的最高金额dp[1]加上相隔一间后本间金额nums[3]</p><p>综上所述，可以得到递推公式为：</p><p><strong>dp[i] &#x3D; max(dp[i-1]，(dp[i-2]+nums[i]))</strong></p><p>3、初始化</p><p>由于dp数组的意义，所以第一间房间金额必然是dp[0] &#x3D; nums[0]</p><p>而第二间房间比较特殊，由于递推公式需要有i-2，如果直接代入公式会导致数组下标为负数，不合法，结合题目情况，有：</p><p>dp[1] &#x3D; max(dp[0],nums[1])</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">105</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>();i++) </span><br><span class="line">&#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], (dp[i - <span class="number">2</span>] + nums[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍IV"><a href="#打家劫舍IV" class="headerlink" title="打家劫舍IV ()"></a>打家劫舍IV ()</h2><p>题目：</p><p>解题思路：</p><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：以<strong>nums[i]为尾</strong>的最长递增子序列的长度</p><p>2、递推公式</p><p>以nums &#x3D; [10,9,2,5,3,7,101,18]为例</p><p>当i &#x3D; 1时，dp[i] 表示以 nums[1]为尾的最长递增子序列[9]，dp[1] &#x3D; 1</p><p>当i &#x3D; 2时，dp[i] 表示以nums[2]为尾的最长递增子序列[2]，dp[2] &#x3D; 1</p><p>当i &#x3D; 3时，dp[i] 表示以nums[3]为尾的最长递增子序列[2，5]，dp[3] &#x3D; 2</p><p>…</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j])时，必有 dp[i] &#x3D; max(dp[i], dp[j] + 1)</p><p>综上可以知道，递推公式为：</p><p>dp[i] &#x3D; max(dp[i]，dp[j]+1); （其中j ∈ [0，i-1]）</p><p>3、初始化</p><p>由于dp数组的含义，<strong>每一个i对应的dp[i]（即最长递增子序列）起始大小至少都是1</strong></p><p>4、遍历顺序</p><p>dp[i]：从左到右</p><p>dp[j]：任意</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; res) res = dp[i]; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><p>题目：<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i] [j]：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]</p><p>2、递推公式</p><p>根据dp[i][j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>3、初始化</p><p>根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！</p><p>但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>所以dp[i] [0] 和dp[0] [j]初始化为0</p><p>拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg" alt="718.最长重复子数组"></p><p>4、遍历顺序</p><p>外层for循环遍历A，内层for循环遍历B</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>这里要理解一个核心的点就是<strong>删除</strong></p><p>解题思路：</p><p>1、dp数组以及下标意义</p><p>dp[i] [j]：长度为[0, i - 1]的字符串A与长度为[0, j - 1]的字符串B的<strong>最长公共子序列长度</strong>为dp[i] [j]</p><p>2、递推公式</p><p>主要就是两大情况： A[i - 1] 与 B[j - 1]相同，A[i - 1] 与 B[j - 1]不相同</p><p>如果A[i - 1] 与 B[j - 1]相同，则<strong>dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1</strong>;</p><p>如果A[i - 1] 与 B[j - 1]不相同，那就看看A[0, i - 2]与B[0, j - 1]的最长公共子序列 和 A[0, i - 1]与B[0, j - 2]的最长公共子序列，取最大的</p><p>即：<strong>dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1])</strong>;</p><p>3、初始化</p><p>统一初始为0</p><p>4、遍历顺序</p><p>从前向后，从上到下来遍历</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204115139616.jpg" alt="1143.最长公共子序列"></p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) </span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br></pre></td></tr></table></figure><p>同时另外一道题也一样：<a href="https://leetcode.cn/problems/uncrossed-lines/description/">https://leetcode.cn/problems/uncrossed-lines/description/</a></p><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), INT_MIN)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxx = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (maxx &lt; dp[i])</span><br><span class="line">                maxx = dp[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p><p>这里也是要理解<strong>删除</strong>的操作</p><h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/distinct-subsequences/description/">https://leetcode.cn/problems/distinct-subsequences/description/</a></p><p>这里也是要理解核心是<strong>删除</strong></p><p>该题有点难理解，可以看下：<a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><p>题目链接：<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>题目链接：<a href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p><p>该题要注意一个思考的点：</p><p>虽然本题的操作有添加操作，但实际上<strong>添加的操作 ＝ 删除的操作</strong></p><p>举例： word1 &#x3D; a， word2 &#x3D; ab</p><p>那么word2删除一个元素 b 就相当于 word1添加一个元素 b这两者的最少步数都是一样的！</p><p>所以实际上求最小值的时候，只要是两个字符串各自的删除就可以表示出来删除和添加这两个操作了</p><h3 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h3><p>题目链接：<a href="https://leetcode.cn/problems/palindromic-substrings/">https://leetcode.cn/problems/palindromic-substrings/</a></p><p>本题要注意dp数组的定义</p><p>我们在判断字符串S是否是回文，那么如果我们知道 s[1]，s[2]，s[3] 这个子串是回文的，那么只需要比较 s[0]和s[4]这两个元素是否相同，如果相同的话，这个字符串s 就是回文串。</p><p>那么此时我们是不是能找到一种递归关系，也就是判断一个子字符串（字符串的下表范围[i,j]）是否回文，依赖于，子字符串（下表范围[i + 1, j - 1]）） 是否是回文。</p><p>所以为了明确这种递归关系，我们的dp数组是要定义成一位二维dp数组。</p><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。</p><p>然后是递推公式的选择：</p><p>当s[i]与s[j]不相等，那dp[i] [j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1] [j - 1]是否为true。</li></ul><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p><p>本题要注意的点主要是初始化的地方：</p><p>dp数组如何初始化？</p><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] &#x3D; dp[i + 1] [j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] &#x3D; max(dp[i + 1] [j], dp[i] [j - 1]);中dp[i] [j]才不会被初始值覆盖。</p><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>01背包理论基础详情见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html</a></p><p>01背包对应的题型各不相同，只是本质上都可以转化为背包问题</p><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>题目链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p><p>分割等和子集对应的背包问题相当于：<strong>给我们一个容器，问我们能否装满这个容器</strong></p><p>分析：</p><ul><li>背包的体积为sum &#x2F; 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集</li><li><strong>背包中每一个元素是不可重复放入</strong>（01背包的前提）</li></ul><p>动规五部曲：</p><ol><li><p><strong>确定dp数组的下标以及含义</strong></p><p>dp[j] 表示装满重量为j的背包 能够放入的最大重量（最大价值）dp[j]  （本题里边每一个元素的值既是重量也是价值）</p><p>所以当dp[target] &#x3D; target  ，也就是<strong>装满</strong>重量为目标值target的背包所能放入的最大重量就等于目标值target的时候，返回true，反之false</p><p>也有装不满的情况：  [1,5,3,7]        dp[7]意味着没有装满的情况，因为此时dp[7]的最大重量只能是6，但是dp[6]则表示可以装满</p></li><li><p><strong>递推公式</strong></p></li></ol><p>​dp[j] &#x3D; max(dp[j], dp[j-nums[i]] + nums[i] )   也就是01背包的式子</p><ol start="3"><li><p>初始化</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p>如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了</p></li><li><p>确定遍历顺序</p><p>采用滚动一维数组的dp数组，所以按照先遍历物品数量再遍历物品重量的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>物品重量的遍历为什么要倒序可以参考讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p><ol start="5"><li>举例推导dp数组</li></ol></li></ol><p>最后进行代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//容量为j的背包最大能装满dp[j]</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">10010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= nums[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; nums[i])</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h3><p>题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p><p>最后一块石头的重量II对应的背包问题相当于：<strong>给我们一个容量的背包，它最多能够装多少</strong></p><p>该题本质上就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小</p><p>动规五部曲：</p><ol><li><strong>确定dp数组以及下标的含义</strong></li></ol><p>​**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。</p><p>​可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>​相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，所以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​依旧是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><ol start="3"><li><strong>dp数组如何初始化</strong></li></ol><p>​既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和</p><p>​因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 </p><p>​而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了</p><p>​接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了</p><ol start="4"><li><p><strong>确定遍历顺序</strong></p><p>同分割等和子集一致</p></li><li><p>举例推导dp数组</p></li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">15000</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//dp[j] 容量为j的背包 最大装满(类似 最大价值)为dp[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; target &gt;= stones[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; stones[i])</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum1 = sum - dp[target];<span class="comment">//第二堆物品</span></span><br><span class="line">        res = sum1 - dp[target];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>题目链接：<a href="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></p><p>目标和对应的背包问题相当于：<strong>给我们一个容器，问装满这个容器有多少种方法</strong></p><p>分析：</p><p>把集合分为两个子集，一个代表正数集left，一个代表负数集right，那么有：<br>left + right &#x3D; sum  (总和)         </p><p>PS：right虽然表示负数集合，但是意思是该里边的数值之和带上负号才是负数，所以此时可以先计算总和(相当于取绝对值)</p><p>题目意思可以表示为：<br>left - right &#x3D; target（目标值）<br>综上可以得到式子：<br>left &#x3D; (target + sum) &#x2F; 2      其中target和sum都是已知的值，所以可以求得left</p><p>此时问题就转化为<strong>在集合nums中找出和为left的组合</strong></p><p>动规五部曲：</p><ol><li><strong>确定dp数组以及下标的含义</strong></li></ol><p>​dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>​其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​有哪些来源可以推出dp[j]呢？</p><p>​只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法</p><p>​例如：dp[j]，j 为5</p><ul><li><p>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</p></li><li><p>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</p></li><li><p>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</p></li><li><p>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</p></li><li><p>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</p><pre><code>相当于，如果要装满容量为1的背包，则有dp[1]种方法实现，此时装满容量1的背包的方法就是dp[1]</code></pre></li></ul><p>​  如果要装满容量为2的背包，则有dp[2]种方法实现，……而要装满容量5的背包，它对应的可以装满的方法就有：</p><p>​  dp[j - nums[i]]累加起来的结果，如何理解？</p><p>​ 比如dp[5-nums[i]]，如果nums[i]为3，那么就相当于dp[5-3]是要达到目标值5的其中一种方法之一，这意味着dp[2]有多少种方法可以       达到dp[5]</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>dp数组如何初始化</strong></li></ol><p>​从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0</p><ol start="4"><li><p>确定遍历顺序</p><p>同上边两个背包问题一致</p></li><li><p>举例推导dp数组</p></li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(target) &gt; sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//dp[j] 表示装满容量j的背包 有dp[j]种方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &gt;= nums[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//递推公式</span></span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p>题目链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></p><p>一和零对应的背包问题就是：<strong>装满这个背包最多有多少个物品</strong></p><p>分析：</p><p><strong>m 和 n相当于是一个背包，两个维度的背包</strong></p><ol><li><strong>确定dp数组（dp table）以及下标的含义</strong></li></ol><p>​dp[i] [j]：最多有<strong>i个0</strong>和<strong>j个1</strong>的strs的最大子集的<strong>大小为dp[i] [j]</strong>  （这样就把三个变量都囊括下去了）</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1(也就是dp[i-x] [j-y]    x表示当前子集0的个数，y表示当前子集1的个数)</p><p>​所以可以推出递推公式：</p><p>​<strong>dp[i] [j] &#x3D; max(dp[i] [j], dp[i-x] [j-y] + 1)</strong>;</p><ol start="3"><li><strong>dp数组初始化</strong></li></ol><p>​因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖</p><ol start="4"><li>遍历顺序</li></ol><p>​外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p><p>​物品就是strs里的字符串，背包容量就是题目描述中的m和n</p><p>​所以顺序就为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (string str : strs) <span class="comment">//物品数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">//背包容量   两个维度(顺序颠倒也没问题)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= x; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= y; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">605</span>][<span class="number">605</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (string str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> s : str)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    x++;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    y++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= x; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= y; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - x][j - y] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>每件物品都有无限个（也就是同个物品可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>完全背包与01背包在动规五部曲的唯一区别就是遍历顺序的不同，01背包的遍历顺序是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而完全背包的遍历顺序是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者区别： 01背包是倒序遍历背包容量，而完全背包是正序遍历背包容量；同时完全背包的双层循环可以互相转换，而01背包不能</p><p>举例推导dp数组来了解为什么正序和倒序会导致物品复用</p><p>01倒序:</p><p><img src="/./../../../typora-images/20210110103614769-1716344111006-1.png" alt="动态规划-背包问题9"></p><p>完全正序：</p><p><img src="/./../../../typora-images/20210126104510106-1716344123969-3.jpg" alt="动态规划-完全背包"></p><h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p>题目链接：<a href="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></p><p>分析：本质上和 目标和  题目一样，相当于求装满该容量的背包有多少种方式</p><p>动规五部曲也同目标和一致，由于是完全背包问题，所以遍历顺序有区别，同时又因为该题目跟顺序有要求，所以不能像纯完全背包问题一样可以让两层循环随意颠倒</p><p>这时候区别在于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>最后代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">5005</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// dp[j]表示填满j容量的背包有dp[j]种方法</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h3><p>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iv/description/">https://leetcode.cn/problems/combination-sum-iv/description/</a></p><p>该题与上一题极其相似，区别只在于遍历顺序，上一题也提到了：</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong> （先物品再背包）</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。（先背包再物品）</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><h2 id="背包递推公式"><a href="#背包递推公式" class="headerlink" title="背包递推公式"></a>背包递推公式</h2><p>问<strong>能否能装满背包</strong>（或者最多装多少）：<strong>dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">动态规划：416.分割等和子集(opens new window)</a></li><li><a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li></ul><p>问<strong>装满背包有几种方法</strong>：<strong>dp[j] +&#x3D; dp[j - nums[i]]</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和(opens new window)</a></li><li><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li><li><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li><li><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li></ul><p>问<strong>背包装满最大价值</strong>：<strong>dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">动态规划：474.一和零(opens new window)</a></li></ul><p>问<strong>装满背包所有物品的最小个数</strong>：<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong> ，对应题目如下：</p><ul><li><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322.零钱兑换</a></p></li><li><p><a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/05/17/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/05/17/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="dfs-与-bfs-区别"><a href="#dfs-与-bfs-区别" class="headerlink" title="dfs 与 bfs 区别"></a>dfs 与 bfs 区别</h2><p>提到深度优先搜索（dfs），就不得不说和广度优先搜索（bfs）有什么区别</p><p>两者的区别：</p><ul><li>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</li><li>bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul><h1 id="dfs-深度优先搜索"><a href="#dfs-深度优先搜索" class="headerlink" title="dfs(深度优先搜索)"></a>dfs(深度优先搜索)</h1><p>dfs解决的是<strong>路怎么走</strong>的问题</p><p>dfs的关键点在于：</p><ul><li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li><li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程</li></ul><p>所以回溯算法本质上就是dfs，回溯的模板也就是dfs的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深搜三部曲：</strong></p><ol><li><p><strong>确认递归函数与参数</strong></p><p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以</p><p>一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多</p></li><li><p><strong>确认终止条件</strong></p></li><li><p><strong>处理目前搜索节点出发的路径</strong></p><p>一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">https://leetcode.cn/problems/all-paths-from-source-to-target/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 0节点到终点的路径</span></span><br><span class="line">    <span class="comment">// x：目前遍历的节点</span></span><br><span class="line">    <span class="comment">// graph：存当前的图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span></span><br><span class="line">        <span class="keyword">if</span> (x == graph.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[x].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历节点n链接的所有节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(graph[x][i]); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, graph[x][i]); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="bfs-广度优先搜索"><a href="#bfs-广度优先搜索" class="headerlink" title="bfs(广度优先搜索)"></a>bfs(广度优先搜索)</h1><p>bfs解决的是<strong>路有多长</strong>的问题</p><p><strong>bfs求的是点与点之间的最短路径！</strong></p><p>广度优先搜索一般采用<strong>队列</strong>的结构来进行</p><p>广搜的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        que.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</code> </p><p>这个数组是用来表示从当前位置可以移动到的四个方向：右、下、左、上。每个方向由一对坐标偏移量表示：</p><ul><li><code>&#123;0, 1&#125;</code>：向右移动，即当前列坐标 +1，行坐标不变。</li><li><code>&#123;1, 0&#125;</code>：向下移动，即当前行坐标 +1，列坐标不变。</li><li><code>&#123;-1, 0&#125;</code>：向左移动，即当前列坐标 -1，行坐标不变。</li><li><code>&#123;0, -1&#125;</code>：向上移动，即当前行坐标 -1，列坐标不变。</li></ul><p><strong>pari</strong>的描述：</p><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量</p><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h2 id="dfs解法"><a href="#dfs解法" class="headerlink" title="dfs解法"></a>dfs解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; grid,vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt;&amp; visited,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newR = r+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> newC = c+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newR &gt;= <span class="number">0</span>&amp;&amp;newR &lt; grid.<span class="built_in">size</span>()&amp;&amp;newC &gt;= <span class="number">0</span>&amp;&amp;newC &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[newR][newC]&amp;&amp;grid[newR][newC]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[newR][newC] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,visited,newR,newC);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="bfs解法"><a href="#bfs解法" class="headerlink" title="bfs解法"></a>bfs解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(&#123;r,c&#125;);</span><br><span class="line">visited[r][c] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; top = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> newR = top.first + dir[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> newC = top.second + dir[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (newR &gt;= <span class="number">0</span> &amp;&amp; newR &lt; grid.<span class="built_in">size</span>() &amp;&amp; newC &gt;= <span class="number">0</span> &amp;&amp; newC &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (grid[newR][newC] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[newR][newC])</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(&#123; newR,newC &#125;);</span><br><span class="line">visited[newR][newC] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a>太平洋大西洋水流问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 保存四个方向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从低向高遍历，注意这里visited是引用，即可以改变传入的pacific和atlantic的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 向四个方向遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 超过边界</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= heights.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= heights[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 高度不合适，注意这里是从低向高判断</span></span><br><span class="line">            <span class="keyword">if</span> (heights[x][y] &gt; heights[nextx][nexty]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span> (heights, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = heights[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// 这里不用担心空指针，题目要求说了长宽都大于1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录从太平洋边出发，可以遍历的节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; pacific = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录从大西洋出发，可以遍历的节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; atlantic = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最上最下行的节点出发，向高处遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span> (heights, pacific, i, <span class="number">0</span>); <span class="comment">// 遍历最左列，接触太平洋 </span></span><br><span class="line">            <span class="built_in">dfs</span> (heights, atlantic, i, m - <span class="number">1</span>); <span class="comment">// 遍历最右列，接触大西 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最左最右列的节点出发，向高处遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span> (heights, pacific, <span class="number">0</span>, j); <span class="comment">// 遍历最上行，接触太平洋</span></span><br><span class="line">            <span class="built_in">dfs</span> (heights, atlantic, n - <span class="number">1</span>, j); <span class="comment">// 遍历最下行，接触大西洋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果这个节点，从太平洋和大西洋出发都遍历过，就是结果</span></span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) result.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/./../../../typora-images/image-20240528235811656.png" alt="image-20240528235811656"></p><p><img src="/./../../../typora-images/image-20240528235757959.png" alt="image-20240528235757959"></p><p>35%通过而已</p><p>加上 记忆化搜索   优化的是bfs</p><p>dfs 路怎么走   bfs是路有多长</p><p>A* B* 跳点</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集主要有两个功能：</p><ul><li><strong>将两个元素添加到一个集合中</strong></li><li><strong>判断两个元素在不在同一个集合</strong></li></ul><p>路径压缩后的并查集<strong>时间复杂度在O(logn)与O(1)之间</strong></p><p>并查集模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inti</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集里查找根结点(祖先)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="built_in">father</span>(u)) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">father</span>(u) = <span class="built_in">find</span>(<span class="built_in">father</span>(u));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并集合 v→u</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根(祖先)</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根(祖先)</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;<span class="comment">//v的根指向u的根(v的祖先指向u的祖先)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题：<a href="https://kamacoder.com/problempage.php?pid=1179">https://kamacoder.com/problempage.php?pid=1179</a></p><h2 id="冗余连接-无向图"><a href="#冗余连接-无向图" class="headerlink" title="冗余连接(无向图)"></a>冗余连接(无向图)</h2><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1181">https://kamacoder.com/problempage.php?pid=1181</a></p><h2 id="冗余连接II-有向图"><a href="#冗余连接II-有向图" class="headerlink" title="冗余连接II(有向图)"></a>冗余连接II(有向图)</h2><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1182">https://kamacoder.com/problempage.php?pid=1182</a></p><p>连接II的思路详解：<a href="https://programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/kamacoder/0109.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II.html#%E6%80%9D%E8%B7%AF</a></p><p><strong>有向图的一个关键点就是要记录每个节点的出入度</strong>，所以通常要定义一个二维数组来对应记录<strong>每一条边</strong>  （vector[i] [0]表示的就是边的一个节点，vector[i] [1]表示的就是边的另外一个节点）</p><p>其他内容就是针对这个边的记录进行相应的操作，比如在该题中，需要我们去删除一条边而形成一个有向树(两个节点只有唯一的一条路径）。也就是要我们去删除入度为2的边</p><p>记录边的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录边  (双端节点)</span></span><br><span class="line">vector &lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line"><span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123; s,t &#125;);</span><br><span class="line">inDegree[t]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是针对该题目，分析出来的三种情况进行对应的处理：</p><ul><li><p>找到一条符合条件的边进行删除</p></li><li><p>多条边情况下，删除最靠后出现的一条边</p><ul><li>删除的边要让其能够形成有向树</li></ul></li><li><p>没有符合条件的边，意味着此时有边形成了环</p></li></ul><p>对应的处理也都是通过这样的流程来的：</p><ol><li>判断哪个节点的入度为2，记录下来</li><li>对于第一二种情况，开始进行构建树并删除边的操作，这样可以顺便判断能否构成有向树</li><li>对于第三种情况，直接构建树并在中途判断是否有环，若出现环则说明当前边就是我们要删除的边</li></ol><p>对于第二步和第三步的操作而言，每一次的查询同时也是对边的构建，这样可以让我们通过<strong>并查集</strong>来一边检查是否形成环路一边join(构建)</p><p>最终的代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">father</span><span class="params">(<span class="number">1001</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == father[u]) <span class="keyword">return</span> u;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> father[u] = <span class="built_in">find</span>(father[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u = <span class="built_in">find</span>(u);</span><br><span class="line"><span class="type">int</span> v = <span class="built_in">find</span>(v);</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> father[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="built_in">find</span>(u);</span><br><span class="line"><span class="type">int</span> v = <span class="built_in">find</span>(v);</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getRemoveEdge</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (edges[i][<span class="number">0</span>] == edges[i][<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; edges[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断删除边是否能够形成树，而不是变成有环的图</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">afterRemoveTree</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> delegeta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="comment">//通过输入的值开始构建树，途中就可以进行树的删除了 (一边开始构成边，一边进行判断能否在删除目标边后还能构成树)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//相当于删除边</span></span><br><span class="line"><span class="keyword">if</span> (i == delegeta) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//有环，不构成树</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里的遍历相当于每次操作都是添加边的操作，而</span></span><br><span class="line"><span class="comment">  通过isSame可以先判断要添加的这个边是否已经被连通了，如果被连通了意味着由于删除操作导致了我们再添加边的时候</span></span><br><span class="line"><span class="comment">  不再被构成树了，因为树必须保证两个节点只有唯一路径，而操作又是添加边的操作，所以可以返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isSame</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接边</span></span><br><span class="line"><span class="built_in">join</span>(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="comment">//记录边  (双端节点)</span></span><br><span class="line">vector &lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line"><span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">edges.<span class="built_in">push_back</span>(&#123; s,t &#125;);</span><br><span class="line">inDegree[t]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况一和二处理</span></span><br><span class="line"><span class="comment">//记录要删除的边(最多只有两条边！)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; deleteEdge;</span><br><span class="line"><span class="comment">//倒序遍历，因为要删除最后的一条边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到入度为0的边</span></span><br><span class="line"><span class="keyword">if</span> (inDegree[edges[i][<span class="number">1</span>]] == <span class="number">2</span>)</span><br><span class="line">deleteEdge.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始删除边</span></span><br><span class="line"><span class="keyword">if</span>(deleteEdge.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//由于上边已经通过倒序的方式来获取入度为2，也就是要删除的边了，所以deleteEdge[0]就是最靠后第一个应该被删除的边！</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">afterRemoveTree</span>(edges, deleteEdge[<span class="number">0</span>]))</span><br><span class="line">cout &lt;&lt; edges[deleteEdge[<span class="number">0</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[deleteEdge[<span class="number">0</span>]][<span class="number">1</span>];</span><br><span class="line"><span class="comment">//已知被删除的边最多总共就两个(deleteEdge的长度最多为2)，所以对应deleteEdge的下标不是0就是1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; edges[deleteEdge[<span class="number">1</span>]][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edges[deleteEdge[<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况三处理：有环，没有入度为2的节点</span></span><br><span class="line"><span class="built_in">getRemoveEdge</span>(edges);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树Prime"><a href="#最小生成树Prime" class="headerlink" title="最小生成树Prime"></a>最小生成树Prime</h1><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1053">https://kamacoder.com/problempage.php?pid=1053</a></p><p>Prime用于 <strong>连接图 中所有节点且总权重最小的树</strong></p><p>概述：最小生成树是所有节点的<strong>最小连通子图</strong>， 即：以最小的成本（边的权值）将图中所有节点链接到一起</p><p>prim算法 是从<strong>节点的角度</strong> 采用贪心的策略 每次寻找距离 最小生成树最近的节点 并加入到最小生成树中</p><p><strong>Prime三部曲：</strong></p><ol><li><strong>选距离生成树最近节点</strong></li><li><strong>最近节点加入生成树</strong></li><li><strong>更新非生成树节点到生成树的距离</strong></li></ol><p>由于最小生成树在本题中也是对应处理无向图的，所以可以在记录数值的时候为了方便计算定义为双向图，也就是A与B，B与A的数值都一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录两个节点间的路径值</span></span><br><span class="line"><span class="comment">//初始化为最大值</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grap</span>(v + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v + <span class="number">1</span>, <span class="number">10001</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v1, v2, val;</span><br><span class="line">cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; val;</span><br><span class="line"><span class="comment">//最小生成树是无向图，为了更好的操作通常可以定义为双向图，也就是记录A到B和B到A的距离</span></span><br><span class="line">grap[v1][v2] = val;</span><br><span class="line">grap[v2][v1] = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个比较重要的点就是要定义好一个数组用于记录非生成树节点到生成树的距离</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重要：定义记录距离最小生成树的各个节点的距离！</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(v + <span class="number">1</span>, <span class="number">10001</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h3><p>minDist 数组 里的数值初始化为 最大数，因为本题 节点距离不会超过 10000，所以 初始化最大数为 10001就可以。</p><p>那么为什么minDist和grap最开始要初始化为最大值？</p><p>现在 还没有最小生成树，默认每个节点距离最小生成树是最大的，这样后面我们在比较的时候，发现更近的距离，才能更新到 minDist 数组上。而minDist记录的实际上也是边的权值，而已知minDist最初时都是10001，那么边的权值最开始也就都默认为10001，这样才满足我们数组的定义</p><p>最小生成树prime本质上也是一种贪心策略，这意味着<strong>如果有v个节点，则最小串联所有节点的路径边实际上就是v-1条</strong>，所以加入最小生成树的步骤也就只进行v-1次即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有v个节点，则最小生成树的路径就只需要v-1条边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//prime第一步：选中距离最小生成树最近的节点</span></span><br><span class="line"><span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> minn = INT_MAX;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//选中的条件：</span></span><br><span class="line"><span class="comment">//1. 不是最小生成树里的节点  (定义vector&lt;bool&gt;数组记录)</span></span><br><span class="line"><span class="comment">//2. 距离最小生成树最近</span></span><br><span class="line"><span class="keyword">if</span> (!isInTree[j] &amp;&amp; minDist[j] &lt; minn)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cur = j;</span><br><span class="line">minn = minDist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prime第二步要记录加入最小生成树的节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最前边定义</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isInTree</span><span class="params">(v + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选中后进行标记</span></span><br><span class="line"><span class="comment">//prime第二步：加入到最小生成树</span></span><br><span class="line">isInTree[cur] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>第三步要进行所有非最小生成树节点对于最小生成树的最短路径的更新：本质上就是把新加入最小生成树的节点所相连的其他节点对比之前对应的minDist的值取最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prime第三步：更新非最小生成树的各个节点距离最小生成树的最小距离(更新minDist数组)</span></span><br><span class="line"><span class="comment">//实际上就是更新新加入的节点连接的各个节点与之前的最小距离进行对比，取最小值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//更新的前提：</span></span><br><span class="line"><span class="comment">//1. 非最小生成树的节点</span></span><br><span class="line"><span class="keyword">if</span> (!isInTree[j] &amp;&amp; grap[cur][j] &lt; minDist[j]) &#123;</span><br><span class="line">minDist[j] = grap[cur][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>概括来说，<strong>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序</strong>。</p><p>（把 <strong>有向无环图</strong> 进行<strong>线性排序</strong> 的算法 都可以叫做 拓扑排序）</p><p>当然拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p><p>所以<strong>拓扑排序也是图论中判断有向无环图的常用方法</strong>。</p><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1191">https://kamacoder.com/problempage.php?pid=1191</a></p><p><strong>拓扑排序是一种算法思路，其算法实现方式通常使用的是广搜(BFS)</strong></p><p>拓扑排序的过程，其实就两步：</p><ol><li>找到入度为0 的节点，加入结果集</li><li>将该节点从图中移除</li></ol><p>循环以上两步，直到 所有节点都在图中被移除了。</p><p>结果集的顺序，就是我们想要的拓扑排序顺序 （结果集里顺序可能不唯一）</p><p>这也意味着通常我们要记录下每个节点的入度以及每个节点连接的其他点的所有记录，所以第一步的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line"><span class="comment">//记录每个节点的入度</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//记录每个节点连接其他节点</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; unrecord;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">while</span> (M--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> S, T;</span><br><span class="line">cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">       <span class="comment">//记录入度</span></span><br><span class="line">inDegree[T]++;</span><br><span class="line">       <span class="comment">//记录该节点连接的其他节点</span></span><br><span class="line">unrecord[S].<span class="built_in">push_back</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再通过入度的集合查找到所有入度为0，也就是我们的目标点，将其记录下来，由于实现拓扑排序可以使用BFS，所以通过队列来实现这个过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到入度为0的节点作为初始节点</span></span><br><span class="line"><span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (que.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> node = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">res.<span class="built_in">push_back</span>(node);</span><br><span class="line"><span class="comment">//每次将入度为0的节点放入队列(结果集)后，都要进行下一步的处理：</span></span><br><span class="line"><span class="comment">//将该节点连接的每个节点入度都-1</span></span><br><span class="line"><span class="keyword">if</span> (unrecord[node].<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; unrecord[node].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">inDegree[unrecord[node][i]]--;</span><br><span class="line"><span class="keyword">if</span> (inDegree[unrecord[node][i]] == <span class="number">0</span>)</span><br><span class="line">que.<span class="built_in">push</span>(unrecord[node][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是可能存在有环的情况，但实际上，如果我们的结果集没有把所有元素都记录下来，意味着本身就是有环的情况了，如果无环的情况下，结果集的长度等于节点的个数，那就是正确结果了，除此之外就全部都是有环的情况</p><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1047">https://kamacoder.com/problempage.php?pid=1047</a></p><p>概述：在有权图（权值非负数）中求从起点到其他节点的<strong>最短路径算法</strong></p><p>需要注意两点：</p><ul><li><strong>★dijkstra 算法可以同时求 起点到所有节点的最短路径</strong></li><li>权值不能为负数</li></ul><p>dijkstra 算法 同样是贪心的思路，不断寻找距离 <strong>源点最近</strong>的没有访问过的节点。</p><p><strong>Dij三部曲：</strong></p><ol><li><strong>寻找距离源点最近的节点</strong></li><li><strong>该最近节点被标记访问过</strong></li><li><strong>更新未被标记的节点到源点的距离（即更新minDist数组）</strong></li></ol><p>Dij最初也是要定义一个记录所有边的数组，通常默认几个节点至少就要几个边，跟其他有向图无向图内容一致</p><p>Dij核心的一个数组是minDist数组，这里要区分于prime的区别，Dij的minDist数组表示的是<strong>当前节点距离源点的距离</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录边</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grap</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line"><span class="comment">//记录节点到源点的最短距离     minDist[i]就表示i节点距离源点的最短距离是minDist[i]</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minDist</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s, e, v;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; e &gt;&gt; v;</span><br><span class="line">grap[s][e] = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这两个数组都要初始化为最大值，方便后边的计算。Dij默认源点让其从1开始(或者给定的初始点)，由于默认minDist都为最大值，最开始第一步从源点出发选择源点，要先把minDist[1]也标记为0, 1到1的距离就是0，这样就可以开始后续的操作了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> start = <span class="number">1</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">minDist[start] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>Dij的第一步就是找到源点最近的节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> minVal = INT_MAX;</span><br><span class="line"><span class="comment">//Dijkstra第一步：选源点到哪个节点近且该节点未被访问过</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[j] &amp;&amp; minDist[j] &lt; minVal)</span><br><span class="line">&#123;</span><br><span class="line">cur = j;</span><br><span class="line">minVal = minDist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步要标记找到的节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra第二步：标记该节点已被访问</span></span><br><span class="line">visited[cur] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>第三步更新未被标记的节点到源点的距离，这一步实际上就是更新新标记的节点可以访问到的未被标记的节点，更新其节点最新的距离源点的最短距离：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra第三步：更新未被标记的节点到源点的最短距离</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visited[j] &amp;&amp; grap[cur][j] != INT_MAX &amp;&amp; minDist[cur] + grap[cur][j] &lt; minDist[j])</span><br><span class="line">minDist[j] = minDist[cur] + grap[cur][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的就是minDist[cur] + grap[cur] [j] 与 minDist[j]</p><p>这样只要最终minDist[end]不是最大值，就说明找到了起点到终点的最短路径了！同时minDist此时每一个下标记录的就都是对应节点距离源点的最短距离！</p><ul><li><strong>时间复杂度：O(n^2)</strong></li><li><strong>空间复杂度：O(n^2)</strong></li></ul><p>总结：<strong>Dij算法和BFS一样都是可以求最短路径的，但是区别在于BFS可以理解为针对的是权重相同的图，而Dij解决的是权重不同的图</strong></p><h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个方向移动</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义记忆化数组，用于存储最短路径</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，返回从 (sx, sy) 到达 (x, y) 的最短路径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果已经计算过该位置，直接返回存储的最短路径</span></span><br><span class="line">    <span class="keyword">if</span> (memo[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> memo[x][y];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经到达起点，距离为0</span></span><br><span class="line">    <span class="keyword">if</span> (x == sx &amp;&amp; y == sy) <span class="keyword">return</span> memo[x][y] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前最短路径为一个很大的值</span></span><br><span class="line">    <span class="type">int</span> shortest = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理四个方向的相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> ny = y + dy[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查边界</span></span><br><span class="line">        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 递归搜索相邻节点的最短路径，并更新最短路径</span></span><br><span class="line">            shortest = <span class="built_in">min</span>(shortest, <span class="built_in">dfs</span>(grid, nx, ny, sx, sy) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化，存储该位置的最短路径值</span></span><br><span class="line">    memo[x][y] = shortest;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shortest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;  <span class="comment">// 输入表格大小</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">grid</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));  <span class="comment">// 初始化表格</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sx, sy;  <span class="comment">// 起点位置</span></span><br><span class="line">    cin &gt;&gt; sx &gt;&gt; sy;  <span class="comment">// 输入起点</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> tx, ty;  <span class="comment">// 终点位置</span></span><br><span class="line">    cin &gt;&gt; tx &gt;&gt; ty;  <span class="comment">// 输入终点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化记忆化数组，初始值为 -1，表示未访问</span></span><br><span class="line">    memo = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用记忆化搜索函数，计算最短路径</span></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">dfs</span>(grid, tx, ty, sx, sy);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">if</span> (result &gt;= <span class="number">1e9</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法到达终点&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;最短路径长度: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/05/03/%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/05/03/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p><strong>链表的类型</strong></p><ul><li>单链表</li><li>双链表</li><li>循环链表</li></ul><p><strong>链表的存储方式</strong></p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p><strong>链表的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240503103823542.png" alt="image-20240503103823542"></p><p><strong>链表的操作</strong></p><p>删除节点</p><p>添加节点</p><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">ListNode* tmp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">cur-&gt;next = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next-&gt;val == val)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* del = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* cur = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    LinkedNode* dummyHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a>两两交换链表中的结点</h2><p>题目链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a></p><p>代码尝试:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       dummyHead-&gt;next = head;</span><br><span class="line">       ListNode* cur = dummyHead;</span><br><span class="line">       <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ListNode* temp = cur-&gt;next;</span><br><span class="line">           ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">           cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">           cur-&gt;next-&gt;next = temp;</span><br><span class="line">           cur-&gt;next-&gt;next-&gt;next = temp1;</span><br><span class="line"></span><br><span class="line">           cur = cur-&gt;next-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode* result = dummyHead-&gt;next;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">         ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">2</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (size - n - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        cur = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n <span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">       </span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> sizeA = <span class="number">0</span>, sizeB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sizeA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sizeB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> startIndex = <span class="built_in">abs</span>(sizeA - sizeB);</span><br><span class="line">        <span class="keyword">if</span> (sizeA &gt; sizeB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; startIndex; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; startIndex; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span> &amp;&amp; curB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB)</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2024/04/20/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2024/04/20/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="STL标准库"><a href="#STL标准库" class="headerlink" title="STL标准库"></a>STL标准库</h1><p>什么是STL？</p><p>STL主要包括了几个部分：</p><ul><li><strong>容器（Containers）</strong><ul><li>序列容器（vector、deque等）</li><li>关联容器（set、map等）</li><li>无序关联容器（unordered_set等）</li></ul></li><li><strong>算法（Algorithms）</strong><ul><li>非修改序列操作（find、count等）</li><li>修改序列操作（copy，replace，sort等）</li><li>删除操作</li><li>数值算法（accumulate（求和）、inner_product（内积）等）</li></ul></li><li><strong>迭代器（Iterators）</strong></li></ul><p>​迭代器是一种访问容器中元素的<strong>对象</strong>，类似于指针，不同的容器提供了不同类型的迭代器</p><ul><li><strong>函数对象（Function objects）</strong></li></ul><p>​用它们来封装行为或策略（比较、哈希等）</p><ul><li><p><strong>适配器（Adapters）</strong></p><ul><li><p>栈（stack）</p></li><li><p>队列（queue）</p></li><li><p>优先队列（priority_queue）</p><p>…</p></li></ul></li></ul><p>STL有三个版本，目前我们使用的基本上都为<code>SGI STL</code>，它是基于第一个版本HP STL实现的</p><p>面经：C++中stack是容器吗？为什么？</p><p>再解决这个问题时，先了解STL标准库里边的各个概念</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的概念：</p><p>容器是<strong>存储数据</strong>的<strong>数据结构</strong>，容器类直接管理数据元素的存储，并提供直接的访问和管理数据的方法，所以不同的容器各有各的数据结构和性能特点</p><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在STL中通常指的是一种特殊的结构，它可以改变一个类（通常是容器或迭代器）的接口，使之适应不同的需求。适配器可以作用于容器、迭代器或函数对象</p><p><strong>适配器本身不直接存储数据，而是利用另外一个容器来存储数据</strong>，同时提供一个修改过的接口来访问这些数据</p><p><strong>容器与适配器的关系：</strong></p><p>容器适配器（eg：stack，queue）使用一个底层容器来存储数据，但是改变了访问这些数据的方式，转而提供了一种限定的接口</p><p>这意味着<strong>适配器依赖于底层容器</strong>来管理数据，但也限制或扩展了用户对数据的操作方式</p><p><strong>容器提供了数据存储和管理的基础功能，而适配器则在这个基础上提供特定的数据访问和操作模式</strong>，STL提供这种方式提高了代码的复用性，也增强了代码的清晰度和可维护性</p><p>更好的理解容器与适配器，比如这样一个例子：</p><p>容器使用了deque（双端队列），特点是可以在两端快速插入和删除元素，deque本身就提供了一个直接接口，接下来使用适配器来改变操作方式</p><ul><li>使用stack适配器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;&gt; st;</span><br></pre></td></tr></table></figure><p>stack是后进先出结构，当用该适配器包装deque时，用户只能从deque的一端添加或移除元素，使其行为类似于栈</p><ul><li>使用queue适配器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>,std::deque&lt;<span class="type">int</span>&gt;&gt; qe;</span><br></pre></td></tr></table></figure><p>queue是先进先出结构，当用该适配器包装deque时，用户只能从尾部添加元素并从头部移除元素，使其行为类似于队列</p><p>回到上边的问题，我们就可以得到答案：C++中stack不是容器，而是一个容器适配器，因为栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以<strong>栈不提供走访功能，也不提供迭代器</strong></p><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）</strong></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器的概念：</p><p>迭代器就是一个<strong>类对象</strong></p><p>那么该对象里边有多少个成员变量？</p><p>3个，分别是</p><ul><li>开始指向</li><li>当前指向</li><li>终值指向</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>委托与事件</title>
      <link href="/2024/03/08/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/"/>
      <url>/2024/03/08/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托的作用：</p><ol><li>将<strong>函数</strong>作为<strong>函数的参数</strong>进行传递</li><li>声明事件并进行注册</li></ol><h2 id="委托类型"><a href="#委托类型" class="headerlink" title="委托类型"></a>委托类型</h2><ul><li><strong>无参无返回</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis(); <span class="comment">//启用委托</span></span><br><span class="line">pis.Invoke()<span class="comment">//第二种方式（常用）</span></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射子弹&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Pistol</span>()</span>;</span><br></pre></td></tr></table></figure><p><strong>第一个问题：既然初始一定要传入，那委托必须为非空吗？</strong></p><p>在解决这个问题之前，先继续探索委托的使用，在接下来的功能尝试下，就可以找到解决该问题的答案</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet; <span class="comment">//可以通过 &quot;+=&quot; 符号来注册方法</span></span><br><span class="line">pis += Bullet2; <span class="comment">//可以注册多个方法（一同使用）</span></span><br><span class="line"><span class="comment">//pis();</span></span><br><span class="line">pis.Invoke();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射第二颗子弹&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射子弹&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该内容最终显示在终端上的结果就为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308143353417.png" alt="image-20240308143353417"></p><p>同时，委托的注册事件严格遵循了<strong>注册的顺序</strong>，比如如果我更换上述注册的顺序，即：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时在终端上的结果就为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308143525245.png" alt="image-20240308143525245"></p><p>而既然可以注册，那么也就有注销的方式，所以可以通过”-&#x3D;”来注销事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis -= Bullet2;</span><br></pre></td></tr></table></figure><p>最后在终端上显示便只有两个事件了，这时候我们也找到了可以探讨第一个问题的方式，即在初始化的时候便使用注销的方式，这样就可以设置其委托为空(null)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis -= Bullet; <span class="comment">//注销事件</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(pis == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>此时打印出来便可以发现委托已经为空了，所以<strong>委托本身是可以为空的</strong>，而在实际应用开发中，由于委托本身是可能为空的，所以在应用委托的时候我们要对委托进行判断，而上述提到的两种委托启动的方式里，其实可以通过第二种方式的快捷判断来直接启用，语法为：<code>xxx?.Invoke()</code></p><p>该语法通过”?”来直接判断委托是否非空，进而确定是否为我们启用委托</p><ul><li><strong>有参有返回</strong></li></ul><p>接下来是有返回值且有带参数的委托事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (number+<span class="number">1</span>).ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>该种方式的委托，其需要输入的参数与我们要注册的事件需要传入的参数类型要一致但形参名字可以不一致（“a”与“number”），同时可以注意到的是，在我们对委托进行初始化时<code>new Pistol(Bullet)</code>传入的函数并没有输入形参，而这正常来说会报错，但其报错实际上只在我们启动事件的时候才会提示并显示</p><p>如果我们设置了另外一个委托事件并进行注册：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (number+<span class="number">1</span>).ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet2</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*number).ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>此时的显示结果为最后注册的事件2：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308151510495.png" alt="image-20240308151510495"></p><p>这时再尝试加入一个新的事件或者多注册一次事件1，再查看结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308151911137.png" alt="image-20240308151911137"></p><p><strong>第二个问题：需要返回值的委托进行事件注册，最终只能注册一个吗，如果只能注册一个，那么最终注册的事件是按最新注册的来还是按注册次数来？</strong></p><p>为了探讨该问题，我们需要再次做一个比较，由于刚才尝试的是 1（初始化）2 1的顺序，所以结果显示的是事件1的结果，此时事件1是最后注册的，且出现了两次，为了确定是顺序还是次数造成的最终结果，我们再次调换顺序：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>此时可以发现结果变为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308152244609.png" alt="image-20240308152244609"></p><p>所以可以初步定下结论，即<strong>带有返回值的委托事件其最终能被注册的有且仅有最后注册的事件</strong>，但是我们还不能确定是不是只有带有返回值的委托才有这种结论，因为我们的委托事件还需要进行传参，所以我们还要进行后边的测试</p><ul><li><strong>有参无返回</strong></li></ul><p>接下来是设置有参数传递但是没有返回值的委托事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis.Invoke(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number.ToString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet2</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine((<span class="number">2</span> * number).ToString()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>此时结果变为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308153347679.png" alt="image-20240308153347679"></p><p>我们可以发现，当我们把委托事件更改为无需返回值的时候，此时也有参数传递，但是当我们注册了多个事件后，再启动委托的时候可以发现所有被注册的事件都会被启用，为了再次确定，我们再进行最后一个类型的委托事件尝试</p><ul><li><strong>无参有返回</strong></li></ul><p>最后来进行有返回值但是没有参数传递的委托测试：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke());</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;发射子弹1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;发射子弹2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308154321265.png" alt="image-20240308154321265"></p><p>所以我们可以肯定的是：<strong>当委托为无返回值时，委托启用可以启用所有已经注册在委托下的事件；当委托为有返回值时，委托启用有且仅有最后一关注册的事件被启用，其他注册的事件不会被调用</strong></p><p><strong>PS：这里要注意的一点是，当委托为有返回值时，虽然委托最终调用的事件是最后一个注册的事件，但实际上其他事件也有被注册使用，只是最终启用的只是最后一个事件</strong></p><p>同时委托本身也根据这两种情况封装好了对应的可用委托类型（<strong>强类型委托</strong>）：</p><ul><li><strong>Action</strong></li></ul><p>Action是无返回值的泛型委托</p><p>eg：</p><p>Action表示无参无返回值的委托</p><p>Action&lt;int,string&gt;表示有传入参数int，string但是无返回值的委托</p><ul><li><strong>Func</strong></li></ul><p>Func是有返回值的泛型委托</p><p>eg：</p><p><strong>Func<int>表示无参，返回值为int的委托</strong></p><p>Func&lt;object,string,int&gt;表示传入参数为object，string，返回值为int的委托</p><p> Func&lt;T1,T2,,T3,int&gt; 表示传入参数为T1,T2,,T3(泛型)返回值为int的委托</p><p>这两种类型都支持至少0个参数，至多16个参数的传入</p><h2 id="委托应用"><a href="#委托应用" class="headerlink" title="委托应用"></a>委托应用</h2><p>如果是正常的委托，正如上述测试的例子一样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Callback callback = <span class="keyword">new</span> Callback(MyCallBack);</span><br><span class="line">callback();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCallBack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我的回电&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>()</span>;</span><br></pre></td></tr></table></figure><p>但在实际应用中，我们可能会尝试在我们的功能下（已经封装好内容的函数）进行其他函数的处理，这时候就可以使用委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyTest(MyCallBack); <span class="comment">//启用功能模块</span></span><br><span class="line"><span class="comment">//我的功能模块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTest</span>(<span class="params">Callback callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCallBack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我的回电&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>()</span>;</span><br></pre></td></tr></table></figure><p>我们还可以有更细致拆分的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyPlayerChose(<span class="number">30</span>, <span class="number">10</span>, ThePlanB);</span><br><span class="line"><span class="comment">//玩家选择自己的方案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPlayerChose</span>(<span class="params"><span class="built_in">int</span> A,<span class="built_in">int</span> B,ChosePlan myPlan</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPlan(A, B) &gt;= A)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前选择方案为A或C&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前选择方案为B或C&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我的第一个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanA</span>(<span class="params"><span class="built_in">int</span> Aa,<span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的第二个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanB</span>(<span class="params"><span class="built_in">int</span> Aa, <span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我的第三个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanC</span>(<span class="params"><span class="built_in">int</span> Aa, <span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Aa+Ab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">ChosePlan</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><p>通过该例子可以知道，委托可以让我们对函数进行定制化处理，能够让函数构造更加灵活</p><h2 id="委托进阶"><a href="#委托进阶" class="headerlink" title="委托进阶"></a>委托进阶</h2><p>我们在委托使用的时候知道，多端委托可以在我们启用的时候同时启用多个注册了的函数方法，那么如果中间有个注册的方法出现错误，会造成什么影响？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testEvent eventList = <span class="keyword">new</span> testEvent(myEventA);</span><br><span class="line">eventList += myEventB;</span><br><span class="line">eventList += myEventC;</span><br><span class="line">eventList?.Invoke();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventA</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestA&quot;</span>);</span><br><span class="line"><span class="comment">//第二个注册方法会抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventB</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;TestB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventC</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestC&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">testEvent</span>()</span>;</span><br></pre></td></tr></table></figure><p>通过实践可以发现，最终当我们启用该委托的时候，由于注册的事件B出现错误，所以委托最终会因为B出错，从而事件调用的只有A，而B和C都不会被启用</p><p>也就是说：<strong>调用委托时，如果其中的一个委托报错，则后面的也不会被调用</strong></p><p>同时我们知道的是委托如果有返回值的情况下，也只会启用最后注册的事件，所以另外一个尝试就是如果通过”-&#x3D;”标识符来卸载注册方法，需要的时间又是怎么样的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testEvent myTestList = <span class="keyword">new</span> testEvent(myEventA);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    myTestList += myEventB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line">myTestList += myEventC;</span><br><span class="line">myTestList -= myEventC; <span class="comment">//再将注销掉的事件分别换成A和B</span></span><br><span class="line">sw.Stop();</span><br><span class="line">Console.WriteLine(sw.ElapsedTicks);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventA</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestA&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventB</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestB&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventC</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestC&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">testEvent</span>()</span>;</span><br></pre></td></tr></table></figure><p>通过对取消注册最后事件(A，B，C)进行测试：</p><p>分别得到了780、356、265三个时间</p><p>原因是，<strong>委托注册事件本质上就是数组添加，所以remove的复杂度是O（n），且取消注册事件是由下往上进行的</strong></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>事件是一种特殊的委托</strong>，我们知道委托只要在被定义的时候就必须被注册，但是有些时候我们不想要这样做，这时候就可以用到事件了。</p><p>在这里补充一个说明，在定义委托的时候，它只是一个声明，声明这是一个委托；在定义事件的时候，它就已经是一个实例了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> MyDelegate myEvent; <span class="comment">//事件</span></span><br><span class="line"></span><br><span class="line"><span class="function">delegete <span class="keyword">void</span> <span class="title">MyPlan</span>()</span>; <span class="comment">//委托</span></span><br></pre></td></tr></table></figure><p>故而，<strong>事件</strong>一般是作为一个<strong>类的成员</strong>来出现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void eventTest1()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Console.WriteLine(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">demo.myEvent += eventTest1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//相当于上述的缩写，使用了Lambda表达式</span></span><br><span class="line">demo.myEvent += () =&gt; Console.WriteLine(<span class="string">&quot;hello&quot;</span>);   <span class="comment">//注册委托</span></span><br><span class="line">demo.invokeEvent(); <span class="comment">//启用事件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码段中，通过直接使用<code>Action</code>来省略了声明委托的前置，因为<code>Action</code>本身就是一个委托类型</p><p>另外一种案例就是让事件在我们类成员发生了变化的时候才启用，这时候就可以做到事件对成员变量的监听，从而实现我们想要的效果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line"><span class="comment">//注册委托</span></span><br><span class="line">demo2.myEvent += () =&gt; Console.WriteLine(<span class="string">&quot;数值发生了改变&quot;</span>);</span><br><span class="line">demo2.TheNum = <span class="number">1</span>;</span><br><span class="line">demo2.TheNum = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> theNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheNum &#123; <span class="keyword">get</span> =&gt; theNum; </span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            theNum = <span class="keyword">value</span>;</span><br><span class="line">            <span class="comment">//数值发生变化的时候，启用事件</span></span><br><span class="line">            myEvent?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是采用委托的话，我们并不可以通过这种方式来实现，因为委托需要先对函数事件进行注册</p><p>事件本质上就是C#提供的一个语法糖，它的作用是：</p><ol><li>将委托以私有变量的形式封装在类内，不让外面访问</li><li>对于委托进行封装，从而定义add与remove方法</li><li>在add与remove中通过互锁的方式提供了线程安全性</li></ol><h1 id="Unity中的应用"><a href="#Unity中的应用" class="headerlink" title="Unity中的应用"></a>Unity中的应用</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（三）</title>
      <link href="/2024/03/06/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/03/06/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="人物属性"><a href="#人物属性" class="headerlink" title="人物属性"></a>人物属性</h1><h2 id="人物血条"><a href="#人物血条" class="headerlink" title="人物血条"></a>人物血条</h2><p>人物血条大致要有内容：</p><p><strong>血条GUI设计</strong></p><p><strong>角色属性脚本</strong>(血量健康、法力等)</p><p>首先要制作血条GUI的设计：</p><p>采取三层图层且挂钩于一个幕布容器下，通过一个父级幕布容器来管理三层图，从而来表达出血条(健康，受伤)状态</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306164603902.png" alt="image-20240306164603902"></p><p>其中要注意的内容主要有：</p><p>1、画布缩放器(Canvas Scaler)的内容修改</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170305037.png" alt="image-20240306170305037"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170209695.png" alt="image-20240306170209695"></p><p>2、GUI血条图层的细节</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170401374.png" alt="image-20240306170401374"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306173311469.png" alt="image-20240306173311469"></p><p>通过设置图片显示方式来实现接下来应该有的血量减少的效果</p><h2 id="设计脚本"><a href="#设计脚本" class="headerlink" title="设计脚本"></a>设计脚本</h2><p>针对人物血条这个功能，我们可以知道的是其至少要有三个对象内容：</p><ul><li><strong>造成伤害方（怪物&#x2F;其他）</strong></li><li><strong>玩家受伤（玩家属性）</strong></li><li><strong>血条变化（GUI）</strong></li></ul><p>基于此我们可以先定义好玩家的属性脚本(Character)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent&lt;PlayerCharacter&gt; playerHealth;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       maxHealth = <span class="number">100f</span>;</span><br><span class="line">       health = maxHealth;</span><br><span class="line">       playerHealth?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，玩家的属性发生变化的时候会对其他内容造成影响，通常来说我们可以直接通过事件的方式来让其他关联的脚本进行订阅，这样如果我们事件启用的时候也会对关联的脚本进行更改，但是这种方式需要在unity界面上进行绑定，这样还有一种缺点：当我们的场景进行切换（销毁Scene，切换另一个新的Scene），这样会导致我们绑定的容器也丢失，所以我们可以通过采取<code>ScriptableObject</code>来对委托进行数据存储：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Events/CharacterEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;PlayerCharacter&gt; action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEventRaised</span>(<span class="params">PlayerCharacter character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相当于注册完成了一个带有PlayerCharacter参数的事件</span></span><br><span class="line">        action?.Invoke(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成对应的资源文件后将其绑定到人物脚本的事件上，从而实现<strong>广播</strong>（通知订阅方）：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240311205154396.png" alt="image-20240311205154396"></p><p>紧接着我们就需要实现对广播的接收方进行设计，也就是添加订阅方&#x2F;修改订阅方脚本</p><p>在这里先以只对血量变化进行血条GUI显示的脚本内容进行更改，让其订阅事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CharacterEventSO healthEvent; <span class="comment">//需要进行绑定</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       healthEvent.action += OnHealthChange;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       healthEvent.action -= OnHealthChange;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//实现血条变化的更改</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params">PlayerCharacter character</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       redHealth.fillAmount = <span class="number">1</span> - character.health / character.maxHealth;</span><br><span class="line">       Debug.Log(redHealth.fillAmount);</span><br><span class="line">       greenHealth.fillAmount = character.health / character.maxHealth;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将其内容进行一一绑定后就完成了整体事件的流程</p><h1 id="怪物设置"><a href="#怪物设置" class="headerlink" title="怪物设置"></a>怪物设置</h1><p>描述：设置怪物，通过怪物的巡逻和对玩家的检测，当两者进行接触时会对玩家造成伤害，具体流程为：</p><ul><li>怪物检测玩家</li><li>怪物追逐玩家</li><li>怪物对玩家造成伤害</li><li>怪物回到原点</li></ul><p>设置怪物的动画与GUI，完成对应的动画绑定后通过脚本实现怪物的追击与动画切换，其中怪物的属性是一个脚本，怪物的控制是另外一个脚本，这样方便接下来为怪物增加一些对应的状态</p><p>定义怪物的属性内容，同时设定事件，通过事件来调用怪物的控制类相关组件，这样只要让其具有检测的功能，而实现功能让另外一个控制脚本进行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent&lt;Vector2&gt; moveToPlayer;</span><br><span class="line"><span class="keyword">public</span> Transform player;</span><br><span class="line"><span class="comment">//怪物攻击力</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> attack;</span><br><span class="line"><span class="comment">//检测范围(仇恨范围)</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> chaseDistance = <span class="number">4f</span>;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测玩家</span></span><br><span class="line">        <span class="built_in">float</span> distance = Vector2.Distance(player.position, transform.position);</span><br><span class="line">        <span class="keyword">if</span>(distance &lt; chaseDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//追击玩家</span></span><br><span class="line">            Vector2 dirction = player.position - transform.position;</span><br><span class="line">            <span class="comment">//移动方向(向量)传入</span></span><br><span class="line">            moveToPlayer?.Invoke(dirction.normalized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            moveToPlayer?.Invoke(Vector2.zero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.transform.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            doDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//怪物接触到玩家则会对其造成伤害</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDamage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player.GetComponent&lt;PlayerCharacter&gt;().hurtByEnemy(attack);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>怪物控制的脚本主要要实现怪物的移动、怪物动画的切换、怪物状态等具体内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params">Vector2 direction</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (direction.magnitude &gt; <span class="number">0</span> &amp;&amp; currentSpeed != <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//播放对应的动画</span></span><br><span class="line">         <span class="keyword">if</span> (direction != <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">             animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">if</span> (direction.x != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, direction.x);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (direction.y != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, direction.y);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//进行移动</span></span><br><span class="line">         rb.velocity = direction * currentSpeed;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         rb.velocity = Vector2.zero;</span><br><span class="line">         animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="comment">//玩家脱战时让其返回原点</span></span><br><span class="line">         <span class="built_in">float</span> distance = Vector2.Distance(currentPos, transform.position);</span><br><span class="line">         <span class="keyword">if</span>(distance &gt; <span class="number">0.1f</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Vector2 dir = currentPos - transform.position;</span><br><span class="line">             OnAnimatorMove(dir.normalized);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="更多机制"><a href="#更多机制" class="headerlink" title="更多机制"></a>更多机制</h2><p>怪物的巡逻也分为几种形式：</p><ul><li>固定地点出现，四周进行巡逻</li><li>固定地点出现，多个标记点来回巡逻</li></ul><p>怪物的状态也有几种形式：</p><ul><li><p>待机状态（巡逻状态）</p><ul><li>描述：最初状态（巡逻），速度为初始速度</li></ul></li><li><p>追击状态</p><ul><li>描述：追击玩家，具体效果可以自拟（比如怪物持续加速至攻击了一次停止）</li></ul></li><li><p>攻击状态（暂不实装）</p></li><li><p>受伤状态（暂不实装）</p></li><li><p>死亡状态（暂不实装）</p></li></ul><h3 id="怪物状态机"><a href="#怪物状态机" class="headerlink" title="怪物状态机"></a>怪物状态机</h3><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240315104840991.png" alt="image-20240315104840991"></p><p>OnUpdate()又称为<strong>逻辑更新</strong>，OnFixedUpdate()又称为<strong>物理更新</strong></p><p>这里叙述一下逻辑更新与物理更新的区别：</p><p>逻辑更新它会在<strong>每一帧都被调用一次</strong>，也就是说，根据电脑性能的不同，它被调用的次数也会不同，相当于每“帧”更新，如果电脑240帧，则逻辑更新的内容就会被执行240次</p><p>物理更新的调用频率是固定的，它本质上不受帧率影响。默认情况下，物理更新每秒被调用50次，它会更适合用来处理物理相关的代码内容</p><p>比如逻辑更新更适合于物体瞬间施加的力（跳跃），物理更新则更适合于持续性的物理模拟（比如流动的水）</p><p>要先定义一个状态机接口，以此来实现不同状态进行切换的基础</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span>;</span><br><span class="line">    <span class="comment">//逻辑更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span>;</span><br><span class="line">    <span class="comment">//固定更新(物理更新)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFixedUpdate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后一一定义不同的状态来实现该接口，同时要注意到怪物本身的类上定义好各个枚举变量，从而对怪物自身不同的状态类进行初始化处理，这里简单举例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敌人状态枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnemyStateType</span><br><span class="line">&#123;</span><br><span class="line">    Idle,Walk,Chase,Hurt,Die</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设定切换状态的方法，同时一般来说，如果怪物有其他属性或者其他数据进行通信，则还要在每个状态类里边定义对应的怪物脚本类属性，这样就能在调用状态切换的情况下把需要的数值传递进来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置字典键值对存取各个状态并初始化</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;EnemyStateType,BaseState&gt; states = <span class="keyword">new</span> Dictionary&lt;EnemyStateType,BaseState&gt;();</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">public</span> BaseState currentBaseState;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对每个状态进行初始化</span></span><br><span class="line">        states.Add(EnemyStateType.Idle, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Walk, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Chase, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Hurt, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Die, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始状态</span></span><br><span class="line">        TransitionState(EnemyStateType.Idle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransitionState</span>(<span class="params">EnemyStateType stateType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentBaseState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentBaseState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentBaseState = states[stateType];</span><br><span class="line">        currentBaseState.OnStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>若加入数据通信，则只需要改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyDie</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy enemy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnemyDie</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.enemy = enemy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在对应的初始化位置实装<code>states.Add(EnemyStateType.Idle, new EnemyIdle(this));</code>即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包系统开发</title>
      <link href="/2024/01/27/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
      <url>/2024/01/27/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="背包GUI设计"><a href="#背包GUI设计" class="headerlink" title="背包GUI设计"></a>背包GUI设计</h1><p>最终效果：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154046999.png" alt="image-20240131154046999"></p><p>一些实用内容：</p><p>1、取消按钮功能的实现 —— 直接绑定</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154238667.png" alt="image-20240131154238667"></p><p>2、背包格子的布局</p><p>最好创建一个子容器来对接下来各个格子进行排布，尤其是使用相关组件<code>Grid Layout Group</code></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154615845.png" alt="image-20240131154615845"></p><p>3、单个物品格子独立设置成一个预制体(<strong>Prefab</strong>)</p><h1 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h1><p>需要用到的核心父类<strong>ScriptableObject</strong></p><ul><li>定义物品类（基类）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Item&quot;</span>,menuName = <span class="string">&quot;Inventory/Item&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Item</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//物品名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> itemName;</span><br><span class="line">    <span class="comment">//物品贴图</span></span><br><span class="line">    <span class="keyword">public</span> Sprite itemImage;</span><br><span class="line">    <span class="comment">//物品数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> itemHeld;</span><br><span class="line">    <span class="comment">//物品描述</span></span><br><span class="line">    [<span class="meta">TextArea</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> itemInfo;</span><br><span class="line">    <span class="comment">//是否可以使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> canUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240219171049446.png" alt="image-20240219171049446"></p><p>自定义出对应的物品Item，后续的存储数据更改就会只针对对应物品下的物品数量属性(Item Held)进行加减</p><ul><li>定义背包类（基类）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Bag&quot;</span>, menuName = <span class="string">&quot;Inventory/Bag Inventory&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagScript</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Item&gt; bagList = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240219171537128.png" alt="image-20240219171537128"></p><p>背包最终存储的会是对应的物品类型，而不会造成同一物品堆叠，让物品数量在对应的物品内容上进行更改即可</p><h2 id="ScriptableObject进行数据存储-重要"><a href="#ScriptableObject进行数据存储-重要" class="headerlink" title="ScriptableObject进行数据存储(重要)"></a>ScriptableObject进行数据存储(重要)</h2><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202111507811.png" alt="image-20240202111507811"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202113637293.png" alt="image-20240202113637293"></p><p><code>CreateAssetMenuAttribute</code>作用：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202113707681.png" alt="image-20240202113707681"></p><h1 id="背包使用"><a href="#背包使用" class="headerlink" title="背包使用"></a>背包使用</h1><ul><li>打开背包</li></ul><p>玩家打开背包可以通过特定按键（”O”键举例）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openBag</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.O))</span><br><span class="line">       &#123;</span><br><span class="line">           isOpen = !isOpen;</span><br><span class="line">           bag.SetActive(isOpen);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>定义拾取脚本(ItemOnWorld)</li></ul><p>玩家捡起对应的物品时相关的一些逻辑内容</p><p>物品 → 背包 → 当前场景物品消失(隐藏)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//捡起的物品</span></span><br><span class="line">  <span class="keyword">public</span> Item thisItem;</span><br><span class="line">  <span class="comment">//绑定的背包(玩家的背包)</span></span><br><span class="line">  <span class="keyword">public</span> BagScript playerBag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(collision.transform.parent.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//将物品放入背包中</span></span><br><span class="line">          AddNewItem();</span><br><span class="line">          Destroy(gameObject);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加物品到背包中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNewItem</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(!playerBag.bagList.Contains(thisItem))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//数据存储层面</span></span><br><span class="line">          playerBag.bagList.Add(thisItem);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         thisItem.itemHeld++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//GUI层面</span></span><br><span class="line">      InventoryManager.instance.refreshItemsInBags();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>物品显示在背包中</p><ul><li><p>单个<strong>物品格子</strong>对应的脚本设计(Slot)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Item item;</span><br><span class="line"><span class="keyword">public</span> Image ItemImage;</span><br><span class="line"><span class="keyword">public</span> Text slotNum;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//点击物品时可以查看物品信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemOnClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InventoryManager.updateItemDescription(item.itemInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>背包数据与物品拾取数据处理的脚本设计（单例模式实现        InventoryManager）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InventoryManager instance;</span><br><span class="line"><span class="comment">//玩家背包</span></span><br><span class="line"><span class="keyword">public</span> BagScript playerBag;</span><br><span class="line"><span class="comment">//物品内容</span></span><br><span class="line"><span class="keyword">public</span> Slot slot;</span><br><span class="line"><span class="comment">//物品描述</span></span><br><span class="line"><span class="keyword">public</span> Text slotDescription;</span><br><span class="line"><span class="comment">//在背包GUI中对应的格子</span></span><br><span class="line"><span class="keyword">public</span> GameObject slotGrid;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123; </span><br><span class="line">        Destroy(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    refreshItemsInBags();</span><br><span class="line">    instance.slotDescription.text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//背包GUI上进行单一物品创建显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateNewItem</span>(<span class="params">Item item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在对应的列表容器位置创建一个新的物品</span></span><br><span class="line">    Slot newItem = Instantiate(instance.slot, instance.slotGrid.transform);</span><br><span class="line">    <span class="comment">//初始化物品信息(包括图片，内容介绍)</span></span><br><span class="line">    newItem.item = item;</span><br><span class="line">    newItem.ItemImage.sprite = item.itemImage;</span><br><span class="line">    newItem.slotNum.text = item.itemHeld.ToString();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//根据背包数据显示在背包GUI上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshItemsInBags</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先清空背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.slotGrid.transform.childCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.slotGrid.transform.childCount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        Destroy(instance.slotGrid.transform.GetChild(i).gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据背包数据在GUI上逐个创建</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.playerBag.bagList.Count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateNewItem(playerBag.bagList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateItemDescription</span>(<span class="params"><span class="built_in">string</span> itemDescription</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.slotDescription.text = itemDescription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在界面上也要对对应的属性先进行绑定</p></li></ul></li></ul><h1 id="附加：可拖拽背包"><a href="#附加：可拖拽背包" class="headerlink" title="附加：可拖拽背包"></a>附加：可拖拽背包</h1><p>描述：可以自由地将物品从原先的格子拖拽到不同的格子上去，实现背包中内容的拖拽</p><p>原先的背包设计是：</p><p>将物品单元格当做一个容器，若拾取了道具就会在Grid表单中创建对应的一个新的单元格，也就是只有 <strong>Grid → Grid下子单元</strong>(自身就包含物品内容)</p><p>拖拽背包的设计是：</p><p>在Grid表单中一次性创建多个物品单元格容器，物品单元格的内容可以往下一级，形成 <strong>Grid → Grid下子单元 → 子单元下物品内容</strong>，这样就可以实现不同单元格可以被交换</p><p><strong>一 、</strong>GUI的重新设计：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240227162144821.png" alt="image-20240227162144821"></p><p>其中Item就是当前物品内容的父组件(Button)，ItemSec相当于Grid下子单元，初始默认为空</p><p><strong>二、</strong>背包脚本的重新设计：</p><p>背包单元格Slot</p><p>修改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自身挂载的容器 —— 即背包下子单元格</span></span><br><span class="line">   <span class="keyword">public</span> GameObject itemInSlot;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//点击物品时可以查看物品信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemOnClick</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       InventoryManager.updateItemDescription(slotInfo);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//初始化每个GUI单元格的内容</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpItem</span>(<span class="params">Item item</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(item == <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           itemInSlot.SetActive(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       slotImage.sprite = item.itemImage;</span><br><span class="line">       slotNum.text = item.itemHeld.ToString();</span><br><span class="line">       slotInfo = item.itemInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>背包功能处理InventoryManager</p><p>修改后：不需要CreateNewItem内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据背包数据显示在背包GUI上</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshItemsInBags</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//先清空背包</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.slotGrid.transform.childCount;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (instance.slotGrid.transform.childCount == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           Destroy(instance.slotGrid.transform.GetChild(i).gameObject);</span><br><span class="line">           <span class="comment">//背包链表清空</span></span><br><span class="line">           instance.slots.Clear();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据背包数据在GUI上逐个创建</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.playerBag.bagList.Count;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//CreateNewItem(playerBag.bagList[i]);</span></span><br><span class="line">           instance.slots.Add(Instantiate(instance.emptySlot));</span><br><span class="line">           instance.slots[i].transform.SetParent(instance.slotGrid.transform);</span><br><span class="line">           <span class="comment">//将物品内容显示在单元格中</span></span><br><span class="line">           instance.slots[i].GetComponent&lt;Slot&gt;().setUpItem(instance.playerBag.bagList[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>拾取脚本ItemOnWorld</p><p>修改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加物品到背包中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNewItem</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!playerBag.bagList.Contains(thisItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//playerBag.bagList.Add(thisItem);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;playerBag.bagList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (playerBag.bagList[i]==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                playerBag.bagList[i] = thisItem;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       thisItem.itemHeld++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InventoryManager.instance.refreshItemsInBags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖拽内容"><a href="#拖拽内容" class="headerlink" title="拖拽内容"></a>拖拽内容</h2><p>描述：背包内容可以被拖拽</p><p>需要用到<code>EventSystems</code>库下的几个接口（<strong>IBeginDragHandler</strong>、<strong>IDragHandler</strong>、<strong>IEndDragHandler</strong>）来实现点击物品后让物品跟着(“黏住”)鼠标箭头移动</p><p>定义需要用到的脚本，绑定到物品容器(item)上，让其能够被拖拽</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录要拖拽物品的初始位置(当前位置)</span></span><br><span class="line"><span class="keyword">public</span> Transform originalPos;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    originalPos = transform.parent;</span><br><span class="line">    transform.SetParent(transform.parent.parent);</span><br><span class="line">    <span class="comment">//（跟随鼠标移动）  被点击的物品  →  鼠标点击位置</span></span><br><span class="line">    transform.position = eventData.position;</span><br><span class="line">    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SetDraggedPosition(eventData);</span><br><span class="line">    <span class="comment">//获取当前幕布组件下射线检测到的容器(内容)是什么</span></span><br><span class="line">    <span class="comment">//Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着实现在移动物品时能够检测到当前移动指向的格子的内容，为接下来的替换物品位置做准备，在这里采用的是通过<code>Canvas Group</code>幕布容器来实现</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240228142847283.png" alt="image-20240228142847283"></p><p>通过该容器的<strong>Block Raycasts</strong>射线来检测此时鼠标箭头(粘着)上物品移动的地点下方被射线穿透到的是哪个单元格</p><p>其中，Block Raycasts的属性可以勾选</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240229132819741.png" alt="image-20240229132819741"></p><p>该内容表示<strong>是否可以让射线穿透</strong>，若处于空则表示允许穿透，此时如果鼠标已经在拖拽物品，<strong>射线可以穿透该物品而检测到鼠标移动地方下是什么</strong>，若勾上√则表示不允许穿透，此时如果鼠标已经在拖拽物品，射线就不能穿透，只能一直检测到的都是鼠标正在拖拽的物品</p><p>所以通过在不同状态下(开始拖拽、拖拽进行时、结束拖拽)设置该值来实现拖拽物品与要到达的目的地进行检测，从而实现物品交换或填补空白单元格</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>最后填补上最后一个接口实现方法(结束拖拽状态 → 物品替换&#x2F;填补)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//鼠标指向的单元格存在物品的情况下</span></span><br><span class="line">    <span class="keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;Image&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GameObject targetSec = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.gameObject;</span></span><br><span class="line">        <span class="comment">//GameObject targetObj = eventData.pointerCurrentRaycast.gameObject.transform.parent.gameObject;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把鼠标抓着的物品放到要交换的当前物品格下</span></span><br><span class="line">        <span class="comment">//transform.SetParent(targetSec.transform);</span></span><br><span class="line">        <span class="comment">//transform.position = targetSec.transform.position;</span></span><br><span class="line">        transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);</span><br><span class="line">        transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把被交换的物品放到鼠标最初点击的物品位置下</span></span><br><span class="line">        <span class="comment">//targetObj.transform.SetParent(originalPos);</span></span><br><span class="line">        <span class="comment">//targetObj.transform.position = originalPos.position;</span></span><br><span class="line">        eventData.pointerCurrentRaycast.gameObject.transform.parent.transform.SetParent(originalPos);</span><br><span class="line">        eventData.pointerCurrentRaycast.gameObject.transform.parent.transform.position = originalPos.position;</span><br><span class="line">       </span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;ItemSec(Clone)&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不存在物品的情况下(空单元格)</span></span><br><span class="line">        transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);</span><br><span class="line">        transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.SetParent(originalPos);</span><br><span class="line">        transform.position = originalPos.position;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDraggedPosition</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rt = gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">    <span class="comment">// transform the screen point to world point int rectangle</span></span><br><span class="line">    Vector3 globalMousePos;</span><br><span class="line">    <span class="keyword">if</span> (RectTransformUtility.ScreenPointToWorldPointInRectangle(rt, eventData.position, eventData.pressEventCamera, <span class="keyword">out</span> globalMousePos))</span><br><span class="line">    &#123;</span><br><span class="line">        rt.position = globalMousePos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要优化以及可以改变的方式"><a href="#需要优化以及可以改变的方式" class="headerlink" title="需要优化以及可以改变的方式"></a>需要优化以及可以改变的方式</h2><ul><li><p>无法将背包中的物品拖拽放置在背包之外</p></li><li><p>无法将背包中的物品拖拽放置在两个单元格之间（已实现）</p></li><li><p>拖拽的物品放到另外一个物品使其弹出并”粘”在鼠标箭头上(MC)</p></li><li><p>背包GUI可以被拖拽（已实现）</p></li><li><p>背包数据在物品位置变换后，重新打开后要依旧是变换后的位置（已实现）</p></li><li><p>物品内容被拖出背包外，可以是物品掉落&#x2F;弹回原位(禁止背包外)</p></li></ul><h3 id="背包GUI界面可以被拖拽"><a href="#背包GUI界面可以被拖拽" class="headerlink" title="背包GUI界面可以被拖拽"></a>背包GUI界面可以被拖拽</h3><p>设计对应的背包拖拽脚本，通过<strong>IDragHandler</strong>接口来实现拖拽状态</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定背包GUI的坐标</span></span><br><span class="line">  <span class="comment">//public Transform bagGUI;</span></span><br><span class="line">  <span class="keyword">public</span> RectTransform bagGUI;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      bagGUI = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">      <span class="comment">//bagGUI = GetComponent&lt;Transform&gt;();</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      bagGUI.anchoredPosition += eventData.delta;</span><br><span class="line">      <span class="comment">//bagGUI.position = eventData.position;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于背包GUI自身是最大的父级容器，同时GUI画面较大，直接通过鼠标拖拽时会使得鼠标也一直在GUI画面的中心位置进行，为了使得效果更加好，通过直接获得<code>RectTransform</code>组件来进行移动，其中<code>RectTransform</code>提供了:</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301161645344.png" alt="image-20240301161645344"></p><p>当前中心位置加上鼠标对应的位置即是背包GUI移动的位置，其中采用了<code>PointerEventData</code>点击事件中的delta方法快速获取鼠标坐标</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301155833328.png" alt="image-20240301155833328"></p><h3 id="背包数据优化-数据同化"><a href="#背包数据优化-数据同化" class="headerlink" title="背包数据优化(数据同化)"></a>背包数据优化(数据同化)</h3><p>当玩家对背包物品进行过拖拽操作，并且改变了原来物品所在的位置时，当玩家重新打开背包或者拾取新的物品时，原先物品发生变化情况下位置要不变（比如进行物品拖拽后，A物品在第二行第三个，再次打开背包或者拾取新物品时，背包数据同步后，A物品依旧在第二行第三个）</p><p>脚本修改分析：</p><p><strong>背包</strong>(最高级父级)绑定的是背包整体处理，涉及的有GUI以及背包数据同步  —— InventoryManager</p><p><strong>单元格</strong>(父级)向上是对背包负责，向下是对物品内容(Item)负责，涉及的有物品内容GUI的展示 —— Slot</p><p><strong>物品内容</strong>(子级)向上是对单元格负责，自身就是最低级，涉及的是自身内容，无展示，同时能够执行拖拽功能 —— ItemOnDrag</p><p>思路：</p><p>背包脚本中具有<strong>链表</strong>属性，该属性的子节点对应每个单元格(Slot)，而单元格下又都一一对应一物品内容(Item)，所以背包中的链表每一个<strong>序号</strong>都可以来表示单元格的序号，<strong>单元格的序号又可以作为物品的序号</strong>，只要通过定义序号，当物品内容进行了拖拽，通过物品内容(Item)自身挂载的脚本，实现的过程中再完成对链表中物品的替换即可(List[A] ,List[B], T)</p><p>单元格脚本的修改：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192633792.png" alt="image-20240301192633792"></p><p>背包数据脚本的修改：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192721771.png" alt="image-20240301192721771"></p><p>物品内容拖拽脚本的增添：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192912288.png" alt="image-20240301192912288"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192822520.png" alt="image-20240301192822520"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240302123009763.png" alt="image-20240302123009763"></p><h3 id="拖拽物品闪烁问题的解决"><a href="#拖拽物品闪烁问题的解决" class="headerlink" title="拖拽物品闪烁问题的解决"></a>拖拽物品闪烁问题的解决</h3><p>该问题主要是因为物品在拥有<code>Grid</code>组件的容器下，而拖拽的时候物品是独立出来的，再接进去的话由于Grid的规则，要先按Grid的排序，所以会过渡到n+1行下，导致闪烁的发生</p><p>解决方式：</p><p>在物品内容容器下添加一个可以忽略<code>Grid</code>规则的组件，启用忽略Grid规则即可</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301195631952.png" alt="image-20240301195631952"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/13/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%9A%BE%E9%A2%98/"/>
      <url>/2024/01/13/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="同种交互物品不同交互内容"><a href="#同种交互物品不同交互内容" class="headerlink" title="同种交互物品不同交互内容"></a>同种交互物品不同交互内容</h1><p>描述：开发途中需要用到两个交互物体，一个物体要实现玩家交互后进行传送，另外一个物体要实现玩家开启后启用其他被隐藏起来的物品</p><p>定义交互的接口<code>IInteractive</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInteractive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">achieveEvent</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>交互物体1</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//传送到达的地点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Vector2 endPos;</span><br><span class="line">   <span class="comment">//传送的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> GameObject player;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//将玩家传送到指定目标点</span></span><br><span class="line">       player.transform.position = endPos;</span><br><span class="line">       <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 激活 obj</span></span><br><span class="line">           obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//点亮柱子</span></span><br><span class="line">           StartCoroutine(changeGlow());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>交互物体2</p></li></ul><p>​   实现挑战的开启</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject challenge;</span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//开启收集物</span></span><br><span class="line">       Debug.Log(<span class="string">&quot;开启收集挑战&quot;</span>);</span><br><span class="line">       challenge.GetComponent&lt;StartChallenge&gt;().getAllCollections();</span><br><span class="line">       <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 激活 obj</span></span><br><span class="line">           obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//点亮柱子</span></span><br><span class="line">           StartCoroutine(changeGlow());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>玩家要绑定的交互脚本要实现同个交互内容但是对应当前被交互的交互物体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//交互的物体</span></span><br><span class="line">  <span class="keyword">public</span> Collider2D coll;</span><br><span class="line"><span class="keyword">private</span> IInteractive currentInteractiveItem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//交互</span></span><br><span class="line">          <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E)&amp;&amp;currentInteractiveItem != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              currentInteractiveItem.achieveEvent();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      coll = collision;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (canPress)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//初始化交互物体</span></span><br><span class="line">              IInteractive interactiveItem = coll.GetComponent&lt;IInteractive&gt;();</span><br><span class="line">              currentInteractiveItem = interactiveItem;</span><br><span class="line">          &#125;</span><br><span class="line">          StartCoroutine(waitForSecondOpen());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>通过接口设定同种交互物体需要实现的方法，对方法进行重载，然后通过角色身上的交互检测对应的方法，设置一个该接口的属性，然后通过接口的属性来赋值，获取要交互的物体对应的方法，这样就实现了同种交互物品，当玩家靠近并调用时能够完成其不同的交互内容</p><p>​    </p><h1 id="背包拖拽问题"><a href="#背包拖拽问题" class="headerlink" title="背包拖拽问题"></a>背包拖拽问题</h1><p>背包拖拽通过采用<strong>MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler</strong>三个接口来进行，在实现接口方式时，由于世界坐标系的问题，可能会导致数值特别大（疑似PointerEventData eventData获取的是世界坐标），原先的方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      transform.position = eventData.position;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这在实际游戏体验时候会发现当你鼠标点击物品后，还没拖拽，该物品就已经飞出你的视野之外了</p><p>修改办法可以是通过<code>ScreenPointToWorldPointInRectangle</code>方法来解决，将屏幕坐标与世界坐标进行转换，修改后的方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetDraggedPosition(eventData);</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDraggedPosition</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rt = gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        <span class="comment">// transform the screen point to world point int rectangle</span></span><br><span class="line">        Vector3 globalMousePos;</span><br><span class="line">        <span class="keyword">if</span> (RectTransformUtility.ScreenPointToWorldPointInRectangle(rt, eventData.position, eventData.pressEventCamera, <span class="keyword">out</span> globalMousePos))</span><br><span class="line">        &#123;</span><br><span class="line">            rt.position = globalMousePos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="2D-x2F-3D鼠标检测"><a href="#2D-x2F-3D鼠标检测" class="headerlink" title="2D&#x2F;3D鼠标检测"></a>2D&#x2F;3D鼠标检测</h1><p>参考：<a href="https://www.bilibili.com/video/BV1pa4y157Qo">https://www.bilibili.com/video/BV1pa4y157Qo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（二）</title>
      <link href="/2023/12/10/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/10/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系列挑战"><a href="#系列挑战" class="headerlink" title="系列挑战"></a>系列挑战</h1><p>描述：角色触发挑战后在指定位置刷新几个挑战点位，玩家要到达这些点位开启挑战任务，完成挑战任务后开启门扉</p><h2 id="收集挑战"><a href="#收集挑战" class="headerlink" title="收集挑战"></a>收集挑战</h2><p>描述：角色在指定位置开启挑战，开启后会在地图随机刷取收集物，角色收集完成收集物后回来完成收集目标</p><p>收集挑战的流程大致为：</p><ul><li><p>开启挑战</p><ul><li><p>无时间限制</p></li><li><p>有时间限制</p></li></ul></li><li><p>生成收集物</p><ul><li>生成方式</li></ul></li><li><p>寻找收集物</p></li><li><p>返回提交 (需要背包系统)</p></li></ul><p>收集物的刷新方式可以有</p><p>1）随机位置生成物品</p><p>2）指定位置生成物品（单点位，连续路径）</p><p>3）固定位置重复生成</p><h3 id="生成收集物"><a href="#生成收集物" class="headerlink" title="生成收集物"></a>生成收集物</h3><p>根据玩法不同，可以设置多种不同的收集物生成方式，这里举例三种方式：</p><p>1.随机位置生成</p><p>2.指定位置生成</p><p>3.固定位置重复生成</p><p>其中，随机位置生成类似星露谷的采集品，像一些野菜等随机生成在指定范围或者区域内</p><p>指定位置生成则比较普遍，比如一些固定点位必有的任务物品等</p><p>固定位置重复生成则类似传奇这种玄幻类游戏中采集草药等</p><p>开启挑战的石柱对应绑定的脚本内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要绑定的收集物统一父组件   </span></span><br><span class="line"><span class="keyword">public</span> GameObject challenge;  </span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//开启收集物</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;开启收集挑战&quot;</span>);</span><br><span class="line">        challenge.GetComponent&lt;StartChallenge&gt;().getAllCollections();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 激活 obj</span></span><br><span class="line">            obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//点亮柱子</span></span><br><span class="line">            StartCoroutine(changeGlow());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="随机位置生成"><a href="#随机位置生成" class="headerlink" title="随机位置生成"></a>随机位置生成</h4><h4 id="指定位置生成"><a href="#指定位置生成" class="headerlink" title="指定位置生成"></a>指定位置生成</h4><p>描述：通过<strong>指定坐标</strong>位置地方生成对应收集品</p><p>收集物统一的父组件绑定对应的生成收集物脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;GameObject&gt; collectionList;</span><br><span class="line">   <span class="keyword">public</span> GameObject col1;</span><br><span class="line">   <span class="keyword">public</span> GameObject col2;</span><br><span class="line">   <span class="keyword">public</span> GameObject col3;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       collectionList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">       collectionList.Add(col1);</span><br><span class="line">       collectionList.Add(col2);</span><br><span class="line">       collectionList.Add(col3);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//生成收集物</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllCollections</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; collectionList.Count; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           collectionList[i].SetActive(<span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240113203747997.png" alt="image-20240113203747997"></p><h4 id="固定位置重复生成"><a href="#固定位置重复生成" class="headerlink" title="固定位置重复生成"></a>固定位置重复生成</h4><h3 id="获取收集物-无背包系统版本"><a href="#获取收集物-无背包系统版本" class="headerlink" title="获取收集物(无背包系统版本)"></a>获取收集物(无背包系统版本)</h3><p>描述：玩家到达收集物位置时按下“F”键进行拾取，收集物会被收集得到，原先的收集物继续被隐藏（<strong>前提：加了时间限制，考虑到没在时间内收集齐导致挑战失败，所以不能直接销毁</strong>）</p><p>玩家身上的交互组件进行修改，添加对获取收集物的记录，同时隐藏收集物即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录收集物品的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> collNum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment"><span class="doctag">///</span>TOOD：交互部分</span></span><br><span class="line">          <span class="comment">//柱子功能交互</span></span><br><span class="line">     </span><br><span class="line">          ...</span><br><span class="line">              </span><br><span class="line">          <span class="comment">//收集物交互</span></span><br><span class="line">          <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.F) &amp;&amp; coll.CompareTag(<span class="string">&quot;Collection&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              collNum++;</span><br><span class="line">              coll.GameObject().SetActive(<span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该功能还可以继续提高上限 ———— <strong>制作背包系统和任务系统(待定)</strong></p><p>背包系统(已实现)</p><p>任务系统(搁置)</p><p>通过拾取收集物，将收集物放入背包，最后玩家再到挑战任务要提交的地方进行提交（此时也要把已经获得的对应收集物进行销毁）</p><h3 id="获取收集物-背包系统"><a href="#获取收集物-背包系统" class="headerlink" title="获取收集物(背包系统)"></a>获取收集物(背包系统)</h3><p>将收集物绑定到数据容器(ScriptableObject)下即可，接下去的背包系统整体内容开发详见<code>背包系统开发</code>页</p><h3 id="提交物品-待定"><a href="#提交物品-待定" class="headerlink" title="提交物品(待定)"></a>提交物品(待定)</h3><p>描述：将物品提交到指定位置 or 提交给指定npc(前置：任务系统)</p><h2 id="时间竞赛"><a href="#时间竞赛" class="headerlink" title="时间竞赛"></a>时间竞赛</h2><p>描述：角色在限定时间内到达指定目标位置，超过时间限制则挑战失败并返回到起点</p><p>时间竞赛的流程大致为：</p><ul><li>开启挑战<ul><li>启动倒计时(显示GUI)</li><li>标出目标地点</li></ul></li><li>目标设置<ul><li>到达目标</li><li>未在指定位置到达<ul><li>返回起点</li></ul></li></ul></li><li>关闭倒计时(完成该挑战)</li></ul><h3 id="开启挑战"><a href="#开启挑战" class="headerlink" title="开启挑战"></a>开启挑战</h3><p>首先要设计好对应的时间条模板GUI，在这里设计成分和秒一同计时的方式</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240304215045034.png" alt="image-20240304215045034"></p><p>通过设置分钟的文本和秒的文本来表示数字，方便后续脚本内容的管理</p><p>定义的字段大致有：</p><table><thead><tr><th>属性</th><th>类型</th></tr></thead><tbody><tr><td>总计数</td><td>float</td></tr><tr><td>分钟</td><td>float</td></tr><tr><td>秒</td><td>float</td></tr><tr><td>分钟</td><td>Text</td></tr><tr><td>秒</td><td>Text</td></tr><tr><td>初始坐标</td><td>Vector2</td></tr><tr><td>目标地点</td><td>GameObject</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交互内容：开启时间计时</span></span><br><span class="line">        <span class="keyword">if</span>(isCount)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCount -= Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分钟和秒数</span></span><br><span class="line">            minuteForCount = Mathf.FloorToInt(timeCount / <span class="number">60</span>);</span><br><span class="line">            secForCount = Mathf.FloorToInt(timeCount % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">            minText.text = minuteForCount.ToString();</span><br><span class="line">            secText.text = secForCount.ToString();</span><br><span class="line">            <span class="keyword">if</span> (timeCount &lt;= <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计时器到达零，执行失败操作</span></span><br><span class="line">                isCount = <span class="literal">false</span>;</span><br><span class="line">                timeCanvas.enabled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还要标出目的地点，可以通过绑定容器的方式来进行启用，失败时则关闭（gameObject.SetActive(true&#x2F;false)）</p><p>实现交互接口的内容，方便玩家绑定的脚本进行交互</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       startCount();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCount</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">//重新挑战初始化倒计时    </span></span><br><span class="line">       timeCount = <span class="number">100f</span>;</span><br><span class="line">       currentPos = character.transform.position;</span><br><span class="line">       <span class="comment">//开启目标点</span></span><br><span class="line">       targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">       IsCount = <span class="literal">true</span>;</span><br><span class="line">       timeCanvas.enabled = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="挑战结果"><a href="#挑战结果" class="headerlink" title="挑战结果"></a>挑战结果</h3><p><strong>若成功：</strong>完成挑战，可以给予奖励或者出现一个宝箱</p><ul><li>给予奖励（前置：背包系统(√)）</li><li>出现宝箱（前置：宝箱界面(类似背包)）（未实现）</li></ul><p>流程为</p><p><strong>玩家到达目的地 → 倒计时板关闭 → 生成挑战结果</strong>(待定)</p><p>要先在目标点设置可以检测的内容(GUI内容实现)，为其定义一个脚本，方便在该位置来取消倒计时板关闭以及完成后续其他奖励内容操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(collision.transform.parent.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(<span class="string">&quot;玩家已到达&quot;</span>);</span><br><span class="line">           countObj.GetComponent&lt;Stone3UI&gt;().IsCount = <span class="literal">false</span>;</span><br><span class="line">           targetCanvas.enabled = <span class="literal">false</span>;</span><br><span class="line">           Destroy(transform.gameObject);</span><br><span class="line">           <span class="meta">#奖励内容(待定)#</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>若失败：</strong>没有在规定时间内完成，返回起点，可以选择重新开始</p><p>原先的时间挑战开启的脚本要进行一定的修改，要添加能够绑定玩家初始位置的属性，同时还要在每次开启挑战时候初始化倒计时的时间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录玩家初始位置</span></span><br><span class="line"><span class="keyword">private</span> Vector2 currentPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(IsCount)</span><br><span class="line">      &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (timeCount &lt;= <span class="number">0.0f</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 计时器到达零，执行失败操作</span></span><br><span class="line">              ...</span><br><span class="line">              <span class="comment">//把玩家返回到起点</span></span><br><span class="line">              character.transform.position = currentPos;</span><br><span class="line">              <span class="comment">//关闭目标点</span></span><br><span class="line">              targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCount</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      timeCount = <span class="number">100f</span>;</span><br><span class="line">    <span class="comment">//记录玩家起始位置</span></span><br><span class="line">      currentPos = character.transform.position;</span><br><span class="line">      <span class="comment">//开启目标点</span></span><br><span class="line">      targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="补充-多个时间挑战"><a href="#补充-多个时间挑战" class="headerlink" title="补充:多个时间挑战"></a>补充:多个时间挑战</h3><p>描述：若该场景下有多个时间挑战的柱子，不同柱子相同挑战但是最终的目的地不同</p><p>首先要定义好各个时间挑战的倒计时时间，同时在开启挑战的时候赋值给初始化的总计时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前柱子设置的挑战时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> currentTime;</span><br></pre></td></tr></table></figure><p>另外一个是要定义好新的目的地(预制体&#x2F;新容器)，让其脚本绑定对应挂钩的时间挑战的柱子即可</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240305211900320.png" alt="image-20240305211900320"></p><h2 id="细节调整"><a href="#细节调整" class="headerlink" title="细节调整"></a>细节调整</h2><p>1、时间竞赛中，如果玩家到达目标点，目标点应该顺便销毁</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(collision.transform.parent.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           ...</span><br><span class="line">           Destroy(transform.gameObject);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2、系列挑战若为一次性挑战，则要考虑到当玩家完成该挑战时，该挑战不再可以被互动</p><p>方法：由于玩家与不同挑战的交互主要是通过该挑战容器对应的<code>Tag</code>来进行检测是否可以互动，所以只要在挑战结束后对其<code>Tag</code>进行更改即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameObject.tag = <span class="string">&quot;XXX&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="任务触发-准备ing-▲"><a href="#任务触发-准备ing-▲" class="headerlink" title="任务触发(准备ing)▲"></a>任务触发(准备ing)▲</h1><p>描述：角色在指定位置进行交互，触发要进行的任务，任务可以有多个，完成几个任务后完成解锁条，解锁条达成后开启门扉，可以进入下一关</p><h1 id="额外：多个一样的挑战内容-脚本能力"><a href="#额外：多个一样的挑战内容-脚本能力" class="headerlink" title="额外：多个一样的挑战内容(脚本能力)"></a>额外：多个一样的挑战内容(脚本能力)</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（一）</title>
      <link href="/2023/12/03/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/12/03/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="俯视视角下人物的移动"><a href="#俯视视角下人物的移动" class="headerlink" title="俯视视角下人物的移动"></a>俯视视角下人物的移动</h1><p>在2D俯视视角进行游戏创作，人物的移动应该要根据玩家操控的上下左右进而完成动画的变更与移动的实现</p><p>首先是动画的切换：</p><p>动画主要可以采取树(Bland Tree)的方式，通过设置x轴和y轴的数值(float或int类型)，由两种数值进行动画的切换</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231204110032376.png" alt="image-20231204110032376"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231204105941308.png" alt="image-20231204105941308"></p><p>其次是运动的实现：</p><p>运动的实现需要有几个步骤</p><ul><li>获取键盘输入</li><li>数值传递切换移动方向</li><li>移动方向施加力</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取横轴</span></span><br><span class="line">    <span class="built_in">float</span> PosX = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="comment">//获取纵轴</span></span><br><span class="line">    <span class="built_in">float</span> PosY = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    <span class="comment">//动画切换</span></span><br><span class="line">    <span class="keyword">if</span>(PosX != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, PosX);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PosY != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, PosY);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动方向归一化(-1 0 1)</span></span><br><span class="line">    Vector2 dir = <span class="keyword">new</span> Vector2(PosX, PosY).normalized;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//Move(dir);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (dir.x != <span class="number">0</span> &amp;&amp; dir.y != <span class="number">0</span>) rb.velocity = dir * <span class="number">0.25f</span>;</span><br><span class="line">    <span class="keyword">else</span> rb.velocity = dir * <span class="number">0.3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中通过<code>Input.GetAxisRaw</code>来获取键盘的输入：</p><p><img src="/./../../../typora-images/image-20231204111356029-1701675525882-4.png" alt="image-20231204111356029"></p><p>另外一种移动方式也可以通过采用**rb.velocity &#x3D; new Vector2(dir.x * speed * Time.deltaTime, 0)**来实现</p><p>这样就完成了俯视视角下人物的移动</p><h2 id="人物的物理检测"><a href="#人物的物理检测" class="headerlink" title="人物的物理检测"></a>人物的物理检测</h2><p>人物的移动在遇到障碍物或地图场景边缘受到阻碍，从而无法跨越</p><ul><li><strong>人物添加碰撞体</strong></li></ul><p>碰撞体添加后，还有细节要进行处理，在人物的刚体组件中，要锁定Z轴让其不变，否则会发生碰撞的时候人物Z轴发生变化而导致旋转</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231205103440059.png" alt="image-20231205103440059"></p><ul><li><strong>人物检测碰撞物体</strong></li></ul><p>通过<code>Physics2D.OverlapXX</code>检查碰撞体是否在XX区域内</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     isHit = Physics2D.OverlapCircle(transform.position,<span class="number">0.2f</span>,layer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231205141314868.png" alt="image-20231205141314868"></p><p>同时可以采用<code>Gizmos.DrawXX</code>方式来可视化检测的范围</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position+bottomOffset, <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="角色穿树透明化"><a href="#角色穿树透明化" class="headerlink" title="角色穿树透明化"></a>角色穿树透明化</h1><p>描述：人物经过树时，树会遮挡人物，但要让树半透明化，使人物能够被看到</p><p>角色穿树主要有几个步骤：</p><ul><li><p>图层覆盖</p></li><li><p>树检测人物</p></li><li><p>更改树贴图</p><ul><li>树上层</li><li>树下层</li></ul></li></ul><p>碰撞体与碰撞体之间的相互接触通过<code>OnTriggerEnter2D</code>来实现检测</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231206110513710.png" alt="image-20231206110513710"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件下所有子组件对应的贴图组件</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;SpriteRenderer&gt; trees = <span class="keyword">new</span> List&lt;SpriteRenderer&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     </span><br><span class="line">     trees.Add(transform.GetChild(<span class="number">0</span>).GetComponent&lt;SpriteRenderer&gt;());</span><br><span class="line">     trees.Add(transform.GetChild(<span class="number">1</span>).GetComponent&lt;SpriteRenderer&gt;());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//Debug.Log(LayerMask.LayerToName(collision.gameObject.layer));</span></span><br><span class="line">     <span class="keyword">if</span>(LayerMask.LayerToName(collision.gameObject.layer) == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">         changeTransparency(trees);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (LayerMask.LayerToName(collision.gameObject.layer) == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">         reverseTransparency(trees);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//树叶透明化</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeTransparency</span>(<span class="params">List&lt;SpriteRenderer&gt; sprite</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;sprite.Count;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         sprite[i].color = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5f</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseTransparency</span>(<span class="params">List&lt;SpriteRenderer&gt; sprite</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sprite.Count; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         sprite[i].color = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>树叶的透明化通过贴图颜色的更改即可实现，除了三元色之外，A对应的数值就是调整透明度</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231206110824400.png" alt="image-20231206110824400"></p><h1 id="传送石进行传送▲"><a href="#传送石进行传送▲" class="headerlink" title="传送石进行传送▲"></a>传送石进行传送▲</h1><p>描述：角色在指定传送石位置时弹出交互按键，玩家按下对应的按键后会传送到达指定位置</p><h2 id="触发交互按钮"><a href="#触发交互按钮" class="headerlink" title="触发交互按钮"></a>触发交互按钮</h2><p>交互按钮的图片材质可以选择挂载到角色身上，然后为其他需要进行交互的物体设置好对应的<strong>Tag</strong>标签，可以方便后续直接启用角色身上的交互</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子物体</span></span><br><span class="line"> <span class="keyword">public</span> GameObject obj;</span><br><span class="line"> <span class="comment">//子物体身上的动画</span></span><br><span class="line"> <span class="keyword">public</span> Animator animator;</span><br><span class="line"> <span class="comment">//是否开启子物体</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">bool</span> canPress;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">     canPress = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     obj.SetActive(canPress);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         canPress = <span class="literal">true</span>;</span><br><span class="line">         obj.SetActive(canPress);</span><br><span class="line">         animator.Play(<span class="string">&quot;StoneUI&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         canPress = <span class="literal">false</span>;</span><br><span class="line">         obj.SetActive(canPress);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过<code>CompareTag</code>方法来判断接触的物体是否具有对应的Tag标签</p><h2 id="按钮监听与交互的实现"><a href="#按钮监听与交互的实现" class="headerlink" title="按钮监听与交互的实现"></a>按钮监听与交互的实现</h2><p>当角色到达交互物品位置并按下按键，通过不同的交互物品来执行不同的交互事件，可以定义需要的接口，然后不同交互物品再实现不同的交互内容</p><p>通过事件的方式来进行不同物体接触后的交互，设置广播方和接收方，当广播方触及条件可以启动事件，在对事件进行绑定后，可以使得事件开启后执行被接触物体对应的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//传送交互</span></span><br><span class="line">          <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E))</span><br><span class="line">          &#123;</span><br><span class="line">              other?.Invoke();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传送到达的地点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Vector2 endPos;</span><br><span class="line"> <span class="comment">//传送的对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> GameObject player;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     endPos = <span class="keyword">new</span> Vector2(<span class="number">-4</span>, <span class="number">11</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.transform.parent != <span class="literal">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//获取交互物体的父物体</span></span><br><span class="line">         player = collision.transform.parent.gameObject;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//实现交互功能</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     Debug.Log(endPos);</span><br><span class="line">     <span class="comment">//将玩家传送到指定目标点</span></span><br><span class="line">     player.transform.position = endPos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过<code>collision.transform.parent</code>来获取当前物体身上的父物体</p><p><strong>PS：</strong>如果要实现多个传送柱子都有相同的方法，则可以设置为单例模式，从而使得不同的预制体要调用自己的内容时保持单一，而不会造成在另外一个物体上调用导致结果为null</p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><h3 id="柱子遮挡问题"><a href="#柱子遮挡问题" class="headerlink" title="柱子遮挡问题"></a>柱子遮挡问题</h3><p>在角色到达传送石柱时，由于俯视2D的特性，角色可以处于柱子四周位置，而此时要做到</p><ul><li>当角色在传送石柱上边时，柱子遮挡角色</li><li>当角色在传送石柱下边时，角色遮挡柱子</li></ul><p>通过人物坐标与柱子坐标的Y轴变化来切换柱子图层(Sorting in Layer)，进而修复该问题</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231208164057454.png" alt="image-20231208164057454"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(character.playerPos.y - transform.position.y &gt;= <span class="number">0</span> ) </span><br><span class="line">        &#123;</span><br><span class="line">            sprite.sortingLayerName = <span class="string">&quot;StoneBack&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            sprite.sortingLayerName = <span class="string">&quot;StoneFront&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判定互动的调整"><a href="#判定互动的调整" class="headerlink" title="判定互动的调整"></a>判定互动的调整</h3><p>问题：</p><p>触发互动的方式主要是通过交互组件上的碰撞体与互动物品的碰撞体之间通过<code>Trigger</code>方式来判断的，这样会由于角色身上的交互组件碰撞体面积过长或者过宽，从而导致<strong>角色在交互物品下方一定距离就已经能够触发交互</strong>，所以最好是进行对判定互动的处理</p><p>碰撞体可以调整的数据主要有：</p><ul><li>Offset（偏移量）</li><li>Size（大小）</li></ul><p>基于此可以通过某个判定条件来调整碰撞体的整体框架，从而减少误差，让游戏互动符合实际要求，比如只有人物靠近交互物体才会触发互动</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">          </span><br><span class="line">      <span class="comment">//到达要互动的物品时，调整碰撞体大小和偏移量</span></span><br><span class="line">      <span class="keyword">if</span>(coll!=<span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (canPress)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//人物在互动物品之下时</span></span><br><span class="line">              <span class="keyword">if</span>(coll.transform.position.y &gt; transform.position.y)</span><br><span class="line">              &#123;</span><br><span class="line">                  box.offset = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">                  box.size = <span class="keyword">new</span> Vector2(<span class="number">0.13f</span>, <span class="number">0.17f</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      coll = collision;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">true</span>;</span><br><span class="line">          StartCoroutine(waitForSecondOpen());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开启互动时的携程</span></span><br><span class="line">  <span class="function">IEnumerator <span class="title">waitForSecondOpen</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line">      obj.SetActive(canPress);</span><br><span class="line">      animator.Play(<span class="string">&quot;StoneUI&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">false</span>;</span><br><span class="line">          obj.SetActive(canPress);</span><br><span class="line">      &#125;</span><br><span class="line">      StartCoroutine(waitForSecondClose());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭互动时的携程</span></span><br><span class="line">  <span class="function">IEnumerator <span class="title">waitForSecondClose</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line">      box.offset = collOffset;</span><br><span class="line">      box.size = collSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过携程的方式设定延迟，避免在交互物品下某个位置时导致物体由于一直在原框架和修改框架来回切换从而让交互按钮一直处于显示状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity脚本</title>
      <link href="/2023/11/13/unity%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/11/13/unity%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="2D应用"><a href="#2D应用" class="headerlink" title="2D应用"></a>2D应用</h1><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><p>对象生成</p><ul><li>GameObject.Instantiate ： 单个对象生成</li></ul><p>  参数构成：</p><table><thead><tr><th>original</th><th>要复制的现有对象。</th></tr></thead><tbody><tr><td>position</td><td>新对象的位置。</td></tr><tr><td>rotation</td><td>新对象的方向。</td></tr><tr><td>parent</td><td>将指定给新对象的父对象。</td></tr><tr><td>instantiateInWorldSpace</td><td>When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.</td></tr></tbody></table><h2 id="脚本API相关"><a href="#脚本API相关" class="headerlink" title="脚本API相关"></a>脚本API相关</h2><h3 id="InvokeRepeating"><a href="#InvokeRepeating" class="headerlink" title="InvokeRepeating"></a>InvokeRepeating</h3><p>方法循环调用 —— <strong>InvokeRepeating</strong></p><p>public void <strong>InvokeRepeating</strong> (string <strong>methodName</strong>, float <strong>time</strong>, float <strong>repeatRate</strong>);</p><p>描述：</p><p>在 <code>time</code> 秒后调用 <code>methodName</code> 方法，然后每 <code>repeatRate</code> 秒调用一次。</p><h3 id="OnMouseDown"><a href="#OnMouseDown" class="headerlink" title="OnMouseDown"></a>OnMouseDown</h3><p>鼠标点击事件 —— <strong>OnMouseDown</strong></p><h3 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h3><p>位移方法 —— <strong>Translate</strong></p><p>参数：</p><ul><li>plane  ———— 平移后的平面</li><li><strong>translation</strong> ———— 在空间中用于移动平面的偏移</li></ul><p>描述：</p><p>在空间中按 <code>translation</code> 矢量移动平面</p><h3 id="Camera-main-ScreenToWorldPoint"><a href="#Camera-main-ScreenToWorldPoint" class="headerlink" title="Camera.main.ScreenToWorldPoint"></a>Camera.main.ScreenToWorldPoint</h3><p>描述：</p><p>将点从屏幕空间变换为世界空间。其中，世界空间定义为位于游戏层级视图最顶层的坐标系统。</p><p>即使以离屏坐标的形式提供时，仍可计算世界空间坐标，例如，用于实例化靠近屏幕特定角的离屏对象。</p><p>屏幕空间以像素定义。屏幕的左下角为 (0,0)，右上角 为 (<a href="https://docs.unity3d.com/cn/current/ScriptReference/Camera-pixelWidth.html">pixelWidth</a>,<a href="https://docs.unity3d.com/cn/current/ScriptReference/Camera-pixelHeight.html">pixelHeight</a>)。z 位置为与摄像机的距离，采用世界单位。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 sunNum = Camera.main.ScreenToWorldPoint(UIManager.Instance.GetSunNumTextPos());</span><br></pre></td></tr></table></figure><p>该语句主要对应了幕布的模式，<strong>为了获取UI界面上对应位置的坐标并符合在游戏画面上，进行精确的转换</strong>，由于UI和游戏画面实际上在#Scene界面上相距很远，所以如果要在游戏实现某种动画或者某种效果移动到UI或者涉及到UI界面，此时就要根据我们幕布选择的OverLay模式来进行处理</p><p>PS：</p><p>如果将幕布的模式切换为Camera模式，则可以不用添加该代码进行转换，通过摄像机圈定范围，然后直接赋值即可</p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><ul><li>Color.Lerp</li></ul><p>public static <a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>Lerp</strong> (<a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>a</strong>, <a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>b</strong>, float <strong>t</strong>);</p><p>概述：在颜色 <code>a</code> 与 <code>b</code> 之间按 <code>t</code> 进行线性插值</p><table><thead><tr><th>a</th><th>颜色 a。</th></tr></thead><tbody><tr><td>b</td><td>颜色 b。</td></tr><tr><td>t</td><td>用于组合 a 和 b 的浮点数。</td></tr></tbody></table><h2 id="包、类、接口相关"><a href="#包、类、接口相关" class="headerlink" title="包、类、接口相关"></a>包、类、接口相关</h2><h3 id="EventSystems"><a href="#EventSystems" class="headerlink" title="EventSystems"></a>EventSystems</h3><p>c#脚本中，可以通过<code>using UnityEngine.EventSystems;</code>来使用EventSystems包内相关内容</p><p>鼠标移入移出的接口事件：IPointerEnterHandler,IPointerExitHandler</p><p>要实现的接口内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标移入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//鼠标移除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法适用的几个类型题目：</p><ul><li><p><strong>组合问题</strong></p><ul><li>组合问题要注意：<strong>组合本身意味着不同顺序代表的是同一个组合</strong>（eg： (2,5)和(5,2)是同一个组合）</li></ul></li><li><p><strong>分割问题</strong></p></li><li><p><strong>子集问题</strong></p></li><li><p><strong>排列问题</strong></p></li><li><p><strong>棋盘问题</strong></p></li></ul><p><strong>回溯三部曲：</strong></p><ul><li><strong>递归函数参数返回</strong></li><li><strong>确定终止条件</strong></li><li><strong>单层递归逻辑</strong></li></ul><p>回溯算法的遍历过程：</p><ul><li>回溯搜索的遍历过程</li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20210130173631174.png" alt="回溯算法理论基础"></p><p><strong>回溯算法模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剪枝优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;= n - (k-peth.<span class="built_in">size</span>())+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    peth.<span class="built_in">push</span>(i);<span class="comment">//加入集合</span></span><br><span class="line">    递归循环</span><br><span class="line">    回溯撤回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h2><p>题目：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><p>把组合问题抽象为如下树形结构：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合"></p><p>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。</p><p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p><p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合</p><p>解题思路：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n;i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版本：</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>题目链接：<a href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p><h3 id="组合总和-III"><a href="#组合总和-III" class="headerlink" title="组合总和 III"></a>组合总和 III</h3><p>题目：<a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975.png" alt="216.组合总和III"></p><p>解题思路：<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;sumTarget&quot;&gt;目标和&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;k&quot;&gt;k个数&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;sum&quot;&gt;辅助求和&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;startIndex&quot;&gt;辅助下标&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> sumTarget,<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>()==k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumTarget == sum) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">backtracking</span>(sumTarget,k,sum,i+<span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销</span></span><br><span class="line">        sum -= i;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和为n，个数为k</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版本：</p><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p>题目：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p><p>解题思路：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p><strong>数字和字母如何映射：</strong></p><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string s;<span class="comment">//存储单个结果(集合)</span></span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits,<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index==digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数字变成对应的字符串集</span></span><br><span class="line">    <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    string letter = letterMap[digit];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,index+<span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>解题思路同组合总和 III</p><p>PS：该题目是可以重复拿取的，所以在纵向遍历的时候<strong>从i开始而不用再从i+1开始</strong>遍历</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt;&amp; k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; k.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        sum += k[i];</span><br><span class="line">        path.<span class="built_in">push_back</span>(k[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(target,k,sum,i); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">        sum -= k[i];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtracking</span>(target, candidates, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶版：组合总和II <a href="https://leetcode.cn/problems/combination-sum-ii/description/">https://leetcode.cn/problems/combination-sum-ii/description/</a></p><p>该题涉及到<strong>去重处理</strong>，具体详解内容参考代码随想录的文章：</p><p><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF</a></p><p>涉及到去重的两种情况：<strong>树枝去重（递归）、树层去重（for循环）</strong></p><h2 id="分割问题"><a href="#分割问题" class="headerlink" title="分割问题"></a>分割问题</h2><h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><p>题目链接：<a href="https://leetcode.cn/problems/palindrome-partitioning/description/">https://leetcode.cn/problems/palindrome-partitioning/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">   vector&lt;string&gt; path;</span><br><span class="line">   <span class="function"><span class="type">bool</span> <span class="title">isMoslems</span><span class="params">(string s,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = l, j = r; i &lt; j; i++,j--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (s[j] != s[i])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string str,<span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">if</span> (startIndex &gt;= str.<span class="built_in">size</span>())</span><br><span class="line">       &#123;</span><br><span class="line">           res.<span class="built_in">push_back</span>(path);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">isMoslems</span>(str,startIndex,i))</span><br><span class="line">           &#123;</span><br><span class="line">               string sub = str.<span class="built_in">substr</span>(startIndex,i-startIndex+<span class="number">1</span>);</span><br><span class="line">               path.<span class="built_in">push_back</span>(sub);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="built_in">backtracking</span>(str, i + <span class="number">1</span>);</span><br><span class="line">           path.<span class="built_in">pop_back</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">       <span class="built_in">backtracking</span>(s, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p><strong>子集问题通常是在回溯的时候就把结果收集起来，而不是在临界位置或者达到目标才收集结果</strong></p><p>题目链接：<a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p><p>子集问题相当于<strong>把每个遍历过的节点都能作为该集合的子集</strong>，代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (startIndex == nums.<span class="built_in">size</span>())</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">      &#123;</span><br><span class="line">          path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">          <span class="comment">//不同之处在于这个地方直接收集结果</span></span><br><span class="line">          result.<span class="built_in">push_back</span>(path);</span><br><span class="line">          <span class="built_in">backtracking</span>(nums, i);</span><br><span class="line">          path.<span class="built_in">pop_back</span>();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进阶版本：子集II<a href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p><p>本质上同组合总和的进阶版(II)一样，区别在于多了一个去重的操作，去重操作也和之前一样，要注意什么时候表示树枝去重(used[i-1]&#x3D;true)，什么时候表示树层去重(used[i-1]&#x3D;false)</p><p>具体去重的讲解参考组合总和II即可</p><p>需要注意的是：<strong>去重操作一般要先对初始数组进行排序</strong>(sort)</p><h2 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h2><p>排列问题通常都要用到剪枝操作，由于排列问题意味着每次循环都是从起点开始遍历到终点，所以通过剪枝操作能够优化，通常默认都是要有树枝去层</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>题目：<a href="https://leetcode.cn/problems/permutations/description/">https://leetcode.cn/problems/permutations/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i])<span class="keyword">continue</span>;</span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(nums);</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    used = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(nums.<span class="built_in">size</span>(), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题再提升还可以多加一个数层去重，对应题目为：</p><p><a href="https://leetcode.cn/problems/permutations-ii/description/">https://leetcode.cn/problems/permutations-ii/description/</a></p><h2 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h2><p>题目链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p><p>该题和子集进阶很像，但是实际上区别很大：</p><p>一个是初始数组被固定，无法排序，这意味着去重操作也不一样</p><p>该题的去重虽然仍是树层去重，但是却不能用used数组的方式来进行排序后去重的操作</p><p>而是采用了无序容器unordered set来进行重复标记</p><p><code>std::unordered_set</code>是一种无序集合容器，它提供了快速的查找操作。查找元素时，通常使用<code>find</code>成员函数，<strong>如果找到了元素，它会返回一个指向该元素的迭代器；如果没有找到，它会返回一个指向容器<code>end</code>的迭代器</strong></p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>题目：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p><p>解题思路：<a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF</a></p><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>验证棋盘是否合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 不需要在检查行的原因是在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"><span class="comment">/* 检测棋盘是否合法：</span></span><br><span class="line"><span class="comment">1. 不能同行</span></span><br><span class="line"><span class="comment">2. 不能同列</span></span><br><span class="line"><span class="comment">3. 不能同斜线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    回溯算法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//n —— 棋盘大小</span></span><br><span class="line"><span class="comment">//row —— 当前所在棋盘第row行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n,vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层遍历，内层递归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n;col++) &#123;</span><br><span class="line">        <span class="comment">//验证是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) </span><br><span class="line">        &#123;</span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(row+<span class="number">1</span>,n,chessboard); <span class="comment">// 递归</span></span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">chessboard</span><span class="params">(n, std::string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(<span class="number">0</span>, n, chessboard);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>题目链接：<a href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p><p>分析：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20201124174327597.png" alt="376.摆动序列"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong></p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p>本题要考虑三种情况：</p><ol><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ol><p>具体讲解看：<a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> pref = <span class="number">0</span>, curf = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           考虑到：</span></span><br><span class="line"><span class="comment">           情况一：上下坡中有平坡</span></span><br><span class="line"><span class="comment">           情况二：数组首尾两端</span></span><br><span class="line"><span class="comment">           情况三：单调坡中有平坡</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           curf = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">           <span class="keyword">if</span> (pref &lt;= <span class="number">0</span> &amp;&amp; curf &gt; <span class="number">0</span> || pref &gt;= <span class="number">0</span> &amp;&amp; curf &lt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               result++;</span><br><span class="line">               pref = curf;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><p>贪心思路：</p><p>累加之和 + nums[i] &#x3D; 新的累加之和</p><p>最优情况下意味着累加之和不应该 &lt; 0，这样会让nums[i]的数值也降低</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, maxx = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (maxx &lt; sum)</span><br><span class="line">                maxx = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity内容整理</title>
      <link href="/2023/10/26/unity%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
      <url>/2023/10/26/unity%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事件方法-委托"><a href="#事件方法-委托" class="headerlink" title="事件方法(委托)"></a>事件方法(委托)</h1><p>以一个例子来理解：</p><p>当场景生成阳光，玩家点击阳光后更新阳光数量，此时植物卡牌会根据当前阳光数量来刷新状态（有阳光有CD、有阳光无CD、无阳光有CD、无阳光无CD）</p><p>其中充当该功能实现的有两个类，在此期间使用了<strong>委托</strong>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerManager Instance;</span><br><span class="line">    <span class="comment">//阳光的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> sunNum;</span><br><span class="line">    <span class="comment">//阳光数量更新事件</span></span><br><span class="line">    <span class="keyword">private</span> UnityAction sunUpdateAction;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SunNum = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SunNum</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; sunNum;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            sunNum = <span class="keyword">value</span>;</span><br><span class="line">            UIManager.Instance.UpdateSunNum(sunNum);</span><br><span class="line">            sunUpdateAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阳光数量更新事件监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddSunNumUpdateActionListener</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sunUpdateAction += action;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>PlayerManager</code> 类中，<code>AddSunNumUpdateActionListener</code> 方法允许其他模块注册一个方法（通过 <code>UnityAction</code> 委托表示）。这个方法会在 <code>PlayerManager</code> 中的 <code>sunUpdateAction</code> 委托被调用时执行</p><p>另外一个类的实现该功能的部分代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPlantCard</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span>,<span class="title">IPointerExitHandler</span>,<span class="title">IPointerClickHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//种植需要消耗的阳光</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> costSun;</span><br><span class="line">    <span class="comment">//冷却时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> CDTime;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentTimeForCd;</span><br><span class="line">    <span class="comment">//植物CD是否转好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canPlace;</span><br><span class="line">    <span class="comment">//当前卡片所对应的植物类型</span></span><br><span class="line">    <span class="keyword">public</span> PlantType CardPlantType;</span><br><span class="line">    <span class="comment">//当前植物卡片的状态</span></span><br><span class="line">    <span class="keyword">private</span> CardState cardState = CardState.NotAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerManager.Instance.AddSunNumUpdateActionListener(CheckState);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有CD 有阳光</span></span><br><span class="line">        <span class="keyword">if</span> (canPlace &amp;&amp; PlayerManager.Instance.SunNum &gt;= costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.CanPlace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有CD 有阳光</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!canPlace &amp;&amp; PlayerManager.Instance.SunNum &gt;= costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotCD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有CD 没有阳光</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (canPlace &amp;&amp; PlayerManager.Instance.SunNum &lt; costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotSun;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有CD 没有阳光</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotAll;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PlayerManager.Instance.AddSunNumUpdateActionListener(CheckState)</code>意味着 <code>CheckState</code> 方法被注册到了 <code>PlayerManager</code> 中的 <code>sunUpdateAction</code> 委托中。</p><p>因此，每当 <code>PlayerManager.Instance.SunNum</code> 的值发生变化，并且 <code>sunUpdateAction</code> 被调用时，<code>CheckState</code> 方法会被执行。</p><p>总体流程为：</p><ol><li>在游戏开始时，<code>PlayerManager</code> 的 <code>Awake</code> 方法中会将 <code>sunUpdateAction</code> 委托初始化为空。</li><li>在 <code>Start</code> 方法中，<code>UIPlantCard</code>通过 <code>AddSunNumUpdateActionListener</code> 将 <code>CheckState</code> 方法注册到了 <code>sunUpdateAction</code> 委托中。</li><li>当 <code>PlayerManager.Instance.SunNum</code> 的值发生变化时，<code>PlayerManager</code> 中的 <code>SunNum</code> 的 <code>set</code> 访问器被调用。</li><li>在 <code>set</code> 访问器中，<code>sunUpdateAction()</code> 被调用，触发了 <code>sunUpdateAction</code> 委托。</li><li>因为 <code>CheckState</code> 方法已经被注册到 <code>sunUpdateAction</code> 委托中，所以 <code>CheckState</code> 方法被执行。</li></ol><h1 id="事件方法-UnityEvent"><a href="#事件方法-UnityEvent" class="headerlink" title="事件方法(UnityEvent)"></a>事件方法(UnityEvent)</h1><h1 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h1><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p><img src="/./../images/unity%E6%80%BB%E7%BB%93(1)/image-20231102143428511.png" alt="image-20231102143428511"></p><ul><li><p>Source Image</p></li><li><p>Color(&amp; Material)</p></li><li><p>Raycast -XX</p><ul><li><strong>Raycast Target</strong></li><li>Raycast Padding</li></ul></li><li><p><strong>Image Type</strong></p></li></ul><h3 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h3><ul><li>Simple</li><li>Sliced</li><li>Tiled</li><li>Filled</li></ul><p><code>Filled</code>类型含有的参数内容：</p><p>Fill Method —— 变化的类型</p><p>Fill Origin —— 起始位置</p><p>Fill Amount —— 变化的数值</p><p>Preserve Aspect</p><h2 id="Horizontal-Layout-Group"><a href="#Horizontal-Layout-Group" class="headerlink" title="Horizontal Layout Group"></a>Horizontal Layout Group</h2><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li><p>Render Mode</p><ul><li>Overlay模式</li><li>Camera模式</li><li>World Space</li></ul></li></ul><h1 id="携程-IEnumerator"><a href="#携程-IEnumerator" class="headerlink" title="携程(IEnumerator)"></a>携程(IEnumerator)</h1><h1 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举(Enum)"></a>枚举(Enum)</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十四）</title>
      <link href="/2023/10/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/10/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十四"><a href="#Unity开发日记-十四" class="headerlink" title="Unity开发日记(十四)"></a>Unity开发日记(十四)</h1><h2 id="暂停面板以及声音控制"><a href="#暂停面板以及声音控制" class="headerlink" title="暂停面板以及声音控制"></a>暂停面板以及声音控制</h2><p>在unity界面上创建<code>Panel</code>容器：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164208317.png" alt="image-20231025164208317"></p><p>然后在该容器下创建滑动条容器<code>Slider</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164508062.png" alt="image-20231025164508062"></p><p>通过滑条的该位置来调整数值，同时还能添加事件，从而实现我们通过滑条来修改游戏音乐：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164733362.png" alt="image-20231025164733362"></p><p>回到unity界面上调出音频设置：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165126484.png" alt="image-20231025165126484"></p><p>此时可以观察到之前设置的音频内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165152780.png" alt="image-20231025165152780"></p><p>同时为了能够实现通过滑条来控制音量，则音频设置需要有暴露参数让其可以通过数值来修改音量：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025173033444.png" alt="image-20231025173033444"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165506338.png" alt="image-20231025165506338"></p><p>在<code>Audio Mixer</code>下能够查看到我们暴露出来的参数，可以为其重命名方便管理</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165616087.png" alt="image-20231025165616087"></p><p>接着在音量控制脚本<code>AudioManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165920483.png" alt="image-20231025165920483"></p><p>为了让音量控制脚本能够得到音量调整的参数(float类型)，所以在事件脚本文件夹·<code>ScriptableObject</code>下创建传递Float参数的事件<code>FloatEventSO</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170316910.png" alt="image-20231025170316910"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170750720.png" alt="image-20231025170750720"></p><p>然后回到unity界面中，先在事件文件下创建该Float类型的事件，然后将其在滑动条容器下的事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170908332.png" alt="image-20231025170908332"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171047947.png" alt="image-20231025171047947"></p><p>然后再次回到音量控制脚本<code>AudioManager</code>下进行修改，添加监听事件与要实现监听后的方法：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171442073.png" alt="image-20231025171442073"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171503797.png" alt="image-20231025171503797"></p><p>回到unity界面，检查可以发现，滑动条可以移动传递的float类型是在0-1之间，而音量的调整缺有-80-20之间，所以代码位置还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171611696.png" alt="image-20231025171611696"></p><p>最后在unity界面为音量监听组件重新绑定事件，然后进行测试</p><p>设计可以打开设置界面的按钮，从而使得通过点击设置按钮来启动暂停面板并可以进行调控音量的操作：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025173553452.png" alt="image-20231025173553452"></p><p>也就是通过设置按钮(Button)容器来启动暂停面板容器(Pause Panel)的开关</p><p>所以要先到UI控制脚本<code>UIManager</code>上进行内容的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174217025.png" alt="image-20231025174217025"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174232573.png" alt="image-20231025174232573"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174256236.png" alt="image-20231025174256236"></p><p>回到unity界面为UI管理脚本绑定相应的内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174543176.png" alt="image-20231025174543176"></p><p>最后设计游戏暂停，只要在UI管理脚本<code>UIManager</code>下让暂停面板弹出的代码部分添加时间相关内容即可：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174857935.png" alt="image-20231025174857935"></p><p>优化：当开启暂停时，当前音量值多少也会反向传递给滑动条</p><p>首先创建一个相同的需要float类型的事件<code>SyncVolume Event</code>，同时还要再创建一个无参的暂停广播事件<code>Pause Event</code>，然后在UI控制脚本<code>UIManager</code>下修改：</p><ul><li>广播事件</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025184712982.png" alt="image-20231025184712982"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025184737615.png" alt="image-20231025184737615"></p><ul><li>监听事件</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185840246.png" alt="image-20231025185840246"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185945977.png" alt="image-20231025185945977"></p><p>然后回到音量控制脚本<code>AudioManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185428015.png" alt="image-20231025185428015"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185554274.png" alt="image-20231025185554274"></p><p>更改完成两个脚本后再回到unity界面上分别进行事件的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190213371.png" alt="image-20231025190213371"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190314530.png" alt="image-20231025190314530"></p><p>最后回到界面管理脚本<code>UIManager</code>下完成监听内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190658416.png" alt="image-20231025190658416"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025190713913.png" alt="image-20231025190713913"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190832856.png" alt="image-20231025190832856"></p><h2 id="打包生成游戏"><a href="#打包生成游戏" class="headerlink" title="打包生成游戏"></a>打包生成游戏</h2><h3 id="初始化场景"><a href="#初始化场景" class="headerlink" title="初始化场景"></a>初始化场景</h3><p>在unity界面上先创建一个空的场景，在空场景下再创建一个空容器，再创建一个初始化脚本<code>InitialLoad</code>并挂载到空容器上，编写脚本内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202028018.png" alt="image-20231025202028018"></p><p>然后回到unity界面上边绑定要初始化的场景：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202128179.png" alt="image-20231025202128179"></p><p>随后在File选项下选择Build Setting：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202406579.png" alt="image-20231025202406579"></p><h3 id="Addressables资源打包"><a href="#Addressables资源打包" class="headerlink" title="Addressables资源打包"></a>Addressables资源打包</h3><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203311335.png" alt="image-20231025203311335"></p><ul><li>手动打包</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203354554.png" alt="image-20231025203354554"></p><ul><li>自动打包</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203423332.png" alt="image-20231025203423332"></p><h3 id="最终打包细节设置"><a href="#最终打包细节设置" class="headerlink" title="最终打包细节设置"></a>最终打包细节设置</h3><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203620337.png" alt="image-20231025203620337"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203651456.png" alt="image-20231025203651456"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203814817.png" alt="image-20231025203814817"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204009005.png" alt="image-20231025204009005"></p><p>经常会遇到的问题是，当我们打包游戏后，在实际游玩过程中会发现贴图有时候会有很小的缝隙，如何解决？</p><p>我们要把我们的图片素材也进行打包即可，首先在图片资源文件夹<code>Art Assets</code>下创建一个<code>Sprite Atlas</code>类型的：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204327276.png" alt="image-20231025204327276"></p><p>作用：可以把我们游戏的图片打包成一个图集，或者把游戏图片素材变成一张图片</p><p>将我们要用到的图片素材都打包过去：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204818581.png" alt="image-20231025204818581"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025205245584.png" alt="image-20231025205245584"></p><p>完成后要记得把Addressable内容重新手动打包一次，最后再进行游戏打包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十三）</title>
      <link href="/2023/10/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2023/10/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据保存和加载"><a href="#数据保存和加载" class="headerlink" title="数据保存和加载"></a>数据保存和加载</h1><h2 id="实现”新的游戏”逻辑"><a href="#实现”新的游戏”逻辑" class="headerlink" title="实现”新的游戏”逻辑"></a>实现”新的游戏”逻辑</h2><p>首先在场景脚本<code>SceneLoader</code>下进行细节的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151241508.png" alt="image-20231023151241508"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151507145.png" alt="image-20231023151507145"></p><p>同时代码也要进行修改，初始不是在第一个场景，而是在主场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151803851.png" alt="image-20231023151803851"></p><p>接下来就是实现新游戏启动的逻辑：</p><p>首先在事件文件夹<code>Event</code>下创建一个新的无参事件<code>New Game Event</code>，然后将其绑定在“新的游戏”按钮容器下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152452993.png" alt="image-20231023152452993"></p><p>随后回到场景加载容器下场景加载脚本<code>SceneLoader</code>进行事件的监听并实现相关逻辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152831438.png" alt="image-20231023152831438"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152858595.png" alt="image-20231023152858595"></p><p>再次回到unity界面为其事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152930155.png" alt="image-20231023152930155"></p><h3 id="加载场景过程中显示UI信息"><a href="#加载场景过程中显示UI信息" class="headerlink" title="加载场景过程中显示UI信息"></a>加载场景过程中显示UI信息</h3><p>先在事件文件夹下创建场景卸载事件<code>ScenUnloaded Event SO</code>，然后在UI界面控制容器的脚本组件下进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154008647.png" alt="image-20231023154008647"></p><p>然后在场景加载脚本<code>SceneLoad</code>下修改代码，使其在场景加载过程中(还是黑屏时)启用广播调整血条显示：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154512824.png" alt="image-20231023154512824"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154543413.png" alt="image-20231023154543413"></p><h3 id="初始化玩家血量"><a href="#初始化玩家血量" class="headerlink" title="初始化玩家血量"></a>初始化玩家血量</h3><p>当进入新游戏时，要重新初始化玩家的血量(回满)，所以先回到角色容器下的角色属性脚本<code>Character</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023155935138.png" alt="image-20231023155935138"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160007417.png" alt="image-20231023160007417"></p><p>最后回到unity上，为角色人物，怪物等身上绑定有属性脚本的都把该事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160117495.png" alt="image-20231023160117495"></p><p>PS：</p><p>我们添加了 New Game 函数在 Character 代码中，仍然要在 Start 函数函数中给血量赋值。</p><p>**<code>character</code>**：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了敌人能在开始获得血量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    currentHealth = maxHealth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化选项"><a href="#初始化选项" class="headerlink" title="初始化选项"></a>初始化选项</h3><p>开始进行初始化前，首先要先了解当unity界面创建UI容器时自动创建的EventSystem容器的作用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161611097.png" alt="image-20231023161611097"></p><p>游戏主界面时，默认选项在开始游戏位置，其次可以通过键盘来直接控制上下的选项，首先先为几个选项按钮都进行设置，使其能够通过键盘来控制上下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160822255.png" alt="image-20231023160822255"></p><p>所以我们要使得其游戏开始时默认就在第一个按钮位置，这样就能进行上下操作了</p><p>在UI文件夹下创建控制脚本<code>Menu</code>，并将其挂载到按键和文本的父容器上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161116384.png" alt="image-20231023161116384"></p><p>进行代码逻辑的编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161717359.png" alt="image-20231023161717359"></p><p>然后回到unity界面上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161854539.png" alt="image-20231023161854539"></p><p>最后在代码中编写“退出”后的内容，实现当用户点击退出后，所有资源都进行关闭：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023162105858.png" alt="image-20231023162105858"></p><p>回到unity界面上，在退出按钮中进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023162353380.png" alt="image-20231023162353380"></p><h2 id="存档点以及画面效果"><a href="#存档点以及画面效果" class="headerlink" title="存档点以及画面效果"></a>存档点以及画面效果</h2><p>首先对图片素材进行调整并切割，以其中一个地形场景作为举例：</p><p>将岩石图片以及两张符文图片作为一个存档点来设计，先放置岩石，然后将符文图片作为子物体挂载到岩石图片上，同时为岩石添加碰撞体积组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023200643921.png" alt="image-20231023200643921"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023200919359.png" alt="image-20231023200919359"></p><p>同时设置图片的标签为可互动的标签：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202426382.png" alt="image-20231023202426382"></p><p>然后在脚本文件夹<code>Script</code>下创建加载保存文件夹<code>Save Load</code>，并创建相关的脚本<code>SavePoint</code>，然后挂载到岩石身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023201418282.png" alt="image-20231023201418282"></p><p>对该存档点脚本<code>SavePoint</code>进行代码编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202357676.png" alt="image-20231023202357676"></p><p>回到unity界面并进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202601074.png" alt="image-20231023202601074"></p><p>其中，<code>Sprite Renderer</code>绑定它的子容器，也即：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023203226362.png" alt="image-20231023203226362"></p><p>最后测试发现其保存后还能继续交互，所以还要对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023203503450.png" alt="image-20231023203503450"></p><h3 id="画面灯光效果以及局部灯光效果"><a href="#画面灯光效果以及局部灯光效果" class="headerlink" title="画面灯光效果以及局部灯光效果"></a>画面灯光效果以及局部灯光效果</h3><p>在洞窟场景可以添加一个容器，为其添加一个灯光组件，通过灯光组件来使得场景画面有灯光的效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204009656.png" alt="image-20231023204009656"></p><p>大致画面效果为：<img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204023628.png" alt="image-20231023204023628"></p><p>然后为存档点的符文位置设置一个局部灯光亮点：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204221713.png" alt="image-20231023204221713"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204430175.png" alt="image-20231023204430175"></p><h3 id="实现后处理"><a href="#实现后处理" class="headerlink" title="实现后处理"></a>实现后处理</h3><p>在unity界面当前场景创建后加载容器<code>Global Volume</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204739565.png" alt="image-20231023204739565"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204836644.png" alt="image-20231023204836644"></p><p>添加需要的管线内容，调整特效等内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205059146.png" alt="image-20231023205059146"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205138303.png" alt="image-20231023205138303"></p><p>曝光管线则是<code>Color Adjustments</code></p><p>同时要先回到主摄像机容器<code>Main Camera</code>下调整设置，使其生效：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205304532.png" alt="image-20231023205304532"></p><p>然后回到存档点脚本里边重新调整代码，使其在角色存档后切换图片并使用如上的灯光效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023211911224.png" alt="image-20231023211911224"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023211931766.png" alt="image-20231023211931766"></p><p>然后回到unity界面上为其脚本内容绑定相关的灯光：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212042224.png" alt="image-20231023212042224"></p><p>再次创建一个新的后处理容器<code>Box Volume</code>，将其范围圈定在上边，使得人物在跳跃到上边场景时候能够提高场景亮度：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212745110.png" alt="image-20231023212745110"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212824977.png" alt="image-20231023212824977"></p><p>PS：要想在unity界面上查看我们调整的画面效果，需要设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213101540.png" alt="image-20231023213101540"></p><p>通过观察可以发现我们刚设置的灯光没有起效，原因是该灯光特效与摄像机是存在距离的</p><p>在摄像机容器上可以发现其是三维坐标，z轴为距离10</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213405624.png" alt="image-20231023213405624"></p><p>而灯光特效本质也是一个立体特效，所以要考虑到距离，所以可以在该位置设置其起效的距离：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213331190.png" alt="image-20231023213331190"></p><h3 id="▲数据结构与坐标保存加载"><a href="#▲数据结构与坐标保存加载" class="headerlink" title="▲数据结构与坐标保存加载"></a>▲数据结构与坐标保存加载</h3><p>首先在事件管理文件夹<code>Event</code>下创建无参事件的数据存储事件<code>LoadGameData Event</code>，然后在存档点脚本<code>SavePoint</code>进行增添内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213855167.png" alt="image-20231023213855167"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023214153801.png" alt="image-20231023214153801"></p><p>然后回到unity界面上进行事件的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023214235955.png" alt="image-20231023214235955"></p><p>然后在存档点加载文件夹<code>Load Save</code>下创建一个存储接口<code>ISaveable</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024093517042.png" alt="image-20231024093517042"></p><p>然后接着创建一个数据存储和读取管理脚本<code>DataManager</code>，并在unity界面上创建对应的数据存储和管理容器，将该脚本挂载上去:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024093920049.png" alt="image-20231024093920049"></p><p>然后通过<strong>观察者模式（单例模式）</strong>来实现数据的统一存储与管理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024095231634.png" alt="image-20231024095231634"></p><p>创建存储列表，对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024100950361.png" alt="image-20231024100950361"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024101007886.png" alt="image-20231024101007886"></p><p>然后再修改存储数据接口<code>ISaveable</code>，在新版本c#中可以直接定义方法内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024095412392.png" alt="image-20231024095412392"></p><p>回到unity界面，在存档点加载文件夹下再创建一个保存的数据类<code>Data</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024102505990.png" alt="image-20231024102505990"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024102702476.png" alt="image-20231024102702476"></p><p>而由于传入的数据是键值对，所以要有一个标识来作为string类型以此区分不同对象的不同数据，这里就要用到<strong>全局唯一标识符（GUID）</strong>，回到存档点加载文件夹下创建数据描述定义脚本<code>DataDefinition</code>来生成GUID：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024103948990.png" alt="image-20231024103948990"></p><p><code>OnValidate()</code>它通常用于在编辑器时期执行操作，而不是在运行时。这意味着你可以在编辑器中进行属性的设置和验证，而不必等到运行游戏</p><p>通过挂载到角色或者怪物身上后，另外一个问题是游戏每次重开，该GUID都会发生变化，为了限制其变化，首先回到枚举脚本<code>Enums</code>下添加新的枚举类型：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104310902.png" alt="image-20231024104310902"></p><p>修改数据描述定义脚本<code>DataDefination</code>，然后将其挂载到角色&#x2F;怪物身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104730617.png" alt="image-20231024104730617"></p><p>接着回到存储接口中，添加获得键值的方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104839014.png" alt="image-20231024104839014"></p><p>最后以将角色脚本信息传递过去来举例进行代码的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024105710389.png" alt="image-20231024105710389"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024105810736.png" alt="image-20231024105810736"></p><p>由于在接口中，注册与卸载方法我们直接写了方法内容，所以在其他类实现接口不会生成这两种方法，所以我们可以<strong>强制声明并让其执行一次</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024110303479.png" alt="image-20231024110303479"></p><p>这样就完成了<strong>对象的数据存储与数据传输</strong>，接下来就是要到数据管理器里获取数据并加载数据，所以回到数据管理脚本<code>DataManager</code>下进行代码的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024131943170.png" alt="image-20231024131943170"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132020760.png" alt="image-20231024132020760"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132108703.png" alt="image-20231024132108703"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024135410779.png" alt="image-20231024135410779"></p><p>回到unity界面下，在事件文件夹下创建新的无参数据加载事件<code>SavaDataEvent</code>，并将其分别绑定在存档点保存广播位置和主数据管理组件的监听位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024111014054.png" alt="image-20231024111014054"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024111043200.png" alt="image-20231024111043200"></p><p>同时为预制体中每个怪物都挂载上数据描述定义脚本:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132616016.png" alt="image-20231024132616016"></p><p>最后测试加载保存数据是否成功，在数据管理脚本<code>DataManager</code>下修改测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024135923425.png" alt="image-20231024135923425"></p><h3 id="人物数值及场景的保存"><a href="#人物数值及场景的保存" class="headerlink" title="人物数值及场景的保存"></a>人物数值及场景的保存</h3><p>先在数据脚本<code>Data</code>下定义新的字典类型：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024141117380.png" alt="image-20231024141117380"></p><p>然后回到角色属性脚本<code>Character</code>下添加场景新的数据存储内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024142009658.png" alt="image-20231024142009658"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024142324898.png" alt="image-20231024142324898"></p><p>这样就完成了人物数值(生命、能量条)的保存</p><p>接下来要实现场景的保存，先在数据类中添加新的存储类型来存储场景，同时使用<strong>工厂模式</strong>进行内容的执行：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024144950038.png" alt="image-20231024144950038"></p><p>接着在场景加载脚本<code>SceneLoader</code>上进行增添，同时为场景加载容器添加<code>DataDefinition</code>组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024143853333.png" alt="image-20231024143853333"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024143934201.png" alt="image-20231024143934201"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024150827389.png" alt="image-20231024150827389"></p><p>这样就完成了场景数据存储的过程，接下来还要实现场景加载的过程，首先回到数据类添加反序列化内容从而能够传递旧的场景信息：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024150936281.png" alt="image-20231024150936281"></p><p>接着回到场景加载脚本<code>SceneLoader</code>下完成加载方法的功能：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024151039940.png" alt="image-20231024151039940"></p><p>对返回的坐标也要进行更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024151322128.png" alt="image-20231024151322128"></p><p>这样就完成了场景的加载</p><h2 id="游戏结束面板"><a href="#游戏结束面板" class="headerlink" title="游戏结束面板"></a>游戏结束面板</h2><p>在<code>Main Canvas</code>容器下创建<code>Panel</code>面板作为游戏结束面板</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024172718817.png" alt="image-20231024172718817"></p><p>设置需要的参数：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024172847866.png" alt="image-20231024172847866"></p><p>然后在该面板下再创建几个画布并命名调整排位：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174006768.png" alt="image-20231024174006768"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174022082.png" alt="image-20231024174022082"></p><p>然后为画布也添加对应的按钮并设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174335043.png" alt="image-20231024174335043"></p><ul><li><strong>“重新开始”功能</strong></li></ul><p>回到数据管理器脚本<code>DataManager</code>下设置监听事件并实现重新开始的功能：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174608124.png" alt="image-20231024174608124"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174623633.png" alt="image-20231024174623633"></p><p>同时还要为“重新开始”容器上绑定触发的事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174748123.png" alt="image-20231024174748123"></p><p>随后还要考虑到角色死亡后触发的问题，也就是当人物死亡后要弹出来上边的游戏结束面板，可以在unity界面上直接进行修改：</p><p>在角色容器的角色属性组件下，可以通过死亡方法绑定对应的死亡面板容器并启用开关来达到这种效果</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024175031210.png" alt="image-20231024175031210"></p><p>为了使得人物死亡后探出游戏结束面板默认在重新开始位置，则要对代码进行修改，首先回到UI界面管理脚本<code>UIManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024180902857.png" alt="image-20231024180902857"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181026620.png" alt="image-20231024181026620"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181042839.png" alt="image-20231024181042839"></p><p>然后回到unity界面上进行绑定，在事件文件夹下再次创建游戏结束事件<code>GameOverEvent</code>，同时把人物容器的死亡事件绑定也更换为游戏结束事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181524554.png" alt="image-20231024181524554"></p><p><img src="/./../../../typora-images/image-20231024195150166.png" alt="image-20231024195150166"></p><p>最后测试发现死亡重新开始后，人物动画没有发生变化，所以还要进行修改，在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200248392.png" alt="image-20231024200248392"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200308205.png" alt="image-20231024200308205"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200322163.png" alt="image-20231024200322163"></p><p>这样就完成了重新开始的功能了</p><ul><li><strong>“离开”功能</strong></li></ul><p>接下来要对离开按钮设计相应的代码实现，首先在事件文件夹下创建离开事件<code>BackToMenu Event</code>并将其作为组件挂载在“离开”按钮容器上边：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024201205888.png" alt="image-20231024201205888"></p><p>随后在场景加载容器上的场景加载脚本内进行代码的设计：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202146087.png" alt="image-20231024202146087"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202207797.png" alt="image-20231024202207797"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202218732.png" alt="image-20231024202218732"></p><p>回到unity界面对修改后的脚本重新绑定对应的事件并测试</p><p>测试后发现点击“离开”后出现的两个问题：</p><ul><li>角色回到主界面是死亡倒地的动画</li><li>游戏结束面板在主界面显示</li></ul><p>为了解决以上问题，首先回到界面管理脚本<code>UIManager</code>上先进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202923937.png" alt="image-20231024202923937"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202944509.png" alt="image-20231024202944509"></p><p>然后再回到角色控制脚本<code>PlayerController</code>下进行代码的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203130398.png" alt="image-20231024203130398"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203150726.png" alt="image-20231024203150726"></p><p>通过代码修改后再次进行测试，仍然还实现不了，通过debug排查，可以发现是在角色属性脚本<code>Character</code>下仍要进行进一步更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203810665.png" alt="image-20231024203810665"></p><p>由于之前会一直执行OnDie的方法，导致其一直执行死亡广播(GameOverEvent)，所以导致UI管理脚本<code>UIManager</code>下会连续执行相应的OnGameOverEvent</p><p>通过修改后就成功实现离开后无游戏结束面板显示主页面的bug了，但是新的问题则是人物离开后在主界面仍然可以移动，所以在角色属性脚本<code>Character</code>也要进行相应的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024204630238.png" alt="image-20231024204630238"></p><p>由于在OnEnable()中会一直开启，所以要切换到Awake()函数中只开启一次即可</p><h2 id="游戏持久化"><a href="#游戏持久化" class="headerlink" title="游戏持久化"></a>游戏持久化</h2><p>首先在主页面继续游戏的按钮添加事件并绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024211648761.png" alt="image-20231024211648761"></p><p>由于自带的json转化无法转化例如三维坐标Vector3，字典类型等数据，所以要采用另外一种json转化包来进行数据序列化地处理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094041553.png" alt="image-20231025094041553"></p><p>通过url方式下载<code>nuget</code>的json功能包</p><p>然后在数据管理脚本<code>DataManager</code>下调用导入的包并进行代码的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094435693.png" alt="image-20231025094435693"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094718197.png" alt="image-20231025094718197"></p><p>如何查看各个脚本之间的执行顺序？Edit → Project Setting → Script Execution Order</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094839064.png" alt="image-20231025094839064"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025095521471.png" alt="image-20231025095521471"></p><p>其中<code>Application.persistentDataPath</code>是unity官方设定的一个默认目录路径：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025095322343.png" alt="image-20231025095322343"></p><p>如何查看项目名<code>companyname</code>或更改项目名？Edit → Project Setting → Player</p><ul><li><strong>传入数据</strong></li></ul><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025100520413.png" alt="image-20231025100520413"></p><ul><li><strong>读取数据</strong></li></ul><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025101141636.png" alt="image-20231025101141636"></p><p>同时要让其在游戏开始时就读取，以便玩家继续游戏:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025101247687.png" alt="image-20231025101247687"></p><p>由于序列化无法直接序列化Vector3类型，所以要在数据类<code>Data</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025130737452.png" alt="image-20231025130737452"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025130840969.png" alt="image-20231025130840969"></p><p>然后回到角色属性脚本<code>Character</code>下对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131127643.png" alt="image-20231025131127643"></p><p>在场景加载脚本<code>SceneLoader</code>下也进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131330993.png" alt="image-20231025131330993"></p><p>通过测试保存后可以在window的对应路径找到我们保存的数据：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131714610.png" alt="image-20231025131714610"></p><p>最终代码总结：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十二）</title>
      <link href="/2023/09/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/09/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十二"><a href="#Unity开发日记-十二" class="headerlink" title="Unity开发日记(十二)"></a>Unity开发日记(十二)</h1><h2 id="场景转换"><a href="#场景转换" class="headerlink" title="场景转换"></a>场景转换</h2><p>首先将<strong>不同场景</strong>和<strong>持久化内容</strong>进行分隔开</p><p>不同场景分别是对应不同的<code>Scence</code>,而持久化内容则是角色、血条、摄像机、BGM等内容</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231008200441838.png" alt="image-20231008200441838"></p><h2 id="人物可互动标识"><a href="#人物可互动标识" class="headerlink" title="人物可互动标识"></a>人物可互动标识</h2><ul><li>宝箱</li></ul><p>将宝箱素材切割后拖拽到场景中并进行相关设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009193745467.png" alt="image-20231009193745467"></p><ul><li>互动按钮</li></ul><p>将按钮素材切割后拖拽到角色下作为子物体组件并进行相关设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009195405750.png" alt="image-20231009195405750"></p><p>为按钮添加动画组件并实现动画效果，</p><p>先在<code>Animation</code>文件下创建存放界面交互动画文件夹<code>UI</code>，然后创建交互按钮的动画控制器并绑定给动画组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009200220172.png" alt="image-20231009200220172"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009200345092.png" alt="image-20231009200345092"></p><p>为按钮组件之上创建一个父容器，为父容器添加一个碰撞体积作为检测玩家有没有接近从而让按钮出现的效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009202744163.png" alt="image-20231009202744163"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010110143729.png" alt="image-20231010110143729"></p><p>然后创建场景互动脚本<code>Sign</code>并绑定到父容器上</p><p>同时创建新的标签来作为要启动的互动内容，并为需要互动的容器都选择该标签</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010103257050.png" alt="image-20231010103257050"></p><p>然后在场景互动脚本<code>Sign</code>进行编辑</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010110318206.png" alt="image-20231010110318206"></p><p>完成编辑后回到unity界面把子容器绑定在脚本上，从而实现代码逻辑能够操控子容器的开关：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111455521.png" alt="image-20231010111455521"></p><p>经过测试，当人物向相反方向移动时，图标也会被翻转，所以还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111829566.png" alt="image-20231010111829566"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111954807.png" alt="image-20231010111954807"></p><p>同时还要设置图标的关闭，当玩家离开交互物体时不再显示图标：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010131744828.png" alt="image-20231010131744828"></p><p>进行动画的绑定，在进行之前，需要设定<strong>当用户是用键盘&#x2F;PS5&#x2F;手柄等不同方式时显示的图标动画也不一样</strong>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010143326705.png" alt="image-20231010143326705"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010134855494.png" alt="image-20231010134855494"></p><p>最后经过测试，发现如果是直接把子容器整个隐藏起来的话，第二次经过互动的物品不会有动画的播放，所以改为子容器启用，但是贴图组件<code>Sprite Renderer</code>关闭，同时回到<code>Sign</code>脚本内进行代码修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150205719.png" alt="image-20231010150205719"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150242510.png" alt="image-20231010150242510"></p><p><strong>错误更正：</strong></p><p>以上<code>Sign</code>内容中不是动画<code>Animation</code>而是动画控制器<code>Animator</code></p><p>如果要采用其他方式进行游戏，如手柄、PS5等等，则还要记得先加上对应的命名空间（这里以PS5举例）：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150611484.png" alt="image-20231010150611484"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150714239.png" alt="image-20231010150714239"></p><h2 id="场景互动的逻辑实现"><a href="#场景互动的逻辑实现" class="headerlink" title="场景互动的逻辑实现"></a>场景互动的逻辑实现</h2><p>通过接口的方式来实现不同物体实现接口方式不同，从而达到不同物体不同交互效果</p><p>在<code>Utilities</code>工具接口文件夹下创建一个可互动接口<code>IInteractable</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010154317091.png" alt="image-20231010154317091"></p><ul><li>宝箱交互</li></ul><p>首先创建一个新的宝箱脚本<code>Chest</code>并调用<code>IInteractable</code>接口，然后在实现之前要先完成交互的前提条件：</p><ol><li><strong>设计宝箱交互(确认)进行时</strong></li></ol><p>回到unity界面上，在角色控制器上添加新的交互按键：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010154744693.png" alt="image-20231010154744693"></p><p>然后回到场景互动脚本<code>Sign</code>编辑新方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204257021.png" alt="image-20231010204257021"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204337477.png" alt="image-20231010204337477"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204435301.png" alt="image-20231010204435301"></p><p>通过获取角色控制器来监听，同时当人物就是在交互物体附近(此时显示有交互图标)按下对应按键就可以调用已经获取的交互物体类的交互接口，从而完成对应交互功能</p><p><strong>2、实现宝箱交互内容</strong></p><p>创建宝箱内容脚本<code>Chest</code>并实现交互接口<code>IIneractable</code>,然后把宝箱内容脚本作为组件挂载到宝箱容器上去</p><p>并填充宝箱内容脚本：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213101764.png" alt="image-20231011213101764"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213111148.png" alt="image-20231011213111148"></p><p>同时回到unity界面上，对该组件需要的两张素材类<code>Sprite</code>进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213325767.png" alt="image-20231011213325767"></p><p>这样就完成了宝箱打开后的图片切换，同时还可以在<code>OpenChest()</code>方法中添加代码让打开后宝箱的容器对应的标签切换为无标签，这样就能让角色经过已经打开过的宝箱时不会弹出交互按钮</p><p><strong>3、为宝箱交互添加对应的BGM</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213907787.png" alt="image-20231011213907787"></p><p>然后回到交互脚本<code>Sign</code>下修改代码，让宝箱被打开时顺便启用bgm：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012112633590.png" alt="image-20231012112633590"></p><p>最终场景互动中，人物与互动物体，宝箱互动的脚本实现总结：</p><p>场景互动脚本<code>Sign</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem.DualShock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sign</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取控制按键</span></span><br><span class="line">    <span class="keyword">private</span> PlayerInputControls playerInput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform playerTran;</span><br><span class="line">    <span class="comment">//操控子容器(按钮互动)</span></span><br><span class="line">    <span class="keyword">public</span> GameObject signSpirte;</span><br><span class="line">    <span class="comment">//判断能否点按</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canPress;</span><br><span class="line">    <span class="comment">//获取要交互的内容</span></span><br><span class="line">    <span class="keyword">private</span> IInteractable targetItem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = signSpirte.GetComponent&lt;Animator&gt;();</span><br><span class="line"></span><br><span class="line">        playerInput = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line">        playerInput.Enable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InputSystem.onActionChange += OnActionChange;</span><br><span class="line">        playerInput.GamePlay.Confirm.started += OnConfirm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnConfirm</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPress)</span><br><span class="line">        &#123;</span><br><span class="line">            targetItem.TriggerAction();</span><br><span class="line">            GetComponent&lt;AudioDefination&gt;()?.PlayAudioClip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        signSpirte.GetComponent&lt;SpriteRenderer&gt;().enabled = canPress;</span><br><span class="line">        signSpirte.transform.localScale = playerTran.localScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnActionChange</span>(<span class="params"><span class="built_in">object</span> obj, InputActionChange actionChange</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionChange == InputActionChange.ActionStarted)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> d = ((InputAction)obj).activeControl.device;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (d.device)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Keyboard:</span><br><span class="line">                    anim.Play(<span class="string">&quot;keyboard&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DualShockGamepad:</span><br><span class="line">                    anim.Play(<span class="string">&quot;ps&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(other.CompareTag(<span class="string">&quot;Interactable&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            canPress= <span class="literal">true</span>;</span><br><span class="line">            targetItem = other.GetComponent&lt;IInteractable&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        canPress = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具文件夹下可互动接口<code>IInteractable</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TriggerAction</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宝箱互动实现互动接口<code>Chest</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">MonoBehaviour</span>,<span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer spriteRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Sprite openSprite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Sprite closeSprite;</span><br><span class="line">    <span class="comment">//判断是否已经打开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer.sprite = isDone ? openSprite : closeSprite;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Open Chest！&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            OpenChest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OpenChest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer.sprite = openSprite;</span><br><span class="line">        isDone= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.tag = <span class="string">&quot;Untagged&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="传送门互动"><a href="#传送门互动" class="headerlink" title="传送门互动"></a>传送门互动</h2><p>首先创建一个新的交互容器用于实现传送门交互，为其添加需要的碰撞体积组件以及新的传送门脚本内容，修改组件属性：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012164105287.png" alt="image-20231012164105287"></p><p>在代码存储文件夹下创建放置交互内容的文件<code>Transistion</code>并创建传送门脚本<code>TeleportPoint</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012164903516.png" alt="image-20231012164903516"></p><h3 id="场景传送-上"><a href="#场景传送-上" class="headerlink" title="场景传送(上)"></a>场景传送(上)</h3><p>场景传送需要有：</p><ol><li>关闭当前场景</li><li>启动新场景</li><li>记录新场景玩家要在的位置(初始点)</li></ol><p>所以要先创建一个全局操控保存应有信息的容器<code>SceneLoad Manager</code>,同时创建场景加载控制脚本<code>SceneLoader</code>,其中全局操控信息的容器放置在角色身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012165352867.png" alt="image-20231012165352867"></p><p>同时将该脚本绑定上去</p><p>然后安装一个场景管理的插件——→ <strong>Addressables</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013210856488.png" alt="image-20231013210856488"></p><p>在unity界面上打开新插件的窗口：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211045305.png" alt="image-20231013211045305"></p><p>然后在新窗口下选择创建Addressables Setting，可以将默认的设置进行改名：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211419764.png" alt="image-20231013211419764"></p><p>再选择不同场景<code>Scene</code>，可以发现多了一个选项可以让我们选择勾选，勾选完成后就会添加在Addressables窗口下的<code>Sences</code>中去：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211631618.png" alt="image-20231013211631618"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211652859.png" alt="image-20231013211652859"></p><h3 id="创建预制体"><a href="#创建预制体" class="headerlink" title="创建预制体"></a>创建预制体</h3><p>创建可以放置怪物预制体<code>Prefab</code>的文件夹，然后在unity界面上通过直接将怪物容器拖拽到该文件夹下成为一个预制体：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212230991.png" alt="image-20231013212230991"></p><p>回到Addressables界面内创建一个新的Assert，并将预制体都拖拽过去方便资源管理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212624495.png" alt="image-20231013212624495"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212715998.png" alt="image-20231013212715998"></p><h3 id="场景传送-中"><a href="#场景传送-中" class="headerlink" title="场景传送(中)"></a>场景传送(中)</h3><p>在事件脚本文件夹<code>ScriptableObject</code>下创建一个新的传递场景加载参数的事件脚本<code>SceneLoadEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015164738458.png" alt="image-20231015164738458"></p><p>然后再在事件脚本文件夹下创建Addressable场景信息<code>GameSceneSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165340575.png" alt="image-20231015165340575"></p><p>随后回到unity界面中创建存储场景信息资源的文件夹<code>Game Scenes</code>，同时将该资源文件夹与BGM资源文件夹一起作为子文件存放在新文件夹<code>Data SO</code>下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165620561.png" alt="image-20231015165620561"></p><p>随后创建需要的资源存储容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165731041.png" alt="image-20231015165731041"></p><p>同时绑定资源存储容器需要的引用，选择我们对应的场景资源内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165816542.png" alt="image-20231015165816542"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165906788.png" alt="image-20231015165906788"></p><p>同样方式将其他场景也加入并绑定，然后回到场景加载事件脚本<code>SceneLoader</code>下进行编写，实现对场景资源的加载：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174214896.png" alt="image-20231015174214896"></p><p><strong><code>LoadSceneAsync</code>方法参数对应的意思：</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015171010189.png" alt="image-20231015171010189"></p><p><code>LoadSceneMode.Additive</code>参数的意思是：将场景添加到当前加载的场景</p><p>然后回到unity界面上将要导入的场景路径(GameSceneSO资源)进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174353091.png" alt="image-20231015174353091"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174408738.png" alt="image-20231015174408738"></p><p>同时为了方便调取<strong>主要场景</strong>(游戏开始的最初场景)和<strong>资源场景</strong>，回到枚举脚本<code>Enums</code>下创建新的枚举对象：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122032738.png" alt="image-20231016122032738"></p><p>同时在场景资源加载事件<code>GameSceneSO</code>下创建对应类的引用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122311710.png" alt="image-20231016122311710"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122339454.png" alt="image-20231016122339454"></p><p>回到unity界面上，在传送容器<code>Teleport</code>下的传送脚本<code>Teleport Point</code>内进行修改，创建对应传送类型的引用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122815345.png" alt="image-20231016122815345"></p><p>然后在unity界面上为sceneToGo属性绑定要传送到达的场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016123026074.png" alt="image-20231016123026074"></p><p>回到场景加载事件脚本<code>SceneLoadEventSO</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135432940.png" alt="image-20231016135432940"></p><p>在事件文件夹<code>Events</code>下创建该场景加载事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135808162.png" alt="image-20231016135808162"></p><p>在传送脚本<code>Teleport Point</code>下进行内容的添加，加入加载事件脚本类的引用，然后回到界面上绑定该加载事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135624423.png" alt="image-20231016135624423"></p><p>然后修改代码，将需要的内容发送给事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016140035367.png" alt="image-20231016140035367"></p><p>最后回到场景加载脚本<code>SceneLoader</code>下编写需要的内容，导入场景加载事件脚本类<code>SceneLoadEventSO</code>的引用，同时完成事件的监听(获取场景内容和坐标)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016154448169.png" alt="image-20231016154448169"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160443762.png" alt="image-20231016160443762"></p><p><strong>场景切换事件监听流程：</strong></p><p><strong>SceneLoader → SceneLoaderEventSO→GameSceneSO</strong></p><p>最后实现当前场景卸载和加载新场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160537013.png" alt="image-20231016160537013"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160547441.png" alt="image-20231016160547441"></p><p>最后通过测试还要进行新一步的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016163249020.png" alt="image-20231016163249020"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016163316075.png" alt="image-20231016163316075"></p><h3 id="场景传送-下"><a href="#场景传送-下" class="headerlink" title="场景传送(下)"></a>场景传送(下)</h3><p>场景切换要考虑到场景加载的时间，所以切换时还要进一步地判断场景是否切换完成：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164003956.png" alt="image-20231016164003956"></p><p>判断完成后启用加载后的方法OnLoadCompleted()来为角色在新场景的坐标进行赋值：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164245809.png" alt="image-20231016164245809"></p><p>同时要回到unity界面上绑定角色坐标：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164424490.png" alt="image-20231016164424490"></p><p>细节修改：当进行场景传送时不能一直连续按传送键(交互)，同时传送途中不显示人物，而是人物到达新场景后才显示：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175511464.png" alt="image-20231016175511464"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175531029.png" alt="image-20231016175531029"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175556262.png" alt="image-20231016175556262"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175622640.png" alt="image-20231016175622640"></p><p>接下来就要设置场景切换后的摄像机</p><p>先回到unity界面中创建一个无参传入的广播事件<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182113347.png" alt="image-20231016182113347"></p><p>然后回到场景加载脚本<code>SceneLoad</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182425589.png" alt="image-20231016182425589"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182440469.png" alt="image-20231016182440469"></p><p>同时要回到unity界面上绑定广播事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210827480.png" alt="image-20231016210827480"></p><p>然后在摄像机控制脚本<code>CameraController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182955774.png" alt="image-20231016182955774"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016183042106.png" alt="image-20231016183042106"></p><p>回到unity界面上，在跟随摄像容器(Virtual Camera)身上的摄像控制脚本绑定事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016211038710.png" alt="image-20231016211038710"></p><p>最后回到场景加载脚本<code>SceneLoader</code>下修改其它内容，实现人物刚开始进入场景时在出生点位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210431004.png" alt="image-20231016210431004"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210137488.png" alt="image-20231016210137488"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210201755.png" alt="image-20231016210201755"></p><p>最后也要回到unity界面上设置最初场景的初始值，也就是出生点的位置，同时还要把当前场景设置为空：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016214120620.png" alt="image-20231016214120620"></p><p>最终场景传送的内容脚本总结</p><p>传送门脚本<code>TeleportPoint</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TeleportPoint</span> : <span class="title">MonoBehaviour</span>, <span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SceneLoadEventSO loadEventSO;</span><br><span class="line">    <span class="comment">//要传送到的场景</span></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO sceneToGo;</span><br><span class="line">    <span class="comment">//传送到场景后新出生点的坐标</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 positionToGo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;传送！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        loadEventSO.RaiseLoadRequestEvent(sceneToGo, positionToGo, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>场景加载控制事件脚本<code>SceneLoader</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.AddressableAssets;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.ResourceManagement.AsyncOperations;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.ResourceManagement.ResourceProviders;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 firstPosition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform playerTrans;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> SceneLoadEventSO loadEventSO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO firstLoadScene;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;广播&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> VoidEventSO afterSceneLoadedEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FadeEventSO fadeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO currentLoadScene;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameSceneSO secondLoadScene;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 positionToGo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> fadeScreen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fadeDuration;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Addressables.LoadSceneAsync(firstLoadScene.sceneReference, LoadSceneMode.Additive);</span></span><br><span class="line">        <span class="comment">//currentLoadScene = firstLoadScene;</span></span><br><span class="line">        <span class="comment">//currentLoadScene.sceneReference.LoadSceneAsync(LoadSceneMode.Additive);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        NewGame();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadEventSO.LoadRequestEvent += OnLoadRequestEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadEventSO.LoadRequestEvent -= OnLoadRequestEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        secondLoadScene = firstLoadScene;</span><br><span class="line">        OnLoadRequestEvent(secondLoadScene, firstPosition, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     场景资源加载请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;locationToLoad&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;posToGo&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fadeScreen&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadRequestEvent</span>(<span class="params">GameSceneSO locationToLoad, Vector3 posToGo, <span class="built_in">bool</span> fadeScreen</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoading)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        secondLoadScene = locationToLoad;</span><br><span class="line">        positionToGo = posToGo;</span><br><span class="line">        <span class="keyword">this</span>.fadeScreen= fadeScreen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Debug.Log(secondLoadScene.sceneReference.SubObjectName);</span></span><br><span class="line">        <span class="keyword">if</span> (currentLoadScene != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(UnLoadPreviousScene());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LoadNewScene();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卸载当前场景</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UnLoadPreviousScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fadeScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//TOOD: 实现渐入渐出</span></span><br><span class="line">            fadeEvent.FadeIn(fadeDuration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">fadeDuration</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> currentLoadScene.sceneReference.UnLoadScene();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭人物</span></span><br><span class="line">        playerTrans.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        LoadNewScene();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载新场景</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadNewScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> loadingOption = secondLoadScene.sceneReference.LoadSceneAsync(LoadSceneMode.Additive,<span class="literal">true</span>);</span><br><span class="line">        loadingOption.Completed += OnLoadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadCompleted</span>(<span class="params">AsyncOperationHandle&lt;SceneInstance&gt; obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentLoadScene = secondLoadScene;</span><br><span class="line"></span><br><span class="line">        playerTrans.position = positionToGo;</span><br><span class="line">        <span class="comment">//开启人物</span></span><br><span class="line">        playerTrans.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fadeScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">            fadeEvent.FadeOut(fadeDuration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//场景加载完成后事件</span></span><br><span class="line">        afterSceneLoadedEvent.RaiseEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传递场景加载参数的广播事件脚本<code>SceneLoadEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/SceneLoadEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoadEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;GameSceneSO, Vector3, <span class="built_in">bool</span>&gt; LoadRequestEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 场景加载请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;locationToLoad&quot;&gt;</span>要加载的场景<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;posToGo&quot;&gt;</span>Player的目的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fadeScreen&quot;&gt;</span>是否渐入渐出<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseLoadRequestEvent</span>(<span class="params">GameSceneSO locationToLoad,Vector3 posToGo,<span class="built_in">bool</span> fadeScreen</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadRequestEvent?.Invoke(locationToLoad, posToGo, fadeScreen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递Addressable插件内容挂载资源的广播事件脚本<code>GameSceneSO</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.AddressableAssets;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Game Scene/GameSceneSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameSceneSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SceneType sceneType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AssetReference sceneReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举脚本<code>Enums</code>修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型 —— enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> NPCState</span><br><span class="line">&#123;</span><br><span class="line">    Patrol,Chase,Skill</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SceneType</span><br><span class="line">&#123;</span><br><span class="line">    Location,Menu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参传入的广播事件脚本<code>VoidEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/VoidEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoidEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摄像机控制脚本<code>CameraController</code>修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Cinemachine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraControll</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> VoidEventSO afterSceneLoadedEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CinemachineConfiner2D confiner2D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CinemachineImpulseSource impulseSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VoidEventSO cameraShakeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        confiner2D = GetComponent&lt;CinemachineConfiner2D&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>场景切换后更改</span></span><br><span class="line">    <span class="comment">//private void Start()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    GetNewCameraBounds();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised += OnCameraShakeEvent;</span><br><span class="line">        afterSceneLoadedEvent.OnEventRaised += OnAfterSceneLoadedEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised -= OnCameraShakeEvent;</span><br><span class="line">        afterSceneLoadedEvent.OnEventRaised -= OnAfterSceneLoadedEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAfterSceneLoadedEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取新摄像边界</span></span><br><span class="line">        GetNewCameraBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCameraShakeEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//震动源(启动摄像机震动)</span></span><br><span class="line">        impulseSource.GenerateImpulse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetNewCameraBounds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = GameObject.FindGameObjectWithTag(<span class="string">&quot;Bounds&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        confiner2D.m_BoundingShape2D = obj.GetComponent&lt;Collider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理地图缓存(切换地图)</span></span><br><span class="line">        confiner2D.InvalidateCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景的渐入渐出效果"><a href="#场景的渐入渐出效果" class="headerlink" title="场景的渐入渐出效果"></a>场景的渐入渐出效果</h3><p>首先在unity界面上创建一个新的<code>Canvas</code>容器，并将其优先级设置为最高：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134106498.png" alt="image-20231017134106498"></p><p>其次在该容器下再创建一个图片容器<code>Image</code>，从而实现图片全覆盖：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134235804.png" alt="image-20231017134235804"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134439251.png" alt="image-20231017134439251"></p><p>我们将通过图片全覆盖后对图片的透明度进行变化从而实现场景的渐入渐出效果</p><p>回到Fada canvas容器下，在界面管理文件夹<code>UI</code>下创建新的场景控制脚本<code>FadaCanvas</code>并将其添加在容器下:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134804610.png" alt="image-20231017134804610"></p><p>在进行代码对场景进行编辑前，还要先去unity资源商场下载一款插件——<strong>DOTween</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017135716763.png" alt="image-20231017135716763"></p><p>回到unity中进行资源启用</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144508372.png" alt="image-20231017144508372"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144448540.png" alt="image-20231017144448540"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144420330.png" alt="image-20231017144420330"></p><p>然后回到<code>FadeCanvas</code>脚本下进行添加：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017145206967.png" alt="image-20231017145206967"></p><p>再回到unity界面上，在事件文件夹下创建渐入渐出事件<code>FadeEventSO</code>，从而<strong>实现通过将渐入渐出封装在该事件上，再在场景加载脚本上直接绑定事件，然后广播通知，进而自动在<code>FadeCanvas</code>下实现渐入渐变的效果</strong>：</p><p>渐入渐变事件脚本<code>FadeEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150410377.png" alt="image-20231017150410377"></p><p>然后在场景加载脚本上引用并调用对应的渐入渐出方法(<strong>广播</strong>)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151007285.png" alt="image-20231017151007285"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150658041.png" alt="image-20231017150658041"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150717141.png" alt="image-20231017150717141"></p><p>再回到<code>FadeCanvas</code>下进行<strong>监听</strong>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151318349.png" alt="image-20231017151318349"></p><p>最后回到unity中，先在事件文件夹下创建该事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151526370.png" alt="image-20231017151526370"></p><p>然后分别为广播和监听都进行绑定，其中<code>FadeCavans</code>还需要绑定前边创建的图片容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151546328.png" alt="image-20231017151546328"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151758823.png" alt="image-20231017151758823"></p><p>同时要为渐入渐出的效果设置对应的时间：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151925545.png" alt="image-20231017151925545"></p><p>最终的场景传送脚本代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主场景创建"><a href="#主场景创建" class="headerlink" title="主场景创建"></a>主场景创建</h2><p>动画场景创建按个人喜好来</p><p>快捷键：</p><p><code>V</code>键——移动到左上角后可以让相同素材被切割的几个部分在界面上自动拼合</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023122720008.png" alt="image-20231023122720008"></p><p>在描绘好主场景之后，为其添加<code>Canvas</code>容器并设置全覆盖</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213433336.png" alt="image-20231021213433336"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213454660.png" alt="image-20231021213454660"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213559382.png" alt="image-20231021213559382"></p><ul><li>创建开始字幕</li></ul><p>然后在<code>Canvas</code>容器下创建文本容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023104059743.png" alt="image-20231023104059743"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105015699.png" alt="image-20231023105015699"></p><p>在网上下载需要的中文字体（这里以得意黑字体举例），在资源文件夹下再创建一个新的存放字体文件的文件夹<code>Fonts</code>并存放字体资源(.ttf)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105426920.png" alt="image-20231023105426920"></p><p>然后右键字体，创建对应的画布字体资源文件，然后再回到文本容器上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105801942.png" alt="image-20231023105801942"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105847622.png" alt="image-20231023105847622"></p><p>由于中文的特殊性是逐个汉字进行渲染，所以当文字过多或者超出可能会导致部分渲染失败，可以在以下设置进行调整和更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023110003779.png" alt="image-20231023110003779"></p><ul><li>创建开始按钮</li></ul><p>在<code>Canvas</code>容器下创建UI界面的开始按钮：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023111136955.png" alt="image-20231023111136955"></p><p>也可以是创建文字容器，最后再手动添加按钮组件即可</p><p>快捷键：</p><p><code>T</code>键 —— 拖动蓝色控制点边框调整大小</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023122402976.png" alt="image-20231023122402976"></p><p>创建多个文字容器并创建一个父容器来控制它们的大小或间距：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023133929965.png" alt="image-20231023133929965"></p><p>为父容器添加<code>Vertical Layout Group</code>从而来精细调控子容器间的间距，大小，排布等等</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023134108321.png" alt="image-20231023134108321"></p><p>然后为子容器各自添加按钮组件并设置颜色：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023134852879.png" alt="image-20231023134852879"></p><p>回到unity界面上设置主场景，让加载脚本绑定初始加载的场景：</p><p>先在场景加载文件夹<code>Game Scenes</code>下创建：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135232791.png" alt="image-20231023135232791"></p><p>然后在<code>Addressables Groups</code>下挂载主场景资源：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135401630.png" alt="image-20231023135401630"></p><p>再回到场景加载文件夹下进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135517470.png" alt="image-20231023135517470"></p><p>最后回到<code>SceneLoad Manager</code>下绑定初始场景为该主场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135627010.png" alt="image-20231023135627010"></p><h3 id="主场景加载无法移动"><a href="#主场景加载无法移动" class="headerlink" title="主场景加载无法移动"></a>主场景加载无法移动</h3><p>正常游戏刚开始的画面都无法移动，同时场景切换时也不让角色移动，所以要进行限制，回到角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142530696.png" alt="image-20231023142530696"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142557854.png" alt="image-20231023142557854"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142627332.png" alt="image-20231023142627332"></p><p>同时为了使主场景时角色不能控制，所以要在场景加载脚本<code>SceneLoader</code>下添加代码：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023143829077.png" alt="image-20231023143829077"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023144939961.png" alt="image-20231023144939961"></p><p>同时回到unity界面，在角色容器对应的组件绑定相应的事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145033925.png" alt="image-20231023145033925"></p><p>这样就实现了主场景下人物无法移动</p><h3 id="主场景不加载人物UI界面"><a href="#主场景不加载人物UI界面" class="headerlink" title="主场景不加载人物UI界面"></a>主场景不加载人物UI界面</h3><p>正常游戏开始不会出现人物血条，人物属性，能量条等信息，所以要对人物UI界面也进行修改，在<code>UI Manager</code>容器下对其组件进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145638941.png" alt="image-20231023145638941"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145925602.png" alt="image-20231023145925602"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023150150042.png" alt="image-20231023150150042"></p><p>最后回到unity界面中，在UI容器上对应的脚本进行事件绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023150334774.png" alt="image-20231023150334774"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十一）</title>
      <link href="/2023/09/13/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2023/09/13/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十一"><a href="#Unity开发日记-十一" class="headerlink" title="Unity开发日记(十一)"></a>Unity开发日记(十一)</h1><h2 id="摄像机跟随"><a href="#摄像机跟随" class="headerlink" title="摄像机跟随"></a>摄像机跟随</h2><p>首先下载一个摄像机跟随的工具，在unity界面上选择<code>Window</code>→<code>Package Manager</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913093934893.png" alt="image-20230913093934893"></p><p>创建摄像机并绑定要跟随的对象：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913131801585.png" alt="image-20230913131801585"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913131824148.png" alt="image-20230913131824148"></p><p>同时还可以调整摄像机跟随的点位位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913173915500.png" alt="image-20230913173915500"></p><p>还可以设置缓冲边框，实现渐进效果</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174032813.png" alt="image-20230913174032813"></p><h3 id="摄像机限制范围"><a href="#摄像机限制范围" class="headerlink" title="摄像机限制范围"></a>摄像机限制范围</h3><p>摄像机的区域要进行限制，以免在游玩过程中摄像机可以看到地图场景外的内容</p><p>首先在摄像机组件下进行设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174513294.png" alt="image-20230913174513294"></p><p>查看添加的内容，我们需要为其绑定摄像机能够移动的范围：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174744591.png" alt="image-20230913174744591"></p><p>所以先回到unity界面上设置一个空的容器并且添加新的2D碰撞体(要设置为 is Trigger)，然后画出我们需要的边界线，最后绑定上去：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174926165.png" alt="image-20230913174926165"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174953783.png" alt="image-20230913174953783"></p><p>设置自动绑定摄像机限制范围，从而实现当场景切换时相机也跟着切换且不越界</p><p>先创建一个Bounds图层并绑定Bounds容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913175627791.png" alt="image-20230913175627791"></p><p>然后在<code>Utilities</code>文件夹下创建摄像机控制脚本<code>CameraController</code>并将其绑定在摄像机容器上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913195147274.png" alt="image-20230913195147274"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913195131169.png" alt="image-20230913195131169"></p><h3 id="摄像机震动-攻击抖动"><a href="#摄像机震动-攻击抖动" class="headerlink" title="摄像机震动(攻击抖动)"></a>摄像机震动(攻击抖动)</h3><p>目的：实现人物被攻击时，摄像机会震动，从而达到一个比较好的动作游戏的表达效果</p><p>首先在摄像机的组件下添加新的<code>Extensions</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913200203463.png" alt="image-20230913200203463"></p><p>同时进行设置</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201251081.png" alt="image-20230913201251081"></p><p>而镜头的震动还需要有一个震动源，所以要创建一个容器并绑定一个震动源脚本(内置)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201548970.png" alt="image-20230913201548970"></p><p>调试一个合适的震动效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201646885.png" alt="image-20230913201646885"></p><p>然后回到摄像机脚本<code>CameraController</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913202414071.png" alt="image-20230913202414071"></p><p>回到unity界面上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913202441684.png" alt="image-20230913202441684"></p><p>为了实现怪物受击，人物受击都能有相应的效果，我们可以通过事件处理器(EventSO)来实现（分为广播方和监听方）</p><ul><li>广播</li></ul><p>先在<code>ScriptableObject</code>下创建一个新的不需要参数传入的事件订阅类<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203001513.png" alt="image-20230913203001513"></p><p>再次切回到unity界面中，在资源存储文件夹<code>Event</code>下创建对应的<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203112169.png" alt="image-20230913203112169"></p><p>回到事件订阅类<code>VoidEventSO</code>中进行代码逻辑的完善：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203606488.png" alt="image-20230913203606488"></p><p>然后为角色和怪物的受伤和死亡事件也都绑定该广播：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204014978.png" alt="image-20230913204014978"></p><ul><li>监听方</li></ul><p>回到摄像机控制脚本<code>CameraControl</code>下进行逻辑的编写：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204804642.png" alt="image-20230913204804642"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204827111.png" alt="image-20230913204827111"></p><p>最后回到unity界面为监听内容绑定对应的震动脚本和事件资源：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913205140944.png" alt="image-20230913205140944"></p><h2 id="音源设置和音效播放"><a href="#音源设置和音效播放" class="headerlink" title="音源设置和音效播放"></a>音源设置和音效播放</h2><p>在这里主要采用了unity社区中的免费音效<code>Free Casual Music Pack</code>以及<code>FREE Casual Game SFX Pack</code></p><p>下载完成资源后回到unity界面上，通过<code>Window</code>→<code>Package Manager</code>进入里边进行导入资源(Import)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103156490.png" alt="image-20230914103156490"></p><p>在<code>Assets</code>主文件夹下再创建一个放置这些音乐文件的文件包<code>Audio</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103422559.png" alt="image-20230914103422559"></p><p>然后在界面中创建一个新的容器作为音乐播放器<code>Audio Manager</code>，并为其绑定核心的广播组件<code>Audio Source</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103907754.png" alt="image-20230914103907754"></p><p><strong>该组件相当于用于绑定对应的音频片段并广播出去，而要想听到音频则需要有对应的监听(Audio Listener)，回到相机上可以发现当初创建的时候就默认带有一个<code>Audio Listener</code>组件，所以相当于让摄像机来监听音频从而实现我们能够在游玩过程听到不同的音乐，也可以根据距离的不同收到不同的音乐这种效果</strong></p><p>让广播组件绑定要播放的背景音乐并测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914104304214.png" alt="image-20230914104304214"></p><p>同时要把设置中<code>Loop</code>也打勾，从而让bgm可以循环播放</p><p>为音乐播放器<code>Audio Manager</code>再添加一个<code>Audio Source</code>组件作为绑定音效的组件，然后进行设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914111204123.png" alt="image-20230914111204123"></p><h3 id="音效播放"><a href="#音效播放" class="headerlink" title="音效播放"></a>音效播放</h3><p>回到<code>Script</code>文件下创建放置音效相关脚本的<code>Audio</code>文件夹，创建我们需要用到的音效控制脚本<code>AudioManager</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914105951743.png" alt="image-20230914105951743"></p><p>然后回到unity界面上为音频控制器添加控制脚本并分别绑定对应的两个组件:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914111333768.png" alt="image-20230914111333768"></p><p>接下来就是要创建传递音频文件的事件(<strong>广播和监听</strong>)，通过攻击的时候广播出去通知音频播放器这时要播放相对应的音效</p><ul><li>广播</li></ul><p>先在事件文件夹<code>ScriptableObject</code>下创建需要的玩家音频广播事件<code>PlayAudioEventSO</code>并编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914171955372.png" alt="image-20230914171955372"></p><p>然后回到unity界面上创建对应的<code>Event</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914203118417.png" alt="image-20230914203118417"></p><p>再复制一个并都将其改名：<img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914203139056.png" alt="image-20230914203139056"></p><p>再回到<code>Script</code>文件下创建新的音频自定义脚本<code>AudioDefination</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204028669.png" alt="image-20230914204028669"></p><p>然后挂载到三段攻击上并进行对应数值的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204240340.png" alt="image-20230914204240340"></p><ul><li>监听(接收)</li></ul><p>回到<code>Audio Manager</code>下的音频监听脚本<code>AudioManager</code>中进行修改:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204951311.png" alt="image-20230914204951311"></p><p>再次回到unity界面上进行绑定然后测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914205026950.png" alt="image-20230914205026950"></p><p>然后继续在音频监听脚本<code>AudioManager</code>下添加bgm的设置内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915223521545.png" alt="image-20230915223521545"></p><p>回到unity上创建一个新的容器命名为BGM，然后为其添加音频广播脚本<code>Audio Defination</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915223808211.png" alt="image-20230915223808211"></p><h3 id="音乐混音"><a href="#音乐混音" class="headerlink" title="*音乐混音"></a>*音乐混音</h3><p>首先要先打开混音的界面：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224107006.png" alt="image-20230915224107006"></p><p>然后在<code>Setting</code>文件夹下也创建放置混音内容的<code>Audio Mixers</code>文件夹，同时在文件夹下创建第一个混音内容<code>MainMixer</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224323024.png" alt="image-20230915224323024"></p><p>在混音调音台中创建新的音轨放置不同的音乐：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224510796.png" alt="image-20230915224510796"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224646357.png" alt="image-20230915224646357"></p><p>然后在音频广播的位置选择音乐播放要在哪个轨道上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224918064.png" alt="image-20230915224918064"></p><p>这样就可以在混音界面上进行调整了，同时可以通过主轨道的声音进一步影响后边两个音轨的声音</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915225228908.png" alt="image-20230915225228908"></p><p>内容总结：</p><p>摄像机控制脚本<code>CameraController</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Cinemachine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraControll</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CinemachineConfiner2D confiner2D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CinemachineImpulseSource impulseSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VoidEventSO cameraShakeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        confiner2D = GetComponent&lt;CinemachineConfiner2D&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>场景切换后更改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetNewCameraBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised += OnCameraShakeEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised -= OnCameraShakeEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCameraShakeEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//震动源(启动摄像机震动)</span></span><br><span class="line">        impulseSource.GenerateImpulse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetNewCameraBounds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = GameObject.FindGameObjectWithTag(<span class="string">&quot;Bounds&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        confiner2D.m_BoundingShape2D = obj.GetComponent&lt;Collider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理地图缓存(切换地图)</span></span><br><span class="line">        confiner2D.InvalidateCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摄像机事件处理器广播<code>VoidEventSO</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/VoidEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoidEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音效控制脚本<code>AudioManager</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Audio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO FXEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO BGMEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioSource BGMSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioSource FXSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXEvent.OnEventRaised += OnFXEvent;</span><br><span class="line">        BGMEvent.OnEventRaised += OnBGMEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXEvent.OnEventRaised -= OnFXEvent;</span><br><span class="line">        BGMEvent.OnEventRaised -= OnBGMEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBGMEvent</span>(<span class="params">AudioClip clip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BGMSource.clip = clip;</span><br><span class="line">        BGMSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFXEvent</span>(<span class="params">AudioClip clip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXSource.clip = clip;</span><br><span class="line">        FXSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音频广播事件<code>PlayAudioEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Event/PlayAudioEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayAudioEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;AudioClip&gt; OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params">AudioClip audioClip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke(audioClip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音频自定义脚本<code>AudioDefination</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioDefination</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO playAudioEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioClip audioClip;</span><br><span class="line">    <span class="comment">//判断是否是音效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> playOnEnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (playOnEnable)</span><br><span class="line">            PlayAudioClip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayAudioClip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playAudioEvent.OnEventRaised(audioClip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水和荆棘的逻辑实现"><a href="#水和荆棘的逻辑实现" class="headerlink" title="水和荆棘的逻辑实现"></a>水和荆棘的逻辑实现</h2><p>首先先设计我们需要的场景</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007145827523.png" alt="image-20231007145827523"></p><p>同时勾选设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007165732022.png" alt="image-20231007165732022"></p><p>然后为水池添加一个新的标签(Tags)，为了便于后续实现当人物落到水池则直接死亡</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007165929656.png" alt="image-20231007165929656"></p><p>在人物属性脚本<code>Character</code>下设置新的进入Trigger状态后执行的死亡方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007170837380.png" alt="image-20231007170837380"></p><p>在画面中设置荆棘</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007205935279.png" alt="image-20231007205935279"></p><p>同时为了要让整个荆棘当做一个整体来作为一个碰撞体积，需要添加碰撞组件并调整<code>Tilemap Collider 2D</code>组件内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211305001.png" alt="image-20231007211305001"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211344528.png" alt="image-20231007211344528"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007212722990.png" alt="image-20231007212722990"></p><p>通过直接为荆棘添加攻击组件来实现荆棘的逻辑效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211700323.png" alt="image-20231007211700323"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2023/09/12/%E9%80%92%E5%BD%92/"/>
      <url>/2023/09/12/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十）</title>
      <link href="/2023/09/06/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2023/09/06/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="unity开发日记（十）"><a href="#unity开发日记（十）" class="headerlink" title="unity开发日记（十）"></a>unity开发日记（十）</h1><h2 id="滑墙及蹬墙跳的实现"><a href="#滑墙及蹬墙跳的实现" class="headerlink" title="滑墙及蹬墙跳的实现"></a>滑墙及蹬墙跳的实现</h2><h3 id="滑墙"><a href="#滑墙" class="headerlink" title="滑墙"></a>滑墙</h3><ul><li>动画部分</li></ul><p>先处理蹬墙跳的动画素材，然后创建一个新的动画进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911084804301.png" alt="image-20230911084804301"></p><p>然后创建需要的判断条件<code>onWall</code>并在动画控制器上进行连接：</p><p><strong>跳跃(前提)→蹬墙跳</strong></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911085041195.png" alt="image-20230911085041195"></p><p><strong>蹬墙跳→落地</strong></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911085148934.png" alt="image-20230911085148934"></p><ul><li>代码部分</li></ul><p>回到物理检测脚本<code>PhysicsCheck</code>上进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090100598.png" alt="image-20230911090100598"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090200097.png" alt="image-20230911090200097"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090325424.png" alt="image-20230911090325424"></p><p>然后到角色动画控制器脚本<code>PlayerAnimation</code>上进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090736730.png" alt="image-20230911090736730"></p><p>随后回到unity界面上进行测试，会发现一个问题：人物在滑墙的时候会一直不断地在滑墙动画和跳跃动画反复切换</p><p>所以要再回到动画控制器上给跳跃动画添加一个新的约束条件：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090918890.png" alt="image-20230911090918890"></p><p>进行测试后会发现另外一个新的问题：当角色按住方向键再按跳跃键时不会有动画出现</p><p>所以要再回到物理检测脚本<code>PhysicsCheck</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092102517.png" alt="image-20230911092102517"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092118842.png" alt="image-20230911092118842"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092207254.png" alt="image-20230911092207254"></p><p>同时为了限制滑墙下降的速度变慢，要回到角色控制器<code>PlayerController</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092702304.png" alt="image-20230911092702304"></p><p>细节修改：</p><p>回到unity界面上，切换scence界面查看会发现当人物进行滑墙跳的时候，由于碰撞体没有被改变，所以</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093121486.png" alt="image-20230911093121486"></p><p>人物还没完全滑下去的时候就先变成落地状态，回到物理检测脚本<code>PhysicsCheck</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093446461.png" alt="image-20230911093446461"></p><p>然后回到unity界面上为y轴的偏移量和检测半径也进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093606077.png" alt="image-20230911093606077"></p><h3 id="蹬墙跳"><a href="#蹬墙跳" class="headerlink" title="蹬墙跳"></a>蹬墙跳</h3><p>在角色控制器<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911094926713.png" alt="image-20230911094926713"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095006072.png" alt="image-20230911095006072"></p><p>回到unity进行测试，会发现一个问题：角色蹬墙跳后立刻又会贴墙，原因是：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095216404.png" alt="image-20230911095216404"></p><p>导致人物蹬墙跳的时候又被按了回去，所以还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095527324.png" alt="image-20230911095527324"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095550610.png" alt="image-20230911095550610"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095606598.png" alt="image-20230911095606598"></p><p>这样做可以成功实现蹬墙跳，但是落地后就不能动了，因为我们只设置了<code>wallJump</code>为true，还没有设置它实现后改为false，但这个部分还有一个需求：当蹬墙跳到最高点开始下落的时候，人物还能控制左右方向，所以要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095950075.png" alt="image-20230911095950075"></p><p>这样就完全实现了蹬墙跳</p><h2 id="滑铲的动画与逻辑实现"><a href="#滑铲的动画与逻辑实现" class="headerlink" title="滑铲的动画与逻辑实现"></a>滑铲的动画与逻辑实现</h2><h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>先实现动画，滑铲动画主要有两个阶段：滑铲准备阶段 → 滑铲阶段</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912134944157.png" alt="image-20230912134944157"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912135640663.png" alt="image-20230912135640663"></p><p>然后在动画控制器中创建新的图层并创建空容器：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912140425790.png" alt="image-20230912140425790"></p><p>创建判断条件值<code>isSlide</code>，同时进行动画之间的连接：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912141048864.png" alt="image-20230912141048864"></p><p>同时也要把滑铲的第一个阶段动画的循环取消了：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912152037613.png" alt="image-20230912152037613"></p><p>回到角色控制监听器<code>PlayerInputControl</code>上进行新按键的设置和绑定：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912142319098.png" alt="image-20230912142319098"></p><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><p>回到角色控制脚本<code>PlayerController</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151037898.png" alt="image-20230912151037898"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151053410.png" alt="image-20230912151053410"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151123539.png" alt="image-20230912151123539"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151156351.png" alt="image-20230912151156351"></p><p>携程部分：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151828822.png" alt="image-20230912151828822"></p><p><strong><code>Rigidbody2D.MovePosition</code>是 Unity 中用于移动 2D 刚体的方法之一</strong>。它的主要作用是将刚体移动到指定的位置，同时自动处理碰撞和物理引擎的交互</p><p>然后回到角色动画控制脚本，添加滑铲动画的设置：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151858445.png" alt="image-20230912151858445"></p><p>经过测试发现还有新的问题</p><ul><li>掉入悬崖时滑动动画没有退出</li><li>滑铲时遇到怪物还是会受到伤害</li></ul><p>修改：</p><p>第一个问题只要把携程退出的语句改了即可：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153704765.png" alt="image-20230912153704765"></p><p>第二个问题则需要添加新的代码逻辑，在这里可以使用让角色所在的图层切换为怪物图层从而实现不会受伤害的效果：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153932452.png" alt="image-20230912153932452"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153945828.png" alt="image-20230912153945828"></p><p>再次进行测试，发现还有细节要进行修改：</p><ul><li>跳跃过程中可以滑铲</li><li>碰到墙壁后不能往反方向滑铲</li></ul><p>所以还要对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912195742826.png" alt="image-20230912195742826"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912195818821.png" alt="image-20230912195818821"></p><p>同时为了能让跳跃可以打断滑铲动作，还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912200314819.png" alt="image-20230912200314819"></p><h4 id="通过能量条使用滑铲"><a href="#通过能量条使用滑铲" class="headerlink" title="通过能量条使用滑铲"></a>通过能量条使用滑铲</h4><p>先在角色属性脚本<code>Character</code>上添加新的代码：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202005330.png" alt="image-20230912202005330"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203828639.png" alt="image-20230912203828639"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202028240.png" alt="image-20230912202028240"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202042203.png" alt="image-20230912202042203"></p><p>然后再到角色状态栏脚本<code>PlayerStatBar</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203505094.png" alt="image-20230912203505094"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203533848.png" alt="image-20230912203533848"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203551005.png" alt="image-20230912203551005"></p><p>然后再到UI界面脚本<code>UIManager</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203639132.png" alt="image-20230912203639132"></p><p>最后回到角色控制脚本<code>PlayerController</code>上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912204158362.png" alt="image-20230912204158362"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912204230911.png" alt="image-20230912204230911"></p><p>滑铲的能量条具体的流程为：</p><p><code>PlayerController</code>的Slide方法 → <code>Character</code>的OnSlide方法 → <code>UIManager</code>的OnHealthEvent方法 → <code>PlayerStatBar</code>的OnPowerChange方法</p><p>最后测试发现当滑铲能量条结束后还可以继续滑铲，所以要再进行细节修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912210322258.png" alt="image-20230912210322258"></p><p>最终代码总结</p><p>物理检测脚本<code>PhysicsCheck</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//判断是手动还是自动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> manual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是挂载在角色身上而不是怪物身上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPlayer;</span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 leftOffset;</span><br><span class="line">    <span class="keyword">public</span> Vector2 rightOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> onWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchLeftWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchRightWall;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        rb= GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        <span class="comment">//自动</span></span><br><span class="line">        <span class="keyword">if</span>(!manual)</span><br><span class="line">        &#123;</span><br><span class="line">            rightOffset = <span class="keyword">new</span> Vector2((coll.bounds.size.x + coll.offset.x) / <span class="number">2</span>, coll.bounds.size.y / <span class="number">2</span>);</span><br><span class="line">            leftOffset = <span class="keyword">new</span> Vector2(-rightOffset.x, rightOffset.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        <span class="keyword">if</span> (onWall)</span><br><span class="line">            isGround = Physics2D.OverlapCircle((Vector2)transform.position + <span class="keyword">new</span> Vector2(bottomOffset.x * transform.localScale.x, bottomOffset.y), checkReduis, groundLayer);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            isGround = Physics2D.OverlapCircle((Vector2)transform.position + <span class="keyword">new</span> Vector2(bottomOffset.x * transform.localScale.x, <span class="number">0</span>), checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//墙体判断</span></span><br><span class="line">        touchLeftWall = Physics2D.OverlapCircle((Vector2)transform.position + leftOffset, checkReduis, groundLayer);</span><br><span class="line">        touchRightWall = Physics2D.OverlapCircle((Vector2)transform.position + rightOffset, checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在墙壁上</span></span><br><span class="line">        <span class="keyword">if</span> (isPlayer)</span><br><span class="line">            onWall = (touchLeftWall &amp;&amp; playerController.inputDirection.x &lt; <span class="number">0f</span> || touchRightWall &amp;&amp; playerController.inputDirection.x &gt; <span class="number">0f</span>) &amp;&amp; rb.velocity.y&lt;<span class="number">0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + leftOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + rightOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色控制脚本<code>PlayerController</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Character character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerAnimation playerAnimation;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跑步速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//行走速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳跃的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反弹力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//蹬墙跳的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> wallJumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> slideDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> slideSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲消耗的能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> slidePowerCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞体的两个变量(大小和位移)</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;物理材质&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> PhysicsMaterial2D normal;</span><br><span class="line">    <span class="keyword">public</span> PhysicsMaterial2D wall;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//是否下蹲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isAttack;</span><br><span class="line">    <span class="comment">//是否蹬墙跳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wallJump;</span><br><span class="line">    <span class="comment">//是否滑铲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isSlide;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        playerAnimation = GetComponent&lt;PlayerAnimation&gt;();</span><br><span class="line"></span><br><span class="line">        character = GetComponent&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳跃</span></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line">        <span class="comment">//攻击</span></span><br><span class="line">        inputControl.GamePlay.Attack.started += PlayerAttack;</span><br><span class="line">        <span class="comment">//滑铲</span></span><br><span class="line">        inputControl.GamePlay.Slide.started += Slide;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">        CheckState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isAttack)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isCrouch &amp;&amp; !wallJump)</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色跳跃对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打断滑铲携程</span></span><br><span class="line">            isSlide = <span class="literal">false</span>;</span><br><span class="line">            StopAllCoroutines();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (physicsCheck.onWall)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(-inputDirection.x,<span class="number">2.2f</span>)*wallJumpForce, ForceMode2D.Impulse);</span><br><span class="line">            wallJump = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色攻击对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerAttack</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!physicsCheck.isGround)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        playerAnimation.PlayAttack();</span><br><span class="line">        isAttack= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Slide</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isSlide &amp;&amp; physicsCheck.isGround &amp;&amp; character.currentPower&gt;=slidePowerCost)</span><br><span class="line">        &#123;</span><br><span class="line">            isSlide=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//滑铲的目标点</span></span><br><span class="line">            <span class="keyword">var</span> targetPos = <span class="keyword">new</span> Vector3(transform.position.x + slideDistance * transform.localScale.x, transform.position.y);</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Enemy&quot;</span>);</span><br><span class="line">            <span class="comment">//启动携程</span></span><br><span class="line">            StartCoroutine(TriggerSlide(targetPos));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//滑铲消耗能量</span></span><br><span class="line">        character.OnSlide(slidePowerCost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">TriggerSlide</span>(<span class="params">Vector3 target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!physicsCheck.isGround)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.touchLeftWall &amp;&amp; transform.localScale.x &lt; <span class="number">0f</span>|| physicsCheck.touchRightWall &amp;&amp; transform.localScale.x &gt; <span class="number">0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isSlide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不断移动</span></span><br><span class="line">            rb.MovePosition(<span class="keyword">new</span> Vector2(transform.position.x + transform.localScale.x * slideSpeed, transform.position.y));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (MathF.Abs(target.x - transform.position.x) &gt; <span class="number">0.1f</span>);</span><br><span class="line"></span><br><span class="line">        isSlide = <span class="literal">false</span>;</span><br><span class="line">        gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> UnityEvent</span></span><br><span class="line">    <span class="comment">//角色受伤对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GerHurt</span>(<span class="params">Transform attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2((transform.position.x - attacker.position.x), <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色死亡对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerDead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">        inputControl.GamePlay.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll.sharedMaterial = physicsCheck.isGround ? normal : wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (physicsCheck.onWall)</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(rb.velocity.x, rb.velocity.y / <span class="number">2f</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(rb.velocity.x, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wallJump &amp;&amp; rb.velocity.y&lt;<span class="number">0f</span>)</span><br><span class="line">            wallJump = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>属性脚本<code>Character</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    <span class="comment">//最大能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxPower;</span><br><span class="line">    <span class="comment">//当前能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentPower;</span><br><span class="line">    <span class="comment">//能量恢复速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> powerRecoverSpeed;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//掉血事件(传递给人物状态栏)</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Character&gt; OnHealthChange;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">        <span class="comment">//初始化能量</span></span><br><span class="line">        currentPower= maxPower;</span><br><span class="line">        <span class="comment">//初始化血条(广播到血条状态栏脚本上)</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能量恢复</span></span><br><span class="line">        <span class="keyword">if</span>(currentPower &lt; maxPower)</span><br><span class="line">        &#123;</span><br><span class="line">            currentPower += Time.deltaTime * powerRecoverSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//血条变化广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSlide</span>(<span class="params"><span class="built_in">int</span> cost</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入character&quot; + cost);</span></span><br><span class="line">        <span class="comment">//能量消耗</span></span><br><span class="line">        currentPower -= cost;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入character&quot; + currentPower);</span></span><br><span class="line">        <span class="comment">//能量恢复广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI控制脚本<code>UIManager</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerStatBar playerStatBar;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> CharacterEventSO healthEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised += OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised -= OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> persentage = character.currentHealth / character.maxHealth;</span><br><span class="line">        playerStatBar.OnHealthChange(persentage);</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入UIManager&quot;);</span></span><br><span class="line">        playerStatBar.OnPowerChange(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色状态栏脚本<code>PlayerStatBar</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerStatBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Character currentCharacter;</span><br><span class="line">    <span class="comment">//血条(绿色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthImage;</span><br><span class="line">    <span class="comment">//血条渐变(红色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthDelayImage;</span><br><span class="line">    <span class="comment">//能量条(黄色)</span></span><br><span class="line">    <span class="keyword">public</span> Image powerImage;</span><br><span class="line">    <span class="comment">//能量是否正在恢复</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isRecovering;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(healthDelayImage.fillAmount &gt; healthImage.fillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            healthDelayImage.fillAmount -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isRecovering)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> persentage = currentCharacter.currentPower / currentCharacter.maxPower;</span><br><span class="line">            powerImage.fillAmount = persentage;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;进入能量条&quot;+persentage);</span></span><br><span class="line">            <span class="keyword">if</span> (persentage &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isRecovering= <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收Health的变更百分比</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;persentage&quot;&gt;</span>百分比：Current/Max<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params"><span class="built_in">float</span> persentage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthImage.fillAmount= persentage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPowerChange</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入PlayerStatBar&quot;);</span></span><br><span class="line">        isRecovering = <span class="literal">true</span>;</span><br><span class="line">        currentCharacter= character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（九）</title>
      <link href="/2023/09/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2023/09/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（九）"><a href="#Unity开发日记（九）" class="headerlink" title="Unity开发日记（九）"></a>Unity开发日记（九）</h1><h2 id="创建人物状态栏"><a href="#创建人物状态栏" class="headerlink" title="创建人物状态栏"></a>创建人物状态栏</h2><p>先到unity asset store下安装一个工具：<a href="https://assetstore.unity.com/packages/tools/utilities/colourful-hierarchy-category-gameobject-205934">https://assetstore.unity.com/packages/tools/utilities/colourful-hierarchy-category-gameobject-205934</a></p><p>回到unity中进行安装：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230901140357378.png" alt="image-20230901140357378"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230901140430004.png" alt="image-20230901140430004"></p><p>找到模组文件夹进行配置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904085740719.png" alt="image-20230904085740719"></p><p>根据个人喜好进行配置，然后回到unity界面上查看效果</p><p>接下来就是创建人物状态栏</p><p>首先要创建UI内容：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904090349034.png" alt="image-20230904090349034"></p><p>完成创建后可以发现会自动给我们多创建了一个<code>EventSystem</code>，我们先查看到<code>EventSystem</code>并进行配置的更改：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904090539144.png" alt="image-20230904090539144"></p><p>查看<code>Caven</code>画布：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091026593.png" alt="image-20230904091026593"></p><p>可以看出画布是独立于游戏画面的，这样可以避免不同设备ui界面不同</p><p>然后配置UI布局，选择根据我们的游戏场景来进行配置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091319040.png" alt="image-20230904091319040"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091541653.png" alt="image-20230904091541653"></p><p>在画布下创建图片，同时设置<code>锚点</code></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091809036.png" alt="image-20230904091809036"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091934563.png" alt="image-20230904091934563"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092354864.png" alt="image-20230904092354864"></p><p>通过<code>Alt +shift</code>键将图片定位到锚点处</p><p>锚点的作用：</p><p>通过<code>W</code>键来移动图片</p><h3 id="编辑人物状态栏"><a href="#编辑人物状态栏" class="headerlink" title="编辑人物状态栏"></a>编辑人物状态栏</h3><h4 id="血条和能量条"><a href="#血条和能量条" class="headerlink" title="血条和能量条"></a>血条和能量条</h4><p>首先对UI界面的画面素材进行切割：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092801447.png" alt="image-20230904092801447"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092827772.png" alt="image-20230904092827772"></p><p>然后手动进行切割的调整并保存，将切割完成的动画放置并进行调整：</p><p>当设置好图片后可以点击<code>Set Native Size</code>进行自动适应我们画布大小的调整，然后我们再进行手动的调整</p><ul><li>血条框架(Health Frame)</li></ul><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094215713.png" alt="image-20230904094215713"></p><ul><li>血条(Health Fill Green)</li></ul><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094441611.png" alt="image-20230904094441611"></p><p>血条要设置一个渐变效果：从右往左逐渐减少，所以要设置新的配置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094706811.png" alt="image-20230904094706811"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094738429.png" alt="image-20230904094738429"></p><ul><li>血条渐变(Health Fill Red)</li></ul><p>复制粘贴Health Fill Green，然后将图片素材换成红色血条的图片素材即可</p><p>将以上内容归为画布下一个模块，创建父类容器，同时调整大小：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095336189.png" alt="image-20230904095336189"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095327038.png" alt="image-20230904095327038"></p><p>父类容器锚点定位在左上角，同时按<code>Alt</code>键连同容器也是在锚点位置，设定好框架后方便对下边的子容器进行移动和调整</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095457420.png" alt="image-20230904095457420"></p><p>同样方法创建能量条</p><h4 id="人物头像"><a href="#人物头像" class="headerlink" title="人物头像"></a>人物头像</h4><p>首先创建人物头像框架<code>Player Face</code></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904100538300.png" alt="image-20230904100538300"></p><p>再创建一个包含了两种能量条和头像的父类容器，方便进行调整：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904100836152.png" alt="image-20230904100836152"></p><p>然后再创建人物头像，由于没有头像素材，所以可以用其他方式进行切割：</p><p>1、定义一个新的图片空素材<code>Cut</code>方便接下来的切割，作为中间层</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101139914.png" alt="image-20230904101139914"></p><p>2、定义一个头像的图片放在<code>Cut</code>下，并调整大小且移动位置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101354444.png" alt="image-20230904101354444"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101409943.png" alt="image-20230904101409943"></p><p>3、回到中间层<code>Cut</code>为其添加一个<code>Mask</code>组件并进行设置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101518378.png" alt="image-20230904101518378"></p><p>这样就完成了基本的人物状态栏的设置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101812421.png" alt="image-20230904101812421"></p><h2 id="血量更新逻辑的实现-广播者和监听者"><a href="#血量更新逻辑的实现-广播者和监听者" class="headerlink" title="血量更新逻辑的实现(广播者和监听者)"></a>血量更新逻辑的实现(广播者和监听者)</h2><p>先创建放置UI脚本内容的文件夹，同时编辑第一个UI脚本<code>PlayerStatBar</code>：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904135400171.png" alt="image-20230904135400171"></p><p>为人物状态栏添加该UI脚本，同时绑定图片：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904135609516.png" alt="image-20230904135609516"></p><p>回到脚本中添加获取让血条移动渐变的方法：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904140751449.png" alt="image-20230904140751449"></p><h3 id="广播者"><a href="#广播者" class="headerlink" title="广播者"></a>广播者</h3><p>回到unity中创建资源文件<code>ScriptableObject</code>,并创建需要的脚本<code>CharacterEventSO</code>作为<strong>广播者</strong>:</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905173335931.png" alt="image-20230905173335931"></p><p>然后创建一个事件文件夹<code>Event</code>，并在下边创建一个我们刚创好的资源脚本：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905175250103.png" alt="image-20230905175250103"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905175552911.png" alt="image-20230905175552911"></p><p>接下来就是要实现<strong>当玩家血量掉血时，将玩家的<code>Character</code>基础属性脚本的内容传递到资源文件夹<code>Event</code>下存储玩家资源的<code>CharacterEventSO</code>，最后在人物状态栏下的状态栏脚本<code>Player Stat Bar</code>脚本中启用</strong></p><p>1、首先更改角色属性脚本<code>Character</code>:</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180145106.png" alt="image-20230905180145106"></p><p>2、其次回到unity界面中绑定对应的类和属性将内容广播出去</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180738311.png" alt="image-20230905180738311"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180753145.png" alt="image-20230905180753145"></p><h3 id="监听者"><a href="#监听者" class="headerlink" title="监听者"></a>监听者</h3><p>在unity界面下创建一个作为UI监听器的容器<code>UIManager</code>,同时在UI文件夹下创建监听器脚本<code>UIManager</code>，挂载到容器上：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905181807956.png" alt="image-20230905181807956"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905181839585.png" alt="image-20230905181839585"></p><p>编辑监听器脚本内容并进行绑定：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905182018735.png" alt="image-20230905182018735"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905182258304.png" alt="image-20230905182258304"></p><p>然后添加启动和取消时的事件监听内容，从而实现<strong>对广播内容的接收</strong>：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905183832835.png" alt="image-20230905183832835"></p><p>回到unity界面中为监听器绑定角色状态栏：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905183915221.png" alt="image-20230905183915221"></p><p>同时回到角色属性脚本<code>Character</code>中进行修改：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905184314844.png" alt="image-20230905184314844"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905184332252.png" alt="image-20230905184332252"></p><p>这样就完成了人物状态栏中绿色血条的减少，接下来要让红色血条也跟着出现渐变，在角色状态栏脚本内容<code>Player Stat Bar</code>进行添加：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905203732849.png" alt="image-20230905203732849"></p><p>最终效果就可以实现了</p><p>总结以上内容的代码：</p><p>人物状态栏脚本<code>PlayerStatBar</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerStatBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//血条(绿色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthImage;</span><br><span class="line">    <span class="comment">//血条渐变(红色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthDelayImage;</span><br><span class="line">    <span class="comment">//能量条(黄色)</span></span><br><span class="line">    <span class="keyword">public</span> Image powerImage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(healthDelayImage.fillAmount &gt; healthImage.fillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            healthDelayImage.fillAmount -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收Health的变更百分比</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;persentage&quot;&gt;</span>百分比：Current/Max<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params"><span class="built_in">float</span> persentage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthImage.fillAmount= persentage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>存储广播内容的资源文件夹<code>ScriptableObject</code>下角色属性资源脚本<code>CharacterEventSO</code>(广播者):</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Event/CharacterEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;Character&gt; OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UI监听器内容脚本<code>UIManager</code>(监听者)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerStatBar playerStatBar;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> CharacterEventSO healthEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised += OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised -= OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> persentage = character.currentHealth / character.maxHealth;</span><br><span class="line">        playerStatBar.OnHealthChange(persentage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色属性脚本<code>Character</code>修改:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//掉血事件(传递给人物状态栏)</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Character&gt; OnHealthChange;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">        <span class="comment">//初始化血条(广播到血条状态栏脚本上)</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//血条变化广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/28/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2023/08/28/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（八）"><a href="#Unity开发日记（八）" class="headerlink" title="Unity开发日记（八）"></a>Unity开发日记（八）</h1><h2 id="怪物——蜗牛"><a href="#怪物——蜗牛" class="headerlink" title="怪物——蜗牛"></a>怪物——蜗牛</h2><h3 id="蜗牛的基本移动逻辑和动画"><a href="#蜗牛的基本移动逻辑和动画" class="headerlink" title="蜗牛的基本移动逻辑和动画"></a>蜗牛的基本移动逻辑和动画</h3><p>进行蜗牛动画的基本处理，对素材进行切割，对不同动画进行简易的命名处理，方便后续操作的管理：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828104225859.png" alt="image-20230828104225859"></p><p>蜗牛的动画主要有几个实现要求：</p><ul><li>蜗牛的移动</li><li>蜗牛的缩壳</li><li>蜗牛的探头</li><li>蜗牛的受伤</li><li>蜗牛的死亡</li></ul><p><img src="/./../images/unity(%E5%85%AB)/image-20230828105345681.png" alt="image-20230828105345681"></p><p>进行基础的图层调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828105453721.png" alt="image-20230828105453721"></p><p>添加对应的碰撞体积，一个在脚上与地面进行检测，一个是自身碰撞体，方便与玩家进行交互：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828114423205.png" alt="image-20230828114423205"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828115106618.png" alt="image-20230828115106618"></p><p>同时蜗牛也要添加其他相对应的脚本文件，在此之前，先回到怪物的基类进行调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110010810.png" alt="image-20230828110010810"></p><p><strong>目的：当蜗牛创建新的脚本并且继承怪物基类时，会为蜗牛自动添加这三个必要的组件</strong></p><p>在脚本文件夹<code>Script</code>下怪物文件夹<code>Enemy</code>创建蜗牛的脚本<code>Snail</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110229557.png" alt="image-20230828110229557"></p><p>然后回到unity中为蜗牛添加该脚本，与此同时也会自动被添加了三个必须的组件：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110338410.png" alt="image-20230828110338410"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110352502.png" alt="image-20230828110352502"></p><p>同时还要为蜗牛添加对应的属性脚本<code>Character</code>以及攻击脚本<code>Attack</code>,也要为事件编辑器绑定对应的脚本以及方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110716009.png" alt="image-20230828110716009"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110758313.png" alt="image-20230828110758313"></p><p>随后再调整蜗牛的一些基础数值：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111032920.png" alt="image-20230828111032920"></p><p>同时蜗牛的地面检测脚本也要进行调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828115349122.png" alt="image-20230828115349122"></p><h4 id="编写蜗牛的状态机与动画"><a href="#编写蜗牛的状态机与动画" class="headerlink" title="编写蜗牛的状态机与动画"></a>编写蜗牛的状态机与动画</h4><ul><li>蜗牛的巡逻状态：</li></ul><p>在怪物文件夹下先创建蜗牛巡逻状态的脚本<code>SnailPatrolState</code></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111534734.png" alt="image-20230828111534734"></p><p>回到unity中编辑实现蜗牛移动的动画：</p><p>在动画文件夹下创建对应的蜗牛存放的文件夹，同时创建蜗牛需要的动画控制器</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111818728.png" alt="image-20230828111818728"></p><p>绑定</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111732146.png" alt="image-20230828111732146"></p><p>开始对动画的编辑，首先是实现蜗牛的待机：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112248723.png" alt="image-20230828112248723"></p><p>随后是蜗牛的移动，要注意的是，蜗牛的移动动画类似于两个阶段：蓄力(准备)和移动，所以要创建两个动画来拼接：</p><p>首先是蜗牛向后蓄力(准备)的动画</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112527110.png" alt="image-20230828112527110"></p><p>然后是蜗牛向前移动的动画</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112652534.png" alt="image-20230828112652534"></p><p>这样就先完成了基础的动画编辑，接下来就是在动画控制器中添加判断的值以及连接不同动画</p><p>回到动画编辑器中，先添加判断值（walk，dead，状态hurt）：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112936206.png" alt="image-20230828112936206"></p><p>然后开始进行连线，首先是蜗牛移动两个阶段动画的连接，这意味着第一个准备阶段动画要完全播放完才会播放第二个移动阶段的动画，而第二次移动也是要第二个移动阶段的动画播放完毕后才会回到第一个阶段的动画，循环往复：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113331223.png" alt="image-20230828113331223"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113502566.png" alt="image-20230828113502566"></p><p>随后再连接待机动画与移动动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113724741.png" alt="image-20230828113724741"></p><p>同理返回的也一样，其他设置保持一致</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113758782.png" alt="image-20230828113758782"></p><p>细节修改：当蜗牛撞墙时就不要继续保持移动的动画了，所以还要再加一个连接线</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828114005331.png" alt="image-20230828114005331"></p><p>最后回到蜗牛的巡逻状态脚本<code>SnailPatrolState</code>中进行编辑：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828121049119.png" alt="image-20230828121049119"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到chase状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Skill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在蜗牛的逻辑脚本<code>Snail</code>中进行状态的初始化：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828121401561.png" alt="image-20230828121401561"></p><p>蜗牛的移动还要再进行细致的修改，要让蜗牛在第一阶段的准备移动时不会真正移动，而是到了第二阶段才会实现真正的移动，所以回到怪物基类中进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144155465.png" alt="image-20230828144155465"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144331662.png" alt="image-20230828144331662"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144402960.png" alt="image-20230828144402960"></p><p><code>IsName()</code>对应的是目前所处的动画是哪个，里边填入对应的一阶段准备的动画名</p><h3 id="蜗牛的特殊技能状态的实现"><a href="#蜗牛的特殊技能状态的实现" class="headerlink" title="蜗牛的特殊技能状态的实现"></a>蜗牛的特殊技能状态的实现</h3><p>蜗牛的特殊技能体现在 ———— 躲藏</p><p>先实现蜗牛的躲藏动画，蜗牛的躲藏分为三个阶段：<strong>缩壳阶段 → 壳中阶段 → 探头阶段</strong></p><p>缩壳阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828170953511.png" alt="image-20230828170953511"></p><p>壳中阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828171334256.png" alt="image-20230828171334256"></p><p>探头阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828171604149.png" alt="image-20230828171604149"></p><p>接下来要设置需要的判断值，同时将动画进行连接，其中要先设置一个看到玩家后就进入的状态值<code>Skill</code>与标记是否是躲藏的值<code>hide</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172321029.png" alt="image-20230828172321029"></p><p>同时设置连接的设置</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172351034.png" alt="image-20230828172351034"></p><p>然后再将第一个阶段动画和第二个阶段动画连接起来：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172601475.png" alt="image-20230828172601475"></p><p>再是将第二个阶段动画和第三个阶段动画连接起来：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172703855.png" alt="image-20230828172703855"></p><p>最后是探头阶段到退出的连线：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172829246.png" alt="image-20230828172829246"></p><p>再添加一个受伤动画，即实现如果是先被玩家攻击而受伤，这时也会进入缩壳状态：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173146832.png" alt="image-20230828173146832"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173350903.png" alt="image-20230828173350903"></p><p>受伤后进入准备缩壳阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173726191.png" alt="image-20230828173726191"></p><h4 id="编写蜗牛特殊技能状态机"><a href="#编写蜗牛特殊技能状态机" class="headerlink" title="编写蜗牛特殊技能状态机"></a>编写蜗牛特殊技能状态机</h4><p>先创建对应的蜗牛特殊技能状态脚本<code>SnailSkillState</code>并进行编辑：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828201956978.png" alt="image-20230828201956978"></p><p>同时回到蜗牛的逻辑脚本<code>Snail</code>下进行初始化，初始化的前提是怪物基类<code>Enemy</code>也有蜗牛缩壳阶段的变量，所以：</p><p><code>Enemy</code>下要添加新的缩壳阶段变量，同时要在switch语句中增添切换的条件</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202215349.png" alt="image-20230828202215349"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202407612.png" alt="image-20230828202407612"></p><p><code>Snail</code>初始化</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202252436.png" alt="image-20230828202252436"></p><p>测试后发现还有其他问题，即蜗牛缩壳后仍然会继续移动且会重复缩壳的动画，如何修改：</p><p>先把蜗牛的几个阶段的动画的循环关闭</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828211853492.png" alt="image-20230828211853492"></p><p>然后在蜗牛缩壳脚本<code>SnailSkillState</code>中进行修改，把丢失目标时间进行赋值，以防止一直为0从而导致来回切换动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828212417426.png" alt="image-20230828212417426"></p><p>最后进行细节修改，当蜗牛没看到角色而进入探头动画的时候会自动移动一段距离，为了防止出现这样，要对怪物基类<code>Enemy</code>中的Move()方法再进行修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">           rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同时还要让<strong>蜗牛进入缩壳的时候，玩家攻击它并不会造成伤害，反而会被攻击到</strong></p><p>在蜗牛缩壳脚本下进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213110363.png" alt="image-20230828213110363"></p><p>经过测试发现无敌状态并没有被切换，原因是因为在属性脚本<code>Character</code>中</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213441623.png" alt="image-20230828213441623"></p><p>会一直不断的通过计时器的减少从而更新无敌状态，所以我们要为蜗牛缩壳时也同时让无敌时间计时器被赋值，从而满足无敌状态的持续：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213816664.png" alt="image-20230828213816664"></p><p>同时为了让蜗牛进入前就能先变成无敌状态，可以在进入的时候就赋值：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828214125767.png" alt="image-20230828214125767"></p><p>PS：由于在属性脚本<code>Character</code>中将计数器属性invulnerableCounter设置为私有属性所以无法被调用，只要改为公共属性即可</p><p>最后测试时，当人物在蜗牛探出头后的背后发动攻击没有效果，所以还要再进行一小段的修改：</p><p>这是因为蜗牛的检测可以检测到攻击的图层（Player），只要把攻击的图层切换为default即可</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829151958056.png" alt="image-20230829151958056"></p><p>最后阶段性总结，蜗牛的脚本内容：</p><p>蜗牛的逻辑脚本<code>Snail</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Snail</span> : <span class="title">Enemy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        patrolState = <span class="keyword">new</span> SnailPatrolState();</span><br><span class="line">        skillState = <span class="keyword">new</span> SnailSkillState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蜗牛的巡逻状态脚本<code>SnailPatrolState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到缩壳(Skill)状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Skill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蜗牛的缩壳阶段脚本<code>SnailSkillState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailSkillState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Skill&quot;);</span></span><br><span class="line">        <span class="comment">//进入缩壳直接把速度写为0即可</span></span><br><span class="line">        currentEnemy.currentSpeed = <span class="number">0</span>;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;hide&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        currentEnemy.anim.SetTrigger(<span class="string">&quot;skill&quot;</span>);</span><br><span class="line"></span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        <span class="comment">//蜗牛进入缩壳阶段时切换为无敌状态</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerable= <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//同时为无敌计时器赋值为丢失目标前的计时(进入时就先启动一次)</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerableCounter = currentEnemy.lostTimeCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line">        <span class="comment">//同时为无敌计时器赋值为丢失目标前的计时</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerableCounter = currentEnemy.lostTimeCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;end&quot;);</span></span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;hide&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//退出缩壳阶段则退出无敌状态</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物基类<code>Enemy</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明该组件的使用或者被调用都必须要有这三个组件，如果没有则自动创建！</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Rigidbody2D),typeof(Animator),typeof(PhysicsCheck))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line">    <span class="comment">//蜗牛——缩壳状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState skillState;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜗牛的蓄力准备阶段和蜗牛的探头阶段都不会有移动</span></span><br><span class="line">        <span class="keyword">if</span>(!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            NPCState.Skill=&gt; skillState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怪物————蜜蜂"><a href="#怪物————蜜蜂" class="headerlink" title="怪物————蜜蜂"></a>怪物————蜜蜂</h2><h3 id="蜜蜂的基本移动逻辑和动画"><a href="#蜜蜂的基本移动逻辑和动画" class="headerlink" title="蜜蜂的基本移动逻辑和动画"></a>蜜蜂的基本移动逻辑和动画</h3><h4 id="蜜蜂的动画创建"><a href="#蜜蜂的动画创建" class="headerlink" title="蜜蜂的动画创建"></a>蜜蜂的动画创建</h4><p>先对蜜蜂的动画素材进行切割，需要注意切割的方式：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829200824506.png" alt="image-20230829200824506"></p><p>将第一帧动画作为模型放置上去</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201103430.png" alt="image-20230829201103430"></p><p>同时也修改蜜蜂的图层设置，可以跟其他两种怪物一样设置为Middle层下第1层</p><p>接下来创建蜜蜂的逻辑脚本<code>Bee</code>，同时挂载到蜜蜂模型下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201412534.png" alt="image-20230829201412534"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201435265.png" alt="image-20230829201435265"></p><p>然后为蜜蜂模型添加碰撞体，这里需要注意的是：蜜蜂设定上为可以穿越地图障碍，所以只需要一个自己自身的胶囊碰撞体即可：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201751890.png" alt="image-20230829201751890"></p><p>然后创建蜜蜂的动画文件夹，创建蜜蜂的动画控制器，并为蜜蜂的动画组件进行绑定：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201934290.png" alt="image-20230829201934290"></p><p>创建蜜蜂需要的各个动画，主要有几个阶段：</p><ul><li>蜜蜂正常飞行</li><li>蜜蜂追击飞行</li><li>蜜蜂攻击</li><li>蜜蜂受伤</li><li>蜜蜂死亡</li></ul><p>蜜蜂的正常飞行动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829202746426.png" alt="image-20230829202746426"></p><p>蜜蜂的追击动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204158279.png" alt="image-20230829204158279"></p><p>蜜蜂的受伤动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204319820.png" alt="image-20230829204319820"></p><p>蜜蜂的攻击动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204422208.png" alt="image-20230829204422208"></p><p>同时调整一下动画，将受伤和攻击动画的循环播放都取消了：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204501786.png" alt="image-20230829204501786"></p><h4 id="▲蜜蜂的基本移动逻辑"><a href="#▲蜜蜂的基本移动逻辑" class="headerlink" title="▲蜜蜂的基本移动逻辑"></a>▲蜜蜂的基本移动逻辑</h4><p>蜜蜂的移动逻辑为： 为<strong>蜜蜂固定在一个点位，然后在该点位的一定空间范围内不固定地进行飞行，当蜜蜂在该范围内检测到玩家，则切换为追击状态</strong></p><p>如果用<strong>图形化</strong>来标识，则在unity的UI上的#Scene窗口可以看到有一个基于圆点的不动的圈，蜜蜂在该圈里实现随机移动，又有另外一个圈一直基于蜜蜂为圆心而移动</p><p>先创建蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829210748273.png" alt="image-20230829210748273"></p><p>同时回到unity页面上修改蜜蜂的基础内容：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829210909767.png" alt="image-20230829210909767"></p><h5 id="蜜蜂检测重写"><a href="#蜜蜂检测重写" class="headerlink" title="蜜蜂检测重写"></a>蜜蜂检测重写</h5><p>而蜜蜂的检测器要进行重做，蜜蜂的检测是要围绕蜜蜂在巡逻过程中周遭范围内进行的检测，在蜜蜂的逻辑脚本<code>Bee</code>中进行方法的重写：</p><p>对<strong>玩家的检测</strong>方法重写：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829211818319.png" alt="image-20230829211818319"></p><p><strong>检测范围</strong>方法重写：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829213113358.png" alt="image-20230829213113358"></p><h5 id="蜜蜂移动逻辑"><a href="#蜜蜂移动逻辑" class="headerlink" title="蜜蜂移动逻辑"></a>蜜蜂移动逻辑</h5><p>要求：在圆圈范围内随机生成点位，让蜜蜂移动到该点位，循环该步骤</p><p>首先在怪物基类<code>Enemy</code>下定义蜜蜂需要用到的属性和准备要重写的方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830125727568.png" alt="image-20230830125727568"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830130343089.png" alt="image-20230830130343089"></p><p>随后要在蜜蜂的逻辑脚本<code>Bee</code>中进行初始化处理和重写方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830132249761.png" alt="image-20230830132249761"></p><p>同时设置图形可视化，把移动范围和检测范围都显示在unity界面上</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830132618262.png" alt="image-20230830132618262"></p><p>接下来就是要设置蜜蜂移动的方法，以上只是完成了蜜蜂在范围内移动且具有检测玩家的功能而已，实际让蜜蜂能够动起来还要另外编写方法：</p><p>在蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code>下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830181326138.png" alt="image-20230830181326138"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830181807016.png" alt="image-20230830181807016"></p><p>同时也要更改蜜蜂的移动方法，重写怪物基类<code>Enemy</code>下的Move()方法：</p><p>先在继承了基类的蜜蜂逻辑脚本<code>Bee</code>下覆盖原先的Move()方法</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830182204119.png" alt="image-20230830182204119"></p><p>然后在蜜蜂巡逻脚本<code>BeePatrolState</code>下编写物理逻辑方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830194306310.png" alt="image-20230830194306310"></p><p>这样就完成了蜜蜂的移动</p><p>还要把蜜蜂的重力组件进行更改，由于蜜蜂是在天上飞的，所以重力要修改为0，否则蜜蜂会直接落地：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830194603865.png" alt="image-20230830194603865"></p><p>最后，蜜蜂的巡逻范围可以修改为基于初始点，在蜜蜂逻辑脚本<code>Bee</code>下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830195211194.png" alt="image-20230830195211194"></p><h3 id="蜜蜂的追击和攻击的实现"><a href="#蜜蜂的追击和攻击的实现" class="headerlink" title="蜜蜂的追击和攻击的实现"></a>蜜蜂的追击和攻击的实现</h3><p>蜜蜂的追击要注意的是，蜜蜂是悬在半空中，也就是追击到敌人的时候不会黏在一起，而是有一定的距离，蜜蜂的攻击也是在这个距离下就可以释放的</p><p>首先为蜜蜂添加其他基础组件<code>Attack</code>，<code>Character</code>，同时为攻击组件设定攻击距离：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105018455.png" alt="image-20230831105018455"></p><p>创建蜜蜂的追击逻辑脚本<code>BeeChaseState</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105519017.png" alt="image-20230831105519017"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105706293.png" alt="image-20230831105706293"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110110133.png" alt="image-20230831110110133"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110156255.png" alt="image-20230831110156255"></p><p>同时还要回到蜜蜂的逻辑脚本<code>Bee</code>初始化启用<code>BeeChaseState</code>脚本</p><p>进行测试，测试发现了蜜蜂会一直翻转的问题，所以还要对蜜蜂的追击逻辑脚本进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110706256.png" alt="image-20230831110706256"></p><h4 id="创建蜜蜂不同动画的连接"><a href="#创建蜜蜂不同动画的连接" class="headerlink" title="创建蜜蜂不同动画的连接"></a>创建蜜蜂不同动画的连接</h4><p>首先创建蜜蜂该有的连接判断值，然后进行不同动画的连线：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135300682.png" alt="image-20230831135300682"></p><p><strong>蜜蜂巡逻动画 → 蜜蜂追击动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111243487.png" alt="image-20230831111243487"></p><p><strong>蜜蜂追击动画→蜜蜂巡逻动画</strong>如上，条件改为false即可</p><p><strong>Any State → 蜜蜂受伤动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111439160.png" alt="image-20230831111439160"></p><p>蜜蜂受伤动画执行一次后就退出(<strong>蜜蜂受伤动画 → Exit</strong>)：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111542144.png" alt="image-20230831111542144"></p><p><strong>Any State → 蜜蜂攻击动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135354548.png" alt="image-20230831135354548"></p><p><strong>蜜蜂攻击动画→退出</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135438215.png" alt="image-20230831135438215"></p><p>随后在蜜蜂追击逻辑<code>BeeChaseState</code>下添加：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831134827253.png" alt="image-20230831134827253"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831134840875.png" alt="image-20230831134840875"></p><p>同时攻击的方式和方法也要再进行修改和添加，否则蜜蜂在追击到敌人并且停止而开始攻击后，如果玩家跑了，这时蜜蜂不会继续追，所以：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831140627820.png" alt="image-20230831140627820"></p><p>然后实现蜜蜂的针刺伤害，也就是当玩家被蜜蜂追击的时候，玩家受到的伤害有两种：</p><ul><li>接触伤害</li><li>针刺伤害</li></ul><p>其中，针刺伤害我们要为其加入，先在蜜蜂模型下创建一个新的模型，起名为Attack Point，然后在攻击动画中进行设置：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831195545857.png" alt="image-20230831195545857"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831195731078.png" alt="image-20230831195731078"></p><p>先为Attack Point添加碰撞体组件并调整参数：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831200348247.png" alt="image-20230831200348247"></p><p>最后再为该模型添加攻击逻辑<code>Attack</code>并设置伤害</p><p>经过测试，发现当玩家攻击蜜蜂时，蜜蜂没有被击退，所以还要回到蜜蜂追击逻辑<code>BeeChaseState</code>下进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831200948736.png" alt="image-20230831200948736"></p><p>同时回到界面中为事件触发器绑定对应的脚本和方法</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831203219833.png" alt="image-20230831203219833"></p><p>添加死亡动画并挂载到动画控制器上：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831205122780.png" alt="image-20230831205122780"></p><p>最后一帧销毁怪物：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831205200782.png" alt="image-20230831205200782"></p><p>挂载到动画控制器上并连接，创建连接条件Bool类型的死亡属性dead</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831204929355.png" alt="image-20230831204929355"></p><p>最后阶段性总结，蜜蜂的脚本内容：</p><p>怪物基类<code>Enemy</code>的修改:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明该组件的使用或者被调用都必须要有这三个组件，如果没有则自动创建！</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Rigidbody2D),typeof(Animator),typeof(PhysicsCheck))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line">    <span class="comment">//蜜蜂初始点位</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 spawnPoint;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line">    <span class="comment">//蜗牛——缩壳状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState skillState;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">        spawnPoint = transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能  初始(巡逻)状态PatrolState</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜗牛的蓄力准备阶段和蜗牛的探头阶段都不会有移动</span></span><br><span class="line">        <span class="keyword">if</span> (!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">            Debug.Log(<span class="string">&quot;baseMove&quot;</span>);</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            NPCState.Skill=&gt; skillState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对蜜蜂：获取点位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Vector3 <span class="title">GetNewPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的基本逻辑脚本<code>Bee</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bee</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;移动范围&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> patrolRadius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        patrolState = <span class="keyword">new</span> BeePatrolState();</span><br><span class="line">        chaseState = <span class="keyword">new</span> BeeChaseState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = Physics2D.OverlapCircle(transform.position, checkDistance, attackLayer);</span><br><span class="line">        <span class="keyword">if</span> (obj)</span><br><span class="line">        &#123;</span><br><span class="line">            attacker = obj.transform;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜜蜂检测敌人的范围可视化</span></span><br><span class="line">        Gizmos.DrawWireSphere(transform.position,checkDistance);</span><br><span class="line">        Gizmos.color = Color.green;</span><br><span class="line">        <span class="comment">//蜜蜂可巡逻轨迹的范围可视化</span></span><br><span class="line">        Gizmos.DrawWireSphere(spawnPoint, patrolRadius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Vector3 <span class="title">GetNewPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> targetX = Random.Range(-patrolRadius, patrolRadius);</span><br><span class="line">        <span class="keyword">var</span> targetY = Random.Range(-patrolRadius, patrolRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spawnPoint + <span class="keyword">new</span> Vector3(targetX, targetY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeePatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//目标位置(对自己)</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 target;</span><br><span class="line">    <span class="comment">//移动方向</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDir;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">        <span class="comment">//初始目标位置最开始为spawnPoint，所以调用父类方法获得</span></span><br><span class="line">        target = enemy.GetNewPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Chase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断蜜蜂是否到达随机目标点</span></span><br><span class="line">        <span class="keyword">if</span>(Mathf.Abs(target.x - currentEnemy.transform.position.x)&lt;<span class="number">0.1f</span> &amp;&amp; Mathf.Abs(target.y - currentEnemy.transform.position.y) &lt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果到达则先等待一小会</span></span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//重新生成目标点，此时就要调用子类方法随机获得</span></span><br><span class="line">            target = currentEnemy.GetNewPoint();</span><br><span class="line">        &#125;</span><br><span class="line">        moveDir = (target - currentEnemy.transform.position).normalized;</span><br><span class="line">        <span class="comment">//改变面朝方向</span></span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &gt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(moveDir.x&lt;<span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(!currentEnemy.isHurt &amp;&amp; !currentEnemy.isDead &amp;&amp; !currentEnemy.wait)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;BeeMove&quot;);</span></span><br><span class="line">            currentEnemy.rb.velocity = currentEnemy.currentSpeed * moveDir * Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.rb.velocity = Vector2.zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的追击逻辑脚本<code>BeeChaseState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeeChaseState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Attack attack;</span><br><span class="line">    <span class="comment">//目标位置(对敌人/玩家)</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 target;</span><br><span class="line">    <span class="comment">//移动方向</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDir;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isAttack;</span><br><span class="line">    <span class="comment">//攻击频率计时器(防止蜜蜂持续攻击)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> attackRateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.chaseSpeed;</span><br><span class="line">        attack = enemy.GetComponent&lt;Attack&gt;();</span><br><span class="line"></span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;chase&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当丢失目标后切换为巡逻状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line">        <span class="comment">//获取目标位置</span></span><br><span class="line">        target = <span class="keyword">new</span> Vector3(currentEnemy.attacker.position.x, currentEnemy.attacker.position.y + <span class="number">1.5f</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断攻击距离(进入攻击距离)</span></span><br><span class="line">        <span class="keyword">if</span>(Mathf.Abs(target.x - currentEnemy.transform.position.x)&lt;= attack.attackRange &amp;&amp; Mathf.Abs(target.y - currentEnemy.transform.position.y) &lt;= attack.attackRange)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//攻击</span></span><br><span class="line">            isAttack = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//攻击时要先停下</span></span><br><span class="line">            <span class="keyword">if</span>(!currentEnemy.isHurt)</span><br><span class="line">                currentEnemy.rb.velocity = Vector2.zero;</span><br><span class="line">            <span class="comment">//计时器</span></span><br><span class="line">            attackRateCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(attackRateCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentEnemy.anim.SetTrigger(<span class="string">&quot;attack&quot;</span>);</span><br><span class="line">                attackRateCounter = attack.attackRate;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//超出攻击范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            isAttack= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        moveDir = (target - currentEnemy.transform.position).normalized;</span><br><span class="line">        <span class="comment">//改变面朝方向</span></span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &gt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &lt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.isHurt &amp;&amp; !currentEnemy.isDead &amp;&amp; !isAttack)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;BeeMove&quot;);</span></span><br><span class="line">            currentEnemy.rb.velocity = currentEnemy.currentSpeed * moveDir * Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;chase&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（七）</title>
      <link href="/2023/08/08/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/08/08/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（七）"><a href="#Unity开发日记（七）" class="headerlink" title="Unity开发日记（七）"></a>Unity开发日记（七）</h1><h2 id="有限状态机与抽象类多态"><a href="#有限状态机与抽象类多态" class="headerlink" title="有限状态机与抽象类多态"></a>有限状态机与抽象类多态</h2><p>创建一个抽象基类<code>BaseState</code>作为状态机</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230808144136907.png" alt="image-20230808144136907"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230808145057814.png" alt="image-20230808145057814"></p><p>再创建一个编写野猪状态的类来实现抽象基类<code>BoarPatrolState</code>:</p><p>默认状态下会一直处于<code>巡逻状态</code>：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809154359926.png" alt="image-20230809154359926"></p><p>同时回到怪物基类<code>Enemy</code>进行修改：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809152337443.png" alt="image-20230809152337443"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809152859524.png" alt="image-20230809152859524"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809153034801.png" alt="image-20230809153034801"></p><p>最后还要回到野猪对应的脚本上进行初始化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809154005998.png" alt="image-20230809154005998"></p><h2 id="追击状态的转换"><a href="#追击状态的转换" class="headerlink" title="追击状态的转换"></a>追击状态的转换</h2><h3 id="修改物体碰撞检测-使用BoxCast"><a href="#修改物体碰撞检测-使用BoxCast" class="headerlink" title="修改物体碰撞检测(使用BoxCast)"></a>修改物体碰撞检测(使用BoxCast)</h3><p><code>BoxCast</code>描述：</p><p><strong>沿射线投射盒体并返回有关命中对象的详细信息</strong></p><p>追击状态的实现首先要先让怪物对象发现玩家对象，这时候就要用到碰撞检测，回到怪物基类<code>Enemy</code>下进行代码的修改，通过<code>BoxCast</code>方法来进行物体检测：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810154249687.png" alt="image-20230810154249687"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810154422182.png" alt="image-20230810154422182"></p><p>其中BoxCast中的各个参数作用和意义如图：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810153953460.png" alt="image-20230810153953460"></p><p>其次要编写<strong>状态切换方法</strong>（即 巡逻状态 → 发现敌人 →切换追击状态），首先回到unity界面上，在<code>Scripts</code>文件包下再创建一个工具包<code>Utilities</code>,在下边再创建一个新的脚本<code>Enums</code>：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810155301579.png" alt="image-20230810155301579"></p><p>在<code>Enemy</code>下编写切换状态的方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NPCState.Patrol =&gt; patrolState,: 这是第一个匹配模式。它表示当 state 等于 NPCState.Patrol 时，将会返回 patrolState，这可能是一个预先定义的状态对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NPCState.Chase =&gt; chaseState,: 这是第二个匹配模式。它表示当 state 等于 NPCState.Chase 时，将会返回 chaseState，同样可能是一个预先定义的状态对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">_ =&gt; null: 这是一个默认的匹配模式，它使用 _ 作为通配符，表示对于除了前面两个模式之外的所有情况，都返回 null。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同时回到怪物的状态实现类<code>BoarPatrolState</code>下实现对应的状态切换：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827140525725.png" alt="image-20230827140525725"></p><p>这样就完成了基础的状态切换</p><p>接下来就是要编写状态切换的脚本：</p><p>首先在怪物脚本文件夹<code>Enemy</code>下创建新的状态切换脚本<code>BoarChaseState</code></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827141752397.png" alt="image-20230827141752397"></p><p>继承基础状态类并实现该抽象类，同时在怪物类<code>Boar</code>下进行初始化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143714979.png" alt="image-20230827143714979"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827142038512.png" alt="image-20230827142038512"></p><p>附带：</p><p>为了方便观察BoxCast基于什么点来发射碰撞箱进行检测，还可以回到怪物基类<code>Enemy</code>下进行修改从而实现unity界面上的可视化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143633392.png" alt="image-20230827143633392"></p><p>为了进行检测，在选择状态中的开始阶段进行日志打印，在当前状态中的结束状态进行日志打印：</p><p>进入选择状态的开始阶段(<strong>进入选择&#x2F;追击阶段</strong>) ——</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143804494.png" alt="image-20230827143804494"></p><p>进入当前状态的结束阶段(<strong>退出当前阶段</strong>) ——</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143824272.png" alt="image-20230827143824272"></p><p>然后回到unity中进行测试，测试前也要先调整好参数（<strong>基于怪物身上哪个点进行碰撞体的发射并检测</strong>，<strong>检测范围要多大</strong>）：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827144718035.png" alt="image-20230827144718035"></p><p>该场景下怪物是要检测玩家的图层从而切换形态，所以：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827144449860.png" alt="image-20230827144449860"></p><p>优化检测点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="切换追击状态"><a href="#切换追击状态" class="headerlink" title="切换追击状态"></a>切换追击状态</h3><p>当野猪遇到人变成追击状态时，要进行以下更改：</p><ul><li>野猪追击速度提高</li><li>当野猪撞到墙不会停顿而是返回来继续冲撞追击玩家</li></ul><p>回到野猪的选择状态脚本<code>BoarChaseState</code>中进行编辑：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827150148396.png" alt="image-20230827150148396"></p><p>随后还要进行修改，当野猪进入追击状态一段时间，丢失了玩家目标后，要重新切换回正常的巡逻状态：</p><p>首先在怪物基类<code>Enemy</code>下添加新的计时器并完成对应的计时</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151125191.png" alt="image-20230827151125191"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151143239.png" alt="image-20230827151143239"></p><p>然后在怪物追击状态<code>BoarChaseState</code>脚本下进行修改，实现当怪物丢失视野目标重新变成巡逻状态：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151551069.png" alt="image-20230827151551069"></p><p>同时也要为巡逻状态脚本<code>BoarPatrolState</code>进行修改，让此时怪物速度重新回到正常的速度：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151758407.png" alt="image-20230827151758407"></p><p>最终完成的脚本内容：</p><p>怪物基类脚本<code>Enemy</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>状态抽象类<code>BaseState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Enemy currentEnemy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span>;</span><br><span class="line">    <span class="comment">//逻辑判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span>;</span><br><span class="line">    <span class="comment">//物理判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物当前状态(巡逻)类<code>BoarPatrolState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoarPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到chase状态</span></span><br><span class="line">        <span class="keyword">if</span>(currentEnemy.FoundPlayer()) </span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Chase);        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物选择状态(追击)类<code>BoarChaseState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoarChaseState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Chase&quot;);</span></span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.chaseSpeed;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当丢失目标后切换为巡逻状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当进入追击状态时无视撞墙等待</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(currentEnemy.faceDir.x, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（六）</title>
      <link href="/2023/08/02/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/08/02/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（六）"><a href="#Unity开发日记（六）" class="headerlink" title="Unity开发日记（六）"></a>Unity开发日记（六）</h1><h2 id="怪物基本的移动逻辑和动画"><a href="#怪物基本的移动逻辑和动画" class="headerlink" title="怪物基本的移动逻辑和动画"></a>怪物基本的移动逻辑和动画</h2><h3 id="移动逻辑"><a href="#移动逻辑" class="headerlink" title="移动逻辑"></a>移动逻辑</h3><p>先在<code>Scripts</code>文件下创建存储怪物脚本的Enemy，随后创建一个基类Enemy作为敌人都会继承的父类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802141848929.png" alt="image-20230802141848929"></p><p>然后创建野猪对应的脚本<code>Boar</code>，其中Boar类要继承Enemy这个父类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802142709916.png" alt="image-20230802142709916"></p><p>然后让野猪绑定对应的脚本：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802142317769.png" alt="image-20230802142317769"></p><p>为野猪添加动画组件（Animator）：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802144518105.png" alt="image-20230802144518105"></p><p>编辑怪物的基本类<code>Enemy</code>：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802144456327.png" alt="image-20230802144456327"></p><h3 id="动画编辑"><a href="#动画编辑" class="headerlink" title="动画编辑"></a>动画编辑</h3><p>先在<code>Animation</code>文件下创建存放怪物动画的文件包Enemies，然后创建存放野猪动画的包Boar：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145350099.png" alt="image-20230802145350099"></p><p>创建动画控制器<code>Animator</code>:</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145502644.png" alt="image-20230802145502644"></p><p>野猪的动画组件也要绑定该控制器：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145550405.png" alt="image-20230802145550405"></p><p>回到动画控制器创建野猪需要的动画，首先创建待机时的动画：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145830073.png" alt="image-20230802145830073"></p><p>然后再对怪物正常走路的动画素材进行处理，然后再创建野猪走路的动画：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150221111.png" alt="image-20230802150221111"></p><p>下边的<code>Compression</code>设置为None</p><p>对素材进行切割：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150314243.png" alt="image-20230802150314243"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150449775.png" alt="image-20230802150449775"></p><p>同理将追击的素材也进行处理，然后也创建对应的动画</p><p>在动画控制器中创建条件转换值，同时创建连线让不同动画进行切换：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151518671.png" alt="image-20230802151518671"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151452100.png" alt="image-20230802151452100"></p><p>具体动画条件转换为：</p><p><strong>Idle → Walk ： walk为true</strong></p><p><strong>Idle → Run：run为true</strong></p><p><strong>Walk → Run：run为true</strong></p><p>反过来则前两个都为false，但是<strong>Run → Walk的条件为：run为false，walk为true</strong></p><p>这样就完成了动画的切换</p><p>接下来要对动画在脚本中进行绑定，首先要让子类<code>Boar</code>重写父类的方法：</p><p>父类<code>Enemy</code>修改</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802152202397.png" alt="image-20230802152202397"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151902990.png" alt="image-20230802151902990"></p><p>子类<code>Boar</code>重写方法</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802152327604.png" alt="image-20230802152327604"></p><h2 id="撞墙判定和等候计时"><a href="#撞墙判定和等候计时" class="headerlink" title="撞墙判定和等候计时"></a>撞墙判定和等候计时</h2><p>先为野猪添加物理校测脚本（Physics Check），目的是为了进行撞墙的判定</p><p>调整参数：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805140908991.png" alt="image-20230805140908991"></p><p>然后回到脚本中修改代码，编写对墙壁的检测（左右墙壁）：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141547527.png" alt="image-20230805141547527"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141623992.png" alt="image-20230805141623992"></p><p>修改完成后回到unity界面跳转左右偏移量的参数：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141834662.png" alt="image-20230805141834662"></p><p>为了优化操作，不用让我们自己来实现对偏移量的修改进一步修改碰撞体碰撞的接触面，我们可以让它自动修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806115343419.png" alt="image-20230806115343419"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806115530003.png" alt="image-20230806115530003"></p><p>这样再进行测试碰撞即可</p><p>细节修改：</p><p>图层部分要修改检测的边框，不然可能导致野猪碰撞后穿模，使得没法正确判定野猪已经撞墙</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806152955241.png" alt="image-20230806152955241"></p><p>最后要实现怪物碰墙后转身，可以对怪物基类<code>Enemy</code>进行修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806153501853.png" alt="image-20230806153501853"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806153533743.png" alt="image-20230806153533743"></p><h3 id="等候计时"><a href="#等候计时" class="headerlink" title="等候计时"></a>等候计时</h3><p>为了让怪物撞击墙壁后留有等待时间再进行调头，这时候还需要多设计一个等候计时</p><p>回到怪物的基类<code>Enemy</code>脚本内进行修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154346430.png" alt="image-20230806154346430"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154931084.png" alt="image-20230806154931084"></p><p>修改前边的调头逻辑，改成设置为等待状态</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154911693.png" alt="image-20230806154911693"></p><p>最后会遇到新的问题：</p><ul><li>野猪第一段开始时没有初始化时间，当前等待时间没有初始化</li><li>野猪第二次撞墙后转身会导致第二个碰撞点撞到墙壁从而再次进行等待计时</li></ul><p>细节修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806155443641.png" alt="image-20230806155443641"></p><h2 id="怪物受伤和死亡"><a href="#怪物受伤和死亡" class="headerlink" title="怪物受伤和死亡"></a>怪物受伤和死亡</h2><h3 id="受伤和死亡动画"><a href="#受伤和死亡动画" class="headerlink" title="受伤和死亡动画"></a>受伤和死亡动画</h3><p>将受伤和死亡动画的素材都先进行处理并切割，以底部为中心：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807143656043.png" alt="image-20230807143656043"></p><p>回到动画控制器，创建新动画并将动画素材拖拽进去：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807143844780.png" alt="image-20230807143844780"></p><p>同理可以直接复制受伤的动画作为死亡动画即可</p><p>动画细节实现：</p><p>让动画播放呈现渐变效果，也就是不会一直闪烁，而是让模型逐渐透明至消失</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807144859800.png" alt="image-20230807144859800"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807145002881.png" alt="image-20230807145002881"></p><p>回到动画控制器将动画连接起来，同时创建切换动画的条件：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150229732.png" alt="image-20230807150229732"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150312501.png" alt="image-20230807150312501"></p><p>受伤和动画的连线设置还要注意一点：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807162544340.png" alt="image-20230807162544340"></p><p>最后也要把受伤和死亡动画都取消循环播放：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150357936.png" alt="image-20230807150357936"></p><h3 id="受伤和死亡逻辑"><a href="#受伤和死亡逻辑" class="headerlink" title="受伤和死亡逻辑"></a>受伤和死亡逻辑</h3><p>定义完成动画后回到怪物的基类<code>Enemy</code>下定义受伤和死亡的逻辑：</p><ul><li>受伤</li></ul><p><img src="/./../images/unity(%E5%85%AD)/image-20230807153238300.png" alt="image-20230807153238300"></p><p>受伤要满足几个该有的细节内容：</p><p>1、受伤后如果玩家在怪物反方向，则怪物转身</p><p>2、受伤后怪物也要有一定的被击退效果</p><p>3、受伤时怪物不移动</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807153413858.png" alt="image-20230807153413858"></p><p><img src="/./../../../typora-images/image-20230807153445129.png" alt="image-20230807153445129"></p><p>细节修改：</p><p>受击后野猪从正常状态到受伤状态再到退出受伤状态，希望能够在受击方法中按顺序来，这时候可以通过<strong>携程</strong>的方式来实现</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807155557596.png" alt="image-20230807155557596"></p><p>完成基类内容的逻辑编写后，要为野猪对象受伤后的组件中的<strong>事件方法</strong>绑定目标组件或目标类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807151834606.png" alt="image-20230807151834606"></p><p>选择要让该组件执行的方法或内容：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807151919318.png" alt="image-20230807151919318"></p><ul><li>死亡</li></ul><p>最后野猪死亡后要对野猪进行销毁</p><p>先在代码中创建死亡状态的变量，然后编写死亡的逻辑：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160325259.png" alt="image-20230807160325259"></p><p>随后要在动画控制器中选择死亡的动画，在死亡动画的最后一帧添加一个方法：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160517619.png" alt="image-20230807160517619"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160602675.png" alt="image-20230807160602675"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160618960.png" alt="image-20230807160618960"></p><p>同时回到unity界面中在野猪的基本属性脚本<code>Character</code>事件方法进行绑定：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160955391.png" alt="image-20230807160955391"></p><p>这样就能实现野猪死亡后顺便将该对象也取消了，但是还有一个新的问题，野猪播放死亡动画的时候仍有碰撞体积，这样会导致死亡的瞬间如果碰到角色仍会让角色掉血，所以要再进行完善：</p><p>可以通过修改图层来忽略图层间的碰撞，从而达到我们要的效果</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163036546.png" alt="image-20230807163036546"></p><p>以死亡的时候让野猪切换为<code>Ignore Raycast</code>为例，如何让这个图层忽略其他图层？可以在Uniity中的设置来进行自定义忽略：</p><p>Edit → Project Setting → Physics 2D</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163406720.png" alt="image-20230807163406720"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163428653.png" alt="image-20230807163428653"></p><p>然后回到怪物基类中修改代码，让怪物死亡的时候就切换成<code>Ignore Raycast</code>图层，从而忽略掉角色层：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163617624.png" alt="image-20230807163617624"></p><p>最终代码：</p><p>怪物基类<code>Emeny</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">protected</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((physicsCheck.touchLeftWall &amp;&amp; faceDir.x &lt; <span class="number">0</span>) || (physicsCheck.touchRightWall &amp;&amp; faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            wait = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp; !isDead)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>物理检测类<code>PhysicsCheck</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//判断是手动还是自动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> manual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 leftOffset;</span><br><span class="line">    <span class="keyword">public</span> Vector2 rightOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchLeftWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchRightWall;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动</span></span><br><span class="line">        <span class="keyword">if</span>(!manual)</span><br><span class="line">        &#123;</span><br><span class="line">            rightOffset = <span class="keyword">new</span> Vector2((coll.bounds.size.x + coll.offset.x) / <span class="number">2</span>, coll.bounds.size.y / <span class="number">2</span>);</span><br><span class="line">            leftOffset = <span class="keyword">new</span> Vector2(-rightOffset.x, rightOffset.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        isGround = Physics2D.OverlapCircle((Vector2)transform.position+bottomOffset, checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//墙体判断</span></span><br><span class="line">        touchLeftWall = Physics2D.OverlapCircle((Vector2)transform.position + leftOffset, checkReduis, groundLayer);</span><br><span class="line">        touchRightWall = Physics2D.OverlapCircle((Vector2)transform.position + rightOffset, checkReduis, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + leftOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + rightOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（五）</title>
      <link href="/2023/07/31/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/07/31/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（五）"><a href="#Unity开发日记（五）" class="headerlink" title="Unity开发日记（五）"></a>Unity开发日记（五）</h1><h2 id="三段攻击动画的实现"><a href="#三段攻击动画的实现" class="headerlink" title="三段攻击动画的实现"></a>三段攻击动画的实现</h2><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105524128.png" alt="image-20230731105524128"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105808903.png" alt="image-20230731105808903"></p><p>切割素材，然后创建三个动画(Animation)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105631349.png" alt="image-20230731105631349"></p><p>以此类推将对应的素材添加到对应的动画上边，完成三段攻击动画的素材绑定</p><p>在动画控制器(Animator)中创建一个新的分层(<strong>Attack Layer</strong>)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110121968.png" alt="image-20230731110121968"></p><p>然后创建一个空的<code>Empty</code>,将三段攻击也拖进来：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110316560.png" alt="image-20230731110316560"></p><p>随后创建连线以及进入攻击状态的判断值<code>isAttack</code>，以及攻击状态的值<code>attack</code>：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110902743.png" alt="image-20230731110902743"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111000465.png" alt="image-20230731111000465"></p><p>将其他几个攻击动画也连接到一起，条件也一样，但是设置要进行修改：</p><p><strong>第一段攻击 → 第二段攻击情况：</strong></p><ul><li>再次攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111655487.png" alt="image-20230731111655487"></p><ul><li>不再攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111842566.png" alt="image-20230731111842566"></p><p>攻击情况下进入二段攻击，只播放90%的一段动画，不再攻击情况下退出动画</p><p><strong>第二段攻击 → 第三段攻击情况：</strong></p><ul><li>再次攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112054448.png" alt="image-20230731112054448"></p><ul><li>不再攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112127452.png" alt="image-20230731112127452"></p><p>同样在进行再次攻击时播放90%动画，而不再攻击就直接退出</p><p>最后是第三段攻击播放完成后就退出了，直接绑定<code>Exit</code>即可</p><h3 id="添加攻击监听以及实现攻击动画绑定"><a href="#添加攻击监听以及实现攻击动画绑定" class="headerlink" title="添加攻击监听以及实现攻击动画绑定"></a>添加攻击监听以及实现攻击动画绑定</h3><p>在<code>Input System</code>输入系统中添加新的<code>Action</code>来监听攻击按键：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112434242.png" alt="image-20230731112434242"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112552057.png" alt="image-20230731112552057"></p><p>在<code>PlayerAnimation</code>动画控制脚本中编辑设置动画状态的方法：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731113320731.png" alt="image-20230731113320731"></p><p>在<code>PlayerController</code>角色控制脚本中编辑攻击逻辑：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731114943442.png" alt="image-20230731114943442"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731125723472.png" alt="image-20230731125723472"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731134204302.png" alt="image-20230731134204302"></p><p>这样就完成了三段攻击动画的绑定，但是还有一个问题，由于攻击状态的持续性，可能会导致三段攻击后还会在多一段攻击，如何解决：</p><p>给三段动画都挂载上<code>Behaviour</code>，创建新的Behaviour，实现对攻击状态的取消</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731135057308.png" alt="image-20230731135057308"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731135201526.png" alt="image-20230731135201526"></p><h2 id="实装攻击判定"><a href="#实装攻击判定" class="headerlink" title="实装攻击判定"></a>实装攻击判定</h2><p>三段攻击动画在同一帧中触发攻击方法</p><h3 id="攻击判定"><a href="#攻击判定" class="headerlink" title="攻击判定"></a>攻击判定</h3><p>首先创建三段攻击的容器，目的是为了方便我们在脚本中调用攻击方法：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802104639753.png" alt="image-20230802104639753"></p><p>为下边三个攻击容器分别添加新的碰撞组件：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802104802996.png" alt="image-20230802104802996"></p><p>勾选为Trigger状态</p><p>在攻击动画有剑影的部分选择该碰撞体的形状：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105059803.png" alt="image-20230802105059803"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105222268.png" alt="image-20230802105222268"></p><p><strong>如何让动画在播放的时候到达那一帧才启动攻击对应的碰撞体</strong>？</p><p>可以通过关闭&#x2F;开启容器来实现</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105504624.png" alt="image-20230802105504624"></p><p>在动画编辑器中添加(以第一段攻击为例)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105751059.png" alt="image-20230802105751059"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105930488.png" alt="image-20230802105930488"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802110009983.png" alt="image-20230802110009983"></p><p>其他时间帧都为取消勾选的状态</p><p>接下来要定义不同段攻击的攻击伤害，需要为三个攻击容器添加对应的<code>Attack</code>脚本的组件：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802110229313.png" alt="image-20230802110229313"></p><p>直接修改Damage值即可定义攻击伤害</p><p>同理为二段攻击动画，三段攻击动画都以上边的流程进行(<strong>碰撞体添加→碰撞体绑定→关键帧启用容器→添加攻击脚本→修改攻击数值</strong>)</p><p>这样就完成了三段攻击的动画判定，但是攻击脚本还有新的问题，当通过<code>Attack</code>执行攻击时，会因为本身人物碰撞体和攻击碰撞体接触而使人物自己也掉血，所以要进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802111640353.png" alt="image-20230802111640353"></p><p>只勾选Enemy即可</p><p>进行测试时，由于野猪有两个碰撞体积，我们要以其中一个作为最高碰撞优先级来进行被攻击的运算，这时就可以修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802112128332.png" alt="image-20230802112128332"></p><p>同时给野猪也添加上对应的受伤无敌</p><p>最后衍生出来还有其他问题：</p><ul><li>角色可以边走路边攻击（同时进行）</li><li>野猪不动，角色不动连续攻击无效</li></ul><h3 id="细节修改"><a href="#细节修改" class="headerlink" title="细节修改"></a>细节修改</h3><p>一、玩家攻击时无法移动</p><p>在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802112959296.png" alt="image-20230802112959296"></p><p>修改完成后进行测试，发现虽然不能边走路边攻击了，但是还是有一段位移，原因：光滑材质导致人物没有摩擦力，所以会有位移</p><p>进行修改：</p><p>创建新的光滑材质</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113304966.png" alt="image-20230802113304966"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113323178.png" alt="image-20230802113323178"></p><p>绑定创建的光滑材质</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113340558.png" alt="image-20230802113340558"></p><p>这样修改完成后优化了人物攻击后按住方向键还有一定的位移，但并没有完全实现人物定住，这种方式可以根据个人需求来使用</p><p>如果要真正实现人物定住，可以在动画控制器的<code>Behaviour</code>中直接修改，使动画播放的瞬间就默认为攻击状态：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113803330.png" alt="image-20230802113803330"></p><p>二、修改材质，人物跳跃时切换材质</p><p>目的：跳跃时切换Wall光滑材质，落地时切换Normal光滑材质</p><p>在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115634815.png" alt="image-20230802115634815"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115645999.png" alt="image-20230802115645999"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115701840.png" alt="image-20230802115701840"></p><p>回到unity界面进行绑定：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115826153.png" alt="image-20230802115826153"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（四）</title>
      <link href="/2023/07/26/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/07/26/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（四）"><a href="#Unity开发日记（四）" class="headerlink" title="Unity开发日记（四）"></a>Unity开发日记（四）</h1><h2 id="人物属性及伤害计算"><a href="#人物属性及伤害计算" class="headerlink" title="人物属性及伤害计算"></a>人物属性及伤害计算</h2><p>选择怪物素材</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160152682-1690358691607-4.png" alt="image-20230726160152682"></p><p>对怪物素材处理后进行切割：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160419010-1690358715948-7.png" alt="image-20230726160419010"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160230023.png" alt="image-20230726160230023"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160703067.png" alt="image-20230726160703067"></p><p>将野猪素材拖拽到<code>Hierarchy</code>界面上成为一个对象：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161201886.png" alt="image-20230726161201886"></p><p>然后为野猪对象添加组件以及进行其他设置的修改：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161230195.png" alt="image-20230726161230195"></p><ul><li>2D物体组件：</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161336789.png" alt="image-20230726161336789"></p><ul><li>2D碰撞体组件：</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161631112.png" alt="image-20230726161631112"></p><p>设置好碰撞体体积后出现的问题有：当人物经过或碰到野猪对象会推着他走，相当于撞上了实体，而实际游戏需要是要穿过模型的，也就是两个模型之间可以穿过而不是发生碰撞</p><p>如何解决？</p><h3 id="解决不同模型碰撞问题-穿过模型"><a href="#解决不同模型碰撞问题-穿过模型" class="headerlink" title="解决不同模型碰撞问题(穿过模型)"></a>解决不同模型碰撞问题(穿过模型)</h3><p>首先先要创建两个不同的图层</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162049124.png" alt="image-20230726162049124"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162116398.png" alt="image-20230726162116398"></p><p>为不同角色绑定不同的<code>Layer</code>:</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162211864.png" alt="image-20230726162211864"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162230148.png" alt="image-20230726162230148"></p><p>接下来在野猪对象的2D碰撞体积组件(<strong>Box Collider 2D</strong>)上增加剔除不同图层的内容：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162422628.png" alt="image-20230726162422628"></p><p>这样就完成了不同模型之间的剔除，可以相互穿过的效果</p><h3 id="通过触发器实现伤害效果"><a href="#通过触发器实现伤害效果" class="headerlink" title="通过触发器实现伤害效果"></a>通过触发器实现伤害效果</h3><p>虽然实现了模型之间可以相互穿过的效果，但是在游戏中，要让角色如果穿过怪物的话会被造成伤害，所以要使用触发器来实现我们要的效果</p><p>首先再给野猪对象添加一个胶囊类型的碰撞体组件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726163239368.png" alt="image-20230726163239368"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726163325643.png" alt="image-20230726163325643"></p><p>触发器脚本内容（测试）：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726211547249.png" alt="image-20230726211547249"></p><h3 id="创建人物属性-生命、无敌帧等"><a href="#创建人物属性-生命、无敌帧等" class="headerlink" title="创建人物属性(生命、无敌帧等)"></a>创建人物属性(生命、无敌帧等)</h3><h4 id="对象基本属性"><a href="#对象基本属性" class="headerlink" title="对象基本属性"></a>对象基本属性</h4><p>在<code>Scripts</code>下创建一个General文件，用于存储涉及人物计算内容的脚本：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726212005510.png" alt="image-20230726212005510"></p><p>可以将物理监测脚本拖到里边，创建新的用于创建人物属性的脚本<code>Character</code></p><p>然后将代码作为组件挂载到角色和怪物身上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726212159946.png" alt="image-20230726212159946"></p><p>定义人物属性内容表格：</p><table><thead><tr><th>人物属性</th><th>值类型</th></tr></thead><tbody><tr><td>最大血量</td><td>maxHealth</td></tr><tr><td>当前血量</td><td>currentHealth</td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103242277.png" alt="image-20230727103242277"></p><h4 id="对象攻击伤害"><a href="#对象攻击伤害" class="headerlink" title="对象攻击伤害"></a>对象攻击伤害</h4><p>在<code>General</code>文件下再创建一个人物攻击属性的脚本<code>Attack</code></p><p>然后将代码作为组件挂载到角色和怪物身上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726215325495.png" alt="image-20230726215325495"></p><p>定义人物属性内容表格：</p><table><thead><tr><th>攻击属性</th><th>值类型</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>在<code>Character</code>脚本下定义一个受到攻击减少血量的方法：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103447232.png" alt="image-20230727103447232"></p><p>在<code>Attack</code>脚本下定义用于调用受到伤害进行减少的方法，由于是当角色和怪物进行<strong>接触</strong>时受到伤害，所以直接用<code>OnTriggerStay2D</code>这个已经封装好的方法即可：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103320281.png" alt="image-20230727103320281"></p><p>编辑受到伤害的逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727105056504.png" alt="image-20230727105056504"></p><h5 id="设置无敌帧"><a href="#设置无敌帧" class="headerlink" title="设置无敌帧"></a>设置无敌帧</h5><p>由于没有设置无敌时间，所以当人物经过怪物时相当于一次性受到很多次伤害，所以我们要通过设置无敌帧来保证人物不会在碰到怪物的一瞬间丢失大量血量：</p><p>首先定义我们需要的无敌属性数值内容表格</p><table><thead><tr><th>无敌属性</th><th>值类型</th></tr></thead><tbody><tr><td>无敌时间</td><td>invulnerableDucation</td></tr><tr><td>计时器</td><td>invulnerableCounter</td></tr><tr><td>状态</td><td>invulnerable</td></tr></tbody></table><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727170630799.png" alt="image-20230727170630799"></p><p>定义逻辑：</p><p>1、定义状态更改(即受到一次伤害后就切换此时状态为无敌)</p><p>目的：保证受到伤害在一定时间内不会连续</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171024371.png" alt="image-20230727171024371"></p><p>2、在攻击造成后即刻调用状态更改方法，同时赋值给计时器</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171217165.png" alt="image-20230727171217165"></p><p>3、对计时器进行计时，使其在无敌时间后再次切回正常状态</p><p>该逻辑要在生命周期内进行，让计时器每一帧都进行计算</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171300825.png" alt="image-20230727171300825"></p><p><code>Time.deltaTime</code>概述：完成上一帧所用的时间</p><p>最后进行细节修正：</p><p><code>Attack</code>下</p><p><img src="/./../../../typora-images/image-20230727171750740.png" alt="image-20230727171750740"></p><p><code>Character</code>下</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171917366.png" alt="image-20230727171917366"></p><h2 id="受伤和死亡的逻辑和动画"><a href="#受伤和死亡的逻辑和动画" class="headerlink" title="受伤和死亡的逻辑和动画"></a>受伤和死亡的逻辑和动画</h2><p>死亡动画应该临界于其他所有动画之上！</p><h3 id="受伤和死亡动画"><a href="#受伤和死亡动画" class="headerlink" title="受伤和死亡动画"></a>受伤和死亡动画</h3><ul><li>受伤动画</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143528831.png" alt="image-20230728143528831"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143634190.png" alt="image-20230728143634190"></p><ul><li>死亡动画</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143815226.png" alt="image-20230728143815226"></p><h3 id="受伤部分"><a href="#受伤部分" class="headerlink" title="受伤部分"></a>受伤部分</h3><h4 id="实现闪烁效果"><a href="#实现闪烁效果" class="headerlink" title="实现闪烁效果"></a>实现闪烁效果</h4><p>新建图画图层：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728175851676.png" alt="image-20230728175851676"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728175920867.png" alt="image-20230728175920867"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730113458522.png" alt="image-20230730113458522"></p><p>新建动画：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729114327234.png" alt="image-20230729114327234"></p><p><strong>通过<code>Add Property</code>可以修改不同组件的参数，从而实现在一个时间轴上不同组件参数发生变化从而达到不同效果</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729115020970.png" alt="image-20230729115020970"></p><p>可以通过角色的<code>Sprite Renderer</code>(材质)更改颜色来实现闪烁效果：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729115630045.png" alt="image-20230729115630045"></p><p>回到动画界面点击Add Property添加我们需要更改的组件，同时选择我们要更改的组件里边的值：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120058423.png" alt="image-20230729120058423"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120317586.png" alt="image-20230729120317586"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120345687.png" alt="image-20230729120345687"></p><p>将动画添加到叠加图层(Hurt Layer)并创建切换的条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105020022.png" alt="image-20230730105020022"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105136134.png" alt="image-20230730105136134"></p><p>Setting跟前边的动画一样设置为无勾选状态，其他数值都为0即可</p><p>再设置一个返回连线，当动画播放完毕后返回原始动画：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105330911.png" alt="image-20230730105330911"></p><h5 id="▲事件方法-UnityEvent-使用方法"><a href="#▲事件方法-UnityEvent-使用方法" class="headerlink" title="▲事件方法(UnityEvent 使用方法)"></a>▲事件方法(UnityEvent 使用方法)</h5><p>在<code>PlayerAnimation</code>动画控制脚本中定义动画切换的方法，只有角色被怪物打到(受到伤害时)才会让<code>hurt</code>值被勾选，从而进行<strong>闪烁效果的播放</strong>：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105831235.png" alt="image-20230730105831235"></p><p><code>Character</code>角色属性脚本受伤部分定义逻辑：</p><ul><li>导入事件包，通过事件类来快速编辑条件</li></ul><p><strong>目的：可以在unity的UI界面上很快添加我们需要的条件</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730110437329.png" alt="image-20230730110437329"></p><p>当在脚本中创建完成后返回unity即可看到：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730110842721.png" alt="image-20230730110842721"></p><ul><li>将我们需要的条件添加进去(将条件注册进事件中)</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111137659.png" alt="image-20230730111137659"></p><p>这是要更改的对象，也就是<strong>条件触发的对象(Player)<strong>，然后选择Function，也就是我们要</strong>触发的组件的方法</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111342721.png" alt="image-20230730111342721"></p><ul><li>启动事件</li></ul><p>直接调用Invoke方法即可</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111857591.png" alt="image-20230730111857591"></p><h4 id="受伤后有反弹效果"><a href="#受伤后有反弹效果" class="headerlink" title="受伤后有反弹效果"></a>受伤后有反弹效果</h4><p>在<code>PlayerController</code>编写反弹逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730115708885.png" alt="image-20230730115708885"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730115849249.png" alt="image-20230730115849249"></p><p>细节修改：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730120013477.png" alt="image-20230730120013477"></p><p>实现当受伤时不能移动</p><p>在事件中注册条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730131525691.png" alt="image-20230730131525691"></p><p>这样就完成了反弹效果，但是还会有新的问题——即人物反弹距离后会一直倒退且此时无法移动，如何解决：</p><h5 id="动画过程执行代码-Animator-Behavior-代码的使用方法"><a href="#动画过程执行代码-Animator-Behavior-代码的使用方法" class="headerlink" title="动画过程执行代码(Animator Behavior 代码的使用方法)"></a>动画过程执行代码(Animator Behavior 代码的使用方法)</h5><p><strong>在动画执行过程中进行代码的变化，通过</strong><code>Animator Behavior</code>来进行实现</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133104530.png" alt="image-20230730133104530"></p><p>创建一个新的Behaviour</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133155292.png" alt="image-20230730133155292"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133316667.png" alt="image-20230730133316667"></p><p>在脚本中编辑新逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133914793.png" alt="image-20230730133914793"></p><p>这样就完成了反弹效果的最终实现</p><h3 id="死亡部分"><a href="#死亡部分" class="headerlink" title="死亡部分"></a>死亡部分</h3><p>在动画控制器中的叠加图层添加动画，同时创建一个新的判断值<code>isDead</code></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730140558570.png" alt="image-20230730140558570"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730140723952.png" alt="image-20230730140723952"></p><p>创建连线并添加条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141006077.png" alt="image-20230730141006077"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141022745.png" alt="image-20230730141022745"></p><p>连接退出的条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141124749.png" alt="image-20230730141124749"></p><p>在<code>Character</code>角色属性脚本中添加死亡逻辑：</p><p>先创建对应的死亡事件，这样可以在unityUI界面上直接添加条件</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141558463.png" alt="image-20230730141558463"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141614824.png" alt="image-20230730141614824"></p><h4 id="死亡后不能操作"><a href="#死亡后不能操作" class="headerlink" title="死亡后不能操作"></a>死亡后不能操作</h4><p>在<code>PlayerController</code>角色控制脚本中添加新的死亡逻辑，实现死亡后不允许操作的逻辑：</p><p>创建isDead布尔类型变量，创建死亡对应的方法来关闭玩家操作内容</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142014143.png" alt="image-20230730142014143"></p><p>在<code>PlayerAnimation</code>动画控制脚本中添加对应的获取死亡条件(isDead)值的方法：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142215642.png" alt="image-20230730142215642"></p><p>最后将要进行的组件的方法作为条件注册到事件上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142651164.png" alt="image-20230730142651164"></p><p>这样就完成了死亡事件的绑定与动画的播放，但还有一个问题——即人物死亡动画会一直播放，该如何解决：</p><p>在动画控制器中<strong>取消循环播放的勾选</strong>即可</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730143102875.png" alt="image-20230730143102875"></p><p>这样就完成了整个死亡过程的功能实现</p><p>最终的脚本代码：</p><p>角色控制脚本<code>PlayerController</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跑步速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//行走速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳跃的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否下蹲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line">    <span class="comment">//碰撞体的两个变量(大小和位移)</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line">    <span class="comment">//反弹力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="comment">//private void OnTriggerStay2D(Collider2D other)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    Debug.Log(other.name);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色受伤对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GerHurt</span>(<span class="params">Transform attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2((transform.position.x - attacker.position.x), <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色死亡对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerDead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">        inputControl.GamePlay.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色(对象)属性脚本<code>Character</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被攻击方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色(对象)攻击属性脚本<code>Attack</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Attack</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> attackRange;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> attackRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.GetComponent&lt;Character&gt;()?.TakeDamage(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色动画控制方法<code>PlayerAnimation</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAnimation</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册的是动画控制器——Animator</span></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理所有动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityX&quot;</span>, Mathf.Abs(rb.velocity.x));</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityY&quot;</span>,rb.velocity.y);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isGround&quot;</span>, physicsCheck.isGround);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isCrouch&quot;</span>, playerController.isCrouch);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isDead&quot;</span>, playerController.isDead);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayHurt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（三）</title>
      <link href="/2023/07/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/07/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（三）"><a href="#Unity开发日记（三）" class="headerlink" title="Unity开发日记（三）"></a>Unity开发日记（三）</h1><h2 id="物理环境监测"><a href="#物理环境监测" class="headerlink" title="物理环境监测"></a>物理环境监测</h2><p>为角色新建物理监测脚本：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724144429242.png" alt="image-20230724144429242"></p><p>将脚本作为组件添加到Player上边</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724144544646.png" alt="image-20230724144544646"></p><p>开始编写脚本内容来实现物理环境监测</p><p>1、采用<code>Physics2D.OverlapCirle</code>函数来实现对地面的检测（即角色是否站在地面上）</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150614684.png" alt="image-20230724150614684"></p><p>其他参数作用(参考unity帮助文档)：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150329357.png" alt="image-20230724150329357"></p><p>角色坐标位置原点：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150734119.png" alt="image-20230724150734119"></p><p>如果角色是在地面上，也就是此时的OverlapCircle函数返回为<code>true</code>，赋值给isGround：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151028928.png" alt="image-20230724151028928"></p><p><strong><code>groundLayer</code>字段的作用：</strong></p><p>如果同地面上（不同图层）有不同的内容，诸如草坪，花朵，蘑菇等等物品，此时同处于地面，但实际我们要检测的是地面，这时候就要通过指定图层（地面所在图层）来保证准确度</p><p>2、为地面图层添加指定的<code>Layer</code></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151544307.png" alt="image-20230724151544307"></p><p>随后返回Player，为Player绑定字段（<strong>checkRedius，GroundLayer</strong>）需要的内容：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151737704.png" alt="image-20230724151737704"></p><p>最后进行测试，运行后看角色落地时<code>Is Ground</code>会不会自动打勾(true)</p><p>3、两个脚本进行交互，修改代码使得只有在地面上人物才能跳跃</p><p>在<code>Player Controller</code>脚本获得<code>Physics Check</code>组件并实现代码的修改：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724152639393.png" alt="image-20230724152639393"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724152708180.png" alt="image-20230724152708180"></p><h3 id="提高物理环境检测度"><a href="#提高物理环境检测度" class="headerlink" title="提高物理环境检测度"></a>提高物理环境检测度</h3><p>希望通过设置一个可以移动的球形来提高检测的精确度</p><p>在<code>PhysicsCheck</code>脚本中编写一个数组作为脚底位移差值（类型为Vector2，也就是坐标）：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724153317363.png" alt="image-20230724153317363"></p><p>如何把位置绘制出来？</p><p>可以通过<code>OnDrawGizmosSelected()</code>来编写对应的内容，从而实现在我们的人物检测点上绘制出可以偏移的圆：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724154852398.png" alt="image-20230724154852398"></p><p>Gizmos → <img src="/./../../../typora-images/image-20230724154924999.png" alt="image-20230724154924999"></p><p>最终呈现效果为：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155117790.png" alt="image-20230724155117790"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155225067.png" alt="image-20230724155225067"></p><h3 id="为人物物理设置光滑材质"><a href="#为人物物理设置光滑材质" class="headerlink" title="为人物物理设置光滑材质"></a>为人物物理设置光滑材质</h3><p>目的：让人物不会黏在墙上</p><p>在Setting文件夹下边创建Physics Material文件夹，然后创建一个新的物理材质</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155853805.png" alt="image-20230724155853805"></p><p>将材质的摩擦力设置为0，然后为其添加到角色的<code>Capsule Collider 2D</code>上：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155953343.png" alt="image-20230724155953343"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724160045644.png" alt="image-20230724160045644"></p><h2 id="人物动画"><a href="#人物动画" class="headerlink" title="人物动画"></a>人物动画</h2><h3 id="创建动画控制器-Animator"><a href="#创建动画控制器-Animator" class="headerlink" title="创建动画控制器(Animator)"></a>创建动画控制器(Animator)</h3><p>定位我们需要的动画素材，对动画素材进行切割(前边已经完成好)</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725144257817.png" alt="image-20230725144257817"></p><p>为角色添加<code>Animator</code>组件（<strong>动画控制器</strong>）</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725144627362.png" alt="image-20230725144627362"></p><p>可以看出还需要添加控制器，所以下一步是创建动画控制器：</p><p>在Assets文件夹下创建Animations文件夹，用于存放接下来需要的各个角色对象的动画控制器，然后创建对应需要的角色文件夹</p><p>在文件夹下再创建<code>Animator Controller</code></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145027557.png" alt="image-20230725145027557"></p><p>然后将该动画控制器添加到<code>Animator</code>组件中的Controller进行绑定：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145125736.png" alt="image-20230725145125736"></p><p>如何查看角色的动画控制器？</p><p>选中角色后，在Window界面上点击Animator进入动画控制器界面</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145342160.png" alt="image-20230725145342160"></p><p>界面效果如图：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145401878.png" alt="image-20230725145401878"></p><h3 id="创建动画-Animation"><a href="#创建动画-Animation" class="headerlink" title="创建动画(Animation)"></a>创建动画(Animation)</h3><p>点击角色，然后在Window选项中选择Animation，创建单个动画</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145801677.png" alt="image-20230725145801677"></p><p>随后会打开对应的页面</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145822866.png" alt="image-20230725145822866"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150003535.png" alt="image-20230725150003535"></p><p>选中我们要播放的动画，将其拖拽到Animation界面上：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150204019.png" alt="image-20230725150204019"></p><p>可以在Animation界面的播放按钮预览当前动画效果</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150430260.png" alt="image-20230725150430260"></p><p><code>Samples</code>越高播放越快</p><p>以上就完成了角色待机动画的创建，接下来还要进行其他动作动画（跳跃，攻击等）的创建，快捷创建Animations：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150953853.png" alt="image-20230725150953853"></p><p>创建跑步的Animation，将对应的动画片段丢到Animation界面中即可：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725151344859.png" alt="image-20230725151344859"></p><h3 id="动画控制器控制动画"><a href="#动画控制器控制动画" class="headerlink" title="动画控制器控制动画"></a>动画控制器控制动画</h3><p>动画(Animation)创建完毕后会在<strong>Animatior</strong>界面上出现对应的容器，在界面中每个块也叫做<strong>状态</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153029470.png" alt="image-20230725153029470"></p><p>不同状态之间建立连接：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153113643.png" alt="image-20230725153113643"></p><p>创建连接线连接到另外一个状态上</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153140621.png" alt="image-20230725153140621"></p><h4 id="为动画切换设置条件"><a href="#为动画切换设置条件" class="headerlink" title="为动画切换设置条件"></a>为动画切换设置条件</h4><p>选中连接线，可以在右边界面看到条件框：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153444747.png" alt="image-20230725153444747"></p><p>**PS:**虽然右边有条件框，但实际上动画切换条件的创建是在左边的<code>Parameters</code>选项下边进行创建</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153843140.png" alt="image-20230725153843140"></p><p>在Parameters下创建对应的条件内容后，回到右边的<code>Conditions</code>框架内添加我们刚创建的条件内容：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154055498.png" alt="image-20230725154055498"></p><p>然后还要对Setting里边的内容进行更改：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154245042.png" alt="image-20230725154245042"></p><p>由于是2D游戏，我们不需要设置以上内容，所以全部关闭及设置0</p><p>然后补齐条件，将其设置为小于0.1时就相当于切换跑步动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725160331146.png" alt="image-20230725160331146"></p><p>此时还没有完成动画切换条件的设置，因为虽然条件设置了只有<code>&lt; 0.1</code>时会让动画控制器切换动画，但是我们还缺少给<code>velocityX</code>赋值的内容，所以接下来就是要在脚本内容中设置如何获得我们需要的数值</p><h3 id="创建管理控制动画的脚本"><a href="#创建管理控制动画的脚本" class="headerlink" title="创建管理控制动画的脚本"></a>创建管理控制动画的脚本</h3><p>在<code>Script</code>下Player文件夹下创建新的控制动画的脚本<code>PlayerAnimation</code>并将其添加到角色的组件中去：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154759439.png" alt="image-20230725154759439"></p><p>编辑脚本内容：</p><p><strong>通过采用Animator类中的SetFloat方法来设置我们需要的切换动画条件的值</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725155550588.png" alt="image-20230725155550588"></p><p><code>SetFloat</code>方法内参数的含义：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725155120625.png" alt="image-20230725155120625"></p><p>需要注意的是：</p><p>此时第二个参数<code>rb.velocity.x</code>虽然获取到了x轴的数值，但是由于我们在切换动画的条件内设置的是<code>&gt; velocity.x</code>，这会导致当我们启动的时候，角色向左跑(<strong>velocity.x&lt;0，为负数**)不会有跑步动画，但是向右跑(**velocity.x&gt;0，为正数</strong>)会有跑步动画</p><p>所以要进行修改：<code>Mathf.Abs</code>取绝对值</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725160121359.png" alt="image-20230725160121359"></p><h3 id="人物行走设定"><a href="#人物行走设定" class="headerlink" title="人物行走设定"></a>人物行走设定</h3><p>目的：当我们按下<code>Shift</code>键时强制切换为<strong>行走状态</strong></p><p>在输入系统<code>Input System</code>下的人物控制器创建新的<code>Action</code>:</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728144847625.png" alt="image-20230728144847625"></p><p>添加监听的按键：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728145053304.png" alt="image-20230728145053304"></p><p>在<code>PlayerController</code>脚本中编写实现走路的逻辑： 即<strong>速度减少一半相当于走路</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728145920650.png" alt="image-20230728145920650"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728151410721.png" alt="image-20230728151410721"></p><p>这样完成后还有其它问题：</p><ul><li>切换走路后再切回来，速度没有变化(speed&#x2F;2)</li><li>切换走路后没有变成走路动画</li></ul><p>细节修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      ........</span><br><span class="line">          </span><br><span class="line">       <span class="meta">#<span class="keyword">region</span> 切换行走状态</span></span><br><span class="line">       runSpeed = speed;</span><br><span class="line">       </span><br><span class="line">       inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">           &#123;</span><br><span class="line">               speed = walkSpeed;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">           &#123;</span><br><span class="line">               speed = runSpeed;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用<code>region - endregion</code>方便管理代码块</p><p>添加正常走路动画并为其设置相应的动画转换连接线和切换条件</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725164245728.png" alt="image-20230725164245728"></p><h2 id="跳跃动画"><a href="#跳跃动画" class="headerlink" title="跳跃动画"></a>跳跃动画</h2><p>跳跃动画主要分为：<strong>起跳阶段和落地阶段</strong></p><p>先按人物基础动画制作流程将跳跃的四个阶段和落地的一个阶段对应的五个Animation创建出来：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205145663.png" alt="image-20230725205145663"></p><p>由于这五个动画本质上都是实现跳跃，只是跳跃时期的不同阶段而已，所以可以采用<strong>混合树</strong>的方法将其整合到一起：</p><p>1、先创建混合树</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205422475.png" alt="image-20230725205422475"></p><p>双击进入混合树的编辑页面：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205549185.png" alt="image-20230725205549185"></p><p>2、在Motion列表中添加需要的一系列动画(Animation)</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205803524.png" alt="image-20230725205803524"></p><p>将四个动画全部添加上去</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725210026603.png" alt="image-20230725210026603"></p><p>同时在动画控制器左边的框内要新创建一个Float值<code>velocityY</code>，最终可以看到</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726112724341.png" alt="image-20230726112724341"></p><p>3、设置混合树切换不同动画的数值结点(Threshold)</p><p>而如何设置不同动画对应的值：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726112227200.png" alt="image-20230726112227200"></p><p>同时要回到<code>PlayerAnimation</code>脚本中添加实时获取<code>velocityY</code>值的代码：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726113149472.png" alt="image-20230726113149472"></p><h3 id="动画控制器绑定跳跃动画"><a href="#动画控制器绑定跳跃动画" class="headerlink" title="动画控制器绑定跳跃动画"></a>动画控制器绑定跳跃动画</h3><h4 id="起跳阶段绑定"><a href="#起跳阶段绑定" class="headerlink" title="起跳阶段绑定"></a>起跳阶段绑定</h4><p>创建完成跳跃动画(<strong>起跳阶段</strong>)的混合树后，接下来就是要在动画控制器中绑定这个跳跃状态了，而我们要实现可以使用跳跃来打断其他动画的效果，就要利用初始的<code>Any State</code>连接我们的跳跃状态：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114132624.png" alt="image-20230726114132624"></p><p>同时在左边也创建一个新的判断值（isGround）：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114206154.png" alt="image-20230726114206154"></p><p>然后绑定该判断值以及修改其它设置：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114342644.png" alt="image-20230726114342644"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114406211.png" alt="image-20230726114406211"></p><p>同时也要在<code>PlayerAnimation</code>脚本中编写获取该值的代码：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726120633315.png" alt="image-20230726120633315"></p><p>这样就设置好了跳跃起跳这一阶段的动画，随后还要把跳跃落地阶段的动画添加进来，然后和跳跃起跳阶段的动画连接起来，实现整个跳跃的完整流程</p><h4 id="落地阶段绑定"><a href="#落地阶段绑定" class="headerlink" title="落地阶段绑定"></a>落地阶段绑定</h4><p>连接落地动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114801332.png" alt="image-20230726114801332"></p><p>设置切换的条件以及修改设置</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114849101.png" alt="image-20230726114849101"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726120833927.png" alt="image-20230726120833927"></p><p>最后将整个跳跃动画完成之后再进入初始的动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726115125515.png" alt="image-20230726115125515"></p><p>这样就能<strong>实现跳跃动作可以先打断其他动画的效果了</strong></p><h4 id="细节打断落地"><a href="#细节打断落地" class="headerlink" title="细节打断落地"></a>细节打断落地</h4><p>当在台阶下落地立马跑步的时候，把落地动画给打断</p><p>在落地阶段动画中连接<code>Exit</code>状态，并添加判断条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726121818956.png" alt="image-20230726121818956"></p><h2 id="下蹲动画与逻辑"><a href="#下蹲动画与逻辑" class="headerlink" title="下蹲动画与逻辑"></a>下蹲动画与逻辑</h2><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>下蹲动画分为两个阶段：<strong>开始下蹲</strong> 和 <strong>持续蹲姿</strong></p><p>流程为：当我们按下下蹲键时，先进行开始下蹲动画然后再进行持续蹲姿，如果我们没有送掉下蹲键那就一直保持蹲姿状态，一旦松掉按键就会恢复</p><ul><li>开始下蹲</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154049341.png" alt="image-20230728154049341"></p><ul><li>持续蹲姿</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154147725.png" alt="image-20230728154147725"></p><p>动画创建完成后接下来就是要进行绑定和条件切换</p><p>首先创建要用到的条件值<code>isCrouch</code>:</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154750038.png" alt="image-20230728154750038"></p><h4 id="使用次级动画选择器-Sub-State-进行内部切换"><a href="#使用次级动画选择器-Sub-State-进行内部切换" class="headerlink" title="使用次级动画选择器(Sub-State)进行内部切换"></a>使用次级动画选择器(Sub-State)进行内部切换</h4><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154940350.png" alt="image-20230728154940350"></p><p>创建连接线并设置条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162050645.png" alt="image-20230728162050645"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155102007.png" alt="image-20230728155102007"></p><p><strong>进入次级动画选择器进行动画切换的设置：</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155430276.png" alt="image-20230728155430276"></p><p>设置两个动画之间的连线并调整条件设置：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155537099.png" alt="image-20230728155537099"></p><p>设置动画退出的连线并设置条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155728936.png" alt="image-20230728155728936"></p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>在<code>PlayerController</code>控制脚本下进行下蹲逻辑的编辑：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160320535.png" alt="image-20230728160320535"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160403803.png" alt="image-20230728160403803"></p><p>将动画切换的条件也在<code>PlayerAnimation</code>脚本下进行添加：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160829537.png" alt="image-20230728160829537"></p><p>通过切换模式可以实现在不同界面上观看启动后的游戏画面：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162556187.png" alt="image-20230728162556187"></p><p>方便在运行时测试并观察碰撞体效果：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164018449.png" alt="image-20230728164018449"></p><h3 id="碰撞体在下蹲时也修改"><a href="#碰撞体在下蹲时也修改" class="headerlink" title="碰撞体在下蹲时也修改"></a>碰撞体在下蹲时也修改</h3><p>碰撞体的重要变量有：</p><ul><li>偏移位置Offset(X,Y)</li><li>长度Size(X,Y)</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162810773.png" alt="image-20230728162810773"></p><p>由于两个变量都是(X,Y)，所以写入代码时定义的变量为<strong>Vector2</strong></p><p>在<code>PlayerController</code>脚本内编辑碰撞体变化的逻辑：</p><p><strong>碰撞体的大小和位移的修改要在unity界面自己根据实际需求进行调整最后确定</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164054457.png" alt="image-20230728164054457"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164151581.png" alt="image-20230728164151581"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164232838.png" alt="image-20230728164232838"></p><p>最后可以在完善移动的细节：即当人物蹲下时不能进行移动</p><p>最终脚本修改完成后的代码：</p><p>人物控制脚本<code>PlayerController</code>代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="comment">//private void OnTriggerStay2D(Collider2D other)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    Debug.Log(other.name);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>环境监测脚本<code>Physics Check</code>代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        isGround = Physics2D.OverlapCircle((Vector2)transform.position+bottomOffset, checkReduis, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制动画的脚本<code>Player Animation</code>代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAnimation</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册的是动画控制器——Animator</span></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理所有动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityX&quot;</span>, Mathf.Abs(rb.velocity.x));</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityY&quot;</span>,rb.velocity.y);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isGround&quot;</span>, physicsCheck.isGround);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isCrouch&quot;</span>, playerController.isCrouch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（五）</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表（Hash Table），也称为散列表，是一种常用的数据结构，用于快速存储和查找键值对</p><p><img src="/./../../../typora-images/image-20230604202549205.png" alt="image-20230604202549205"></p><p>哈希表包含以下几个重要的部分：</p><ol><li>数组（Array）：数组是哈希表的基本数据结构，用于存储数据。<strong>数组中的每个元素称为桶（Bucket）或槽（Slot）</strong>，每个桶可以存储一个或多个键值对。</li><li>哈希函数（Hash Function）：哈希函数将键（Key）映射为哈希值（Hash Value），并用于确定键在数组中的存储位置。哈希函数的设计应该尽量减少冲突，即不同的键映射到相同的哈希值的概率较低。</li><li>冲突处理机制（Collision Resolution）：由于哈希函数的映射空间有限，不同的键可能会映射到相同的哈希值，导致冲突。冲突处理机制用于解决冲突，常见的方法包括链地址法和开放地址法。<ul><li>链地址法（Chaining）：每个桶存储一个链表或其他数据结构，相同哈希值的键值对存储在同一个桶中。当发生冲突时，新的键值对会添加到该桶的链表中。</li><li>开放地址法（Open Addressing）：发生冲突时，会通过一定的规则找到下一个可用的桶，将新的键值对存储在该桶中。常见的开放地址法包括线性探测、二次探测和双重哈希等。</li></ul></li><li>哈希表的存储过程：存储过程根据键的哈希值找到对应的桶，然后将键值对存储在桶中。如果发生冲突，根据冲突处理机制的规则，将新的键值对添加到桶的链表中或者找到下一个可用的桶。</li><li>哈希表的查找过程：查找过程根据键的哈希值找到对应的桶，然后在桶中查找目标键的值。如果桶中不存在目标键值对，则表示查找失败。如果存在冲突，根据冲突处理机制的规则，通过链表或其他方式遍历桶中的键值对，找到目标键的值。</li></ol><p>PS：<strong>哈希函数和数组：哈希函数根据键计算出哈希值，然后根据哈希值确定键在数组中的存储位置。</strong></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数（Hash Function）是一种将<strong>输入数据映射为固定长度哈希值</strong>（Hash Value）的函数。它的作用是将任意大小的输入数据转换为固定大小的输出，通常是一个整数或固定长度的字节数组。</p><p>哈希函数具有以下特性：</p><ol><li><strong>一致性</strong>：相同的输入始终产生相同的输出。即使输入数据发生微小的改变，输出结果也会有较大的差异。</li><li><strong>高效性</strong>：哈希函数的计算速度应该很快，能够在常数时间内完成计算。</li><li><strong>均匀性</strong>：哈希函数应该将输入数据均匀地映射到哈希值空间中，尽量减少哈希冲突的概率。</li></ol><h2 id="哈希表的存储方式"><a href="#哈希表的存储方式" class="headerlink" title="哈希表的存储方式"></a>哈希表的存储方式</h2><p>过程：</p><ol><li>计算哈希值：使用哈希函数对键进行计算，得到一个哈希值。哈希函数将键映射到哈希表的索引位置。</li><li>定位桶：根据哈希值定位到哈希表的对应桶（Bucket），即确定要存储键值对的位置。</li><li>冲突处理：如果发生哈希冲突，即多个键映射到同一个桶的情况，需要进行冲突处理。常见的冲突处理机制包括链地址法、开放地址法或公共溢出区域法，根据具体的冲突处理机制来存储键值对。</li><li>存储键值对：将键值对存储在确定的桶中。具体的存储方式取决于采用的冲突处理机制。对于链地址法，将键值对添加到桶的链表或其他数据结构中。对于开放地址法，将键值对存储在可用的桶中，或者按照一定的规则探测下一个可用的桶。对于公共溢出区域法，将键值对存储在共享的溢出区域中，并在桶中存储溢出区域的索引。</li><li>完成存储：存储过程完成后，键值对就被成功存储在哈希表中，可以通过哈希表的索引和冲突处理机制来进行快速的查找和访问。</li></ol><h2 id="哈希表的实现方式"><a href="#哈希表的实现方式" class="headerlink" title="哈希表的实现方式"></a>哈希表的实现方式</h2><ul><li>数组＋链表</li><li>数组＋二叉树</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（二）</title>
      <link href="/2023/06/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/06/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（二）"><a href="#Unity开发日记（二）" class="headerlink" title="Unity开发日记（二）"></a>Unity开发日记（二）</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="设置人物"><a href="#设置人物" class="headerlink" title="设置人物"></a>设置人物</h3><p>为人物添加重力组件</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605111521201.png" alt="image-20230605111521201"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605111704469.png" alt="image-20230605111704469"></p><p>人物添加了重物组件，但是由于还没有加入碰撞组件，所以启动时人物会一直往下落</p><p>为人物添加碰撞组件：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112043971.png" alt="image-20230605112043971"></p><p>此时回到Sense界面可以看到人物的碰撞框架</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112258723.png" alt="image-20230605112258723"></p><p>这时可以通过选择框架来调整他的碰撞体积大小：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112328974.png" alt="image-20230605112328974"></p><p>通过框架的上下左右<strong>四个点</strong>来自定义调整大小，也可以通过快捷键<code>Alt</code>来进行对称调整</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112549109.png" alt="image-20230605112549109"></p><p>也可以通过框架大小数值调整直接进行：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112803391.png" alt="image-20230605112803391"></p><p>为角色下边的平台也设置上碰撞体积：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605132831942.png" alt="image-20230605132831942"></p><p>此时每个瓦片都有一个体积碰撞</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605132957771.png" alt="image-20230605132957771"></p><p>通过添加另外一个新组件，可以实现将所有瓦片都视为一个体积碰撞</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133047191.png" alt="image-20230605133047191"></p><p>此时就可以在我们设置的平台碰撞体积上进行合并</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133201147.png" alt="image-20230605133201147"></p><p>最终所有瓦片的体积碰撞也被我们合并了起来：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133224377.png" alt="image-20230605133224377"></p><p>由于对瓦片增加了相应的碰撞体积组件，在对其添加后会自动为场景也设置上对应的<code>Rigdbody 2D</code>组件，这会导致当我们运行的时候场景也会受到重力影响一直往下掉落，所以还要对该组件进行另外设置：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133639482.png" alt="image-20230605133639482"></p><p>这样就能够实现角色不会永久下落，而是站立在场景上，但另外一个问题是当角色的初始角度过高或者角色此时有一定旋转角度，这时候运行就会使得角色落地后倒在场景位置上，所以还要对角色的旋转角度固定住：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605134021135.png" alt="image-20230605134021135"></p><p>PS：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605134932789.png" alt="image-20230605134932789"></p><h3 id="创建配置输入系统"><a href="#创建配置输入系统" class="headerlink" title="创建配置输入系统"></a>创建配置输入系统</h3><p>Assets目录下创建存放相关代码的Scripts包，包下再创建存放人物代码的Player文件夹</p><p>在Player文件夹下创建C#脚本</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608131329662.png" alt="image-20230608131329662"></p><p>为角色添加刚创建的脚本：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608132240279.png" alt="image-20230608132240279"></p><h4 id="修改输入系统"><a href="#修改输入系统" class="headerlink" title="修改输入系统"></a>修改输入系统</h4><p>Edit → Project Setting → Player → OtherSetting</p><p>在OtherSetting界面上修改：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608140209592.png" alt="image-20230608140209592"></p><p>应用成功后进行下一步修改，回到主页面</p><p>Window选项 → Package Manager</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608141540290.png" alt="image-20230608141540290"></p><p>安装input system</p><p>开始创建输入系统</p><ul><li><strong>手动创建方式：</strong></li></ul><p>在Setting文件夹下创建Input System文件包，在Input System文件包下创建输入系统：</p><p>点击左上角＋号添加</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230610100557802.png" alt="image-20230610100557802"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230610100701487.png" alt="image-20230610100701487"></p><p>点击进入控制面板，创建Action Map，同时创建我们需要的Action</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165032497.png" alt="image-20230701165032497"></p><p>例如创建对键盘键位的读取，选择Action类型为<code>Value</code>值，控制的类型为坐标系<code>Vector 2</code></p><p>同时可以对Action下各个内容进行绑定</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165227129.png" alt="image-20230701165227129"></p><p>这样就完成了对键盘按键的监测</p><p>此外，此时再次添加了一个对手柄的监测：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165448116.png" alt="image-20230701165448116"></p><p>在这时候要添加控制的配置表来定义什么时候用什么监测</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165636012.png" alt="image-20230701165636012"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165855881.png" alt="image-20230701165855881"></p><p>添加完后可以为每个Action选择对应的配置：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701170037503.png" alt="image-20230701170037503"></p><ul><li><strong>自动创建方式：</strong></li></ul><p>选择角色，在添加组件中选择player input</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707165749383.png" alt="image-20230707165749383"></p><p>随后在右侧<code>Create Action</code>创建Action，选择我们即将要创建的文件夹，修改名字并创建完成后，它就会自动帮我们生成需要的Action</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707170057614.png" alt="image-20230707170057614"></p><p>如果要改成用代码来操控的话，需要先生成对应的C#代码：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707170757832.png" alt="image-20230707170757832"></p><p>在选择角色后右侧显示的框架内进入PlayerController代码中，在PlayerController导入刚创建好的操作脚本，同时定义脚本启用的情况：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172051050.png" alt="image-20230707172051050"></p><p>问题：什么情况下是启用？什么情况下是关闭？</p><p>当<img src="/./../images/unity(%E4%BA%8C)/image-20230707172142841.png" alt="image-20230707172142841"></p><p>开启或关闭时就相当于程序中调用开启和关闭</p><p>获取MoveAction中的操控值：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172701984.png" alt="image-20230707172701984"></p><p>MoveAction对应的值为Vector 2，所以在C#上也要定义对应的类型来获取：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172627352.png" alt="image-20230707172627352"></p><p>保存后可以看到界面上多了我们新设置的操控值：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172820364.png" alt="image-20230707172820364"></p><p>接下来要设置一个更新方法，来获取每一帧我们移动的操作：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707173302355.png" alt="image-20230707173302355"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707173329199.png" alt="image-20230707173329199"></p><h3 id="实现人物的运动"><a href="#实现人物的运动" class="headerlink" title="实现人物的运动"></a>实现人物的运动</h3><p><strong>如果一个物品绑定了一个刚体，那么运动是通过刚体来进行的</strong></p><h4 id="人物移动"><a href="#人物移动" class="headerlink" title="人物移动"></a>人物移动</h4><ul><li>如何通过速度来驱动物体</li></ul><p>在<code>PlayerController</code>控制脚本中添加一个新的速度属性，来让前文编写的Vector2的左右值给到它</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713110452782.png" alt="image-20230713110452782"></p><p>这样就能在unity的图形界面中也能看到新的速度边框了：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713110530151.png" alt="image-20230713110530151"></p><p>接下来要在控制脚本中也编写一个刚体属性，绑定到unity上边我们需要用到的刚体，从而让后续的动作操作能够执行：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111020075.png" alt="image-20230713111020075"></p><p>在unity界面上查看并进行绑定：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111120884.png" alt="image-20230713111120884"></p><p>PS：需要注意的是，此时刚体的属性为public，也就是为初始就能进行绑定，如果改为private的话，保存之后的unity界面并不会显示到该属性值，这样就不能做到一个初始化就绑定刚体的操作，需要用其他方式来获得</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111730448.png" alt="image-20230713111730448"></p><p>绑定速度实现左右移动(x，y)：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713112040013.png" alt="image-20230713112040013"></p><p>保持人物落地时的速度(默认0会导致人物下落时十分缓慢)：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230721183058351.png" alt="image-20230721183058351"></p><h4 id="人物翻转"><a href="#人物翻转" class="headerlink" title="人物翻转"></a>人物翻转</h4><ul><li>如何翻转人物(实现人物的调头)</li></ul><p>通过Scale的X或Y轴进行人物的翻转，最常用的是基于X轴进行的翻转</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722103424671.png" alt="image-20230722103424671"></p><p>在人物控制脚本中绑定并实现翻转：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722104136092.png" alt="image-20230722104136092"></p><h4 id="人物跳跃"><a href="#人物跳跃" class="headerlink" title="人物跳跃"></a>人物跳跃</h4><ul><li>如何实现人物的跳跃</li></ul><p>在<code>Input System</code>系统中添加新的Action：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722105454331.png" alt="image-20230722105454331"></p><p>然后在PlayerController控制脚本中绑定编写相关内容:</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722112247589.png" alt="image-20230722112247589"></p><p><strong><code>+=</code>符号表示注册内容，相当于把+&#x3D;后边的函数给到前边的内容</strong></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722112812139.png" alt="image-20230722112812139"></p><p>返回测试：</p><p>​注意：此时代码中虽然定义了jumpForce变量，但是并没有在脚本中进行赋值，赋值的地方可以在unity UI界面上手动添加值，然后保存就行</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113005867.png" alt="image-20230722113005867"></p><p>同时，为了让跳跃效果更好一点，可以按如下配置进行更改：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113128337.png" alt="image-20230722113128337"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113147187.png" alt="image-20230722113147187"></p><p>到这里为止，跳跃还会遇到的其他问题大致有：</p><ul><li>空中无限跳跃</li><li>跳完之后松开方向键没有惯性向前</li><li>按键时间长短和跳起高度的绑定</li></ul><p>最后完成的PlayerController脚本代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记 (一)</title>
      <link href="/2023/05/22/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/05/22/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（一）"><a href="#Unity开发日记（一）" class="headerlink" title="Unity开发日记（一）"></a>Unity开发日记（一）</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="对导入素材进行调整"><a href="#对导入素材进行调整" class="headerlink" title="对导入素材进行调整"></a>对导入素材进行调整</h3><p><strong>背景素材调整</strong>：</p><p>导入素材之后调整素材大小</p><p>比较简单粗糙的调整素材大小方式(<strong>一般开发不采用</strong>)：</p><p><img src="/../images/unity(%E4%B8%80)/1.png" alt="1"></p><p><img src="/../images/unity(%E4%B8%80)/2.png" alt="2"></p><p>较为常用的方式(通过像素点来按比例进行调整)：</p><p><code>Pixels Per Unit</code>代表每个格子当中显示多少个像素单位，根据美术素材的不同(16 * 16,32 * 32等)进行调整</p><p><img src="/../images/unity(%E4%B8%80)/3.png" alt="3"></p><p>同时还要进行调整的地方有：</p><p>一般像素游戏的渲染模式都会选择Point(即没有渲染)</p><p><img src="/../images/unity(%E4%B8%80)/4.png" alt="4"></p><p>调整压缩</p><p><img src="/../images/unity(%E4%B8%80)/5.png" alt="5"></p><p><strong>动作集(任务素材)调整</strong>：</p><p>如何查看总体动作素材集：</p><p><img src="/../images/unity(%E4%B8%80)/6.png" alt="6"></p><p>打开后的显示为：</p><p><img src="/../images/unity(%E4%B8%80)/7.png" alt="7"></p><p><strong>目的：</strong>对该图集进行切割，方便接下来开发流程中的使用</p><h4 id="切割图集"><a href="#切割图集" class="headerlink" title="切割图集"></a>切割图集</h4><p>首先调整图集：</p><p><img src="/../images/unity(%E4%B8%80)/8.png" alt="8"></p><p>下方的渲染和压缩同上进行修改即可</p><p><strong>开始进行素材的切割：</strong></p><p><img src="/../images/unity(%E4%B8%80)/9.png" alt="9"></p><p>调整切割方式：</p><p><img src="/../images/unity(%E4%B8%80)/10.png" alt="10"></p><p>切割后效果：</p><p><img src="/../images/unity(%E4%B8%80)/11.png" alt="11"></p><p>PS：切割后要记得应用<img src="/../images/unity(%E4%B8%80)/12.png" alt="12"></p><p>同时退出切割页面后，在编辑页面仍然要重新进行应用</p><p><img src="/../images/unity(%E4%B8%80)/13.png" alt="13"></p><p>最终对图片集展开就可以使用每一个已经被切割出来的素材图片了</p><p><img src="/../images/unity(%E4%B8%80)/14.png" alt="14"></p><h4 id="场景绘制"><a href="#场景绘制" class="headerlink" title="场景绘制"></a>场景绘制</h4><p>对对应的场景素材先进行相应的调整：</p><p><img src="/../images/unity(%E4%B8%80)/15.png" alt="15"></p><p><img src="/../images/unity(%E4%B8%80)/16.png" alt="16"></p><p>渲染和压缩也要进行调整，同其他素材一样调整为<code>Point</code>和<code>None</code></p><p>随后开始<strong>对素材进行切割</strong>：</p><p><img src="/../images/unity(%E4%B8%80)/17.png" alt="17"></p><p>完成切割：</p><p><img src="/../images/unity(%E4%B8%80)/18.png" alt="18"></p><p><strong>对场景进行绘制</strong>：</p><p>使用2D场景绘制工具进行场景的绘制</p><h5 id="调色盘的使用"><a href="#调色盘的使用" class="headerlink" title="调色盘的使用"></a>调色盘的使用</h5><p><img src="/../images/unity(%E4%B8%80)/19.png" alt="19"></p><p><strong>创建新的调色盘：</strong></p><p><img src="/../images/unity(%E4%B8%80)/20.png" alt="20"></p><p>在Assets同级目录下创建方便管理的调色盘文件夹Titlemap，进入Titlemap文件夹再次创建方便管理每一个瓦块的文件夹Palettes，最后选择Palettes文件夹完成创建调色盘的工作</p><p>完成调色盘的创建：</p><p><img src="/../images/unity(%E4%B8%80)/21.png" alt="21"></p><p><strong>将切割后的场景素材拖拽到调色盘界面上</strong>：</p><p><img src="/../images/unity(%E4%B8%80)/22.png" alt="22"></p><p>拖拽后会显示让你添加到哪个文件夹上，这时在Palettes文件夹同级目录下再次创建一个Tiles文件夹，进入该文件夹再次创建一个Forest 1文件夹进行存放所有要进行调色的素材</p><p>完成素材的拖拽后：</p><p><img src="/../images/unity(%E4%B8%80)/23.png" alt="23"></p><p>接下来就是要对每一个瓦片进行调整：</p><p>在编辑器上先创建Tilemap</p><p><img src="/../images/unity(%E4%B8%80)/24.png" alt="24"></p><p><img src="/../images/unity(%E4%B8%80)/25.png" alt="25"></p><p>这时我们的编辑器格子很明显</p><p><img src="/../images/unity(%E4%B8%80)/26.png" alt="26"></p><p>然后<strong>回到调色盘编辑界面（Tile Palette）进行选择：</strong></p><p><img src="/../images/unity(%E4%B8%80)/27.png" alt="27"></p><p>这时就可以选择我们想要的瓦片来进行绘制了</p><p><img src="/../images/unity(%E4%B8%80)/28.png" alt="28"></p><p>绘制完成后查看在游戏中的效果：</p><p>如果要更改画面中视距的效果，可以通过<code>Free Aspect</code>调整</p><p><img src="/../images/unity(%E4%B8%80)/29.png" alt="29"></p><p>最主要的调整方式还是通过相机来进行调整：</p><p><img src="/../images/unity(%E4%B8%80)/30.png" alt="30"></p><p>而在进行场景绘制的时候，如果场景挡住了人物，此时就可以用到<strong>叠层</strong></p><h4 id="叠层设置"><a href="#叠层设置" class="headerlink" title="叠层设置"></a>叠层设置</h4><p>通过对物体的<code>Sprite Renderer</code>组件内进行叠层设置</p><p><img src="/../images/unity(%E4%B8%80)/31.png" alt="31"></p><p><strong>其中<code>Sorting Layer</code>代表不同层，<code>Order in Layer</code>代表同层下不同次序</strong></p><p><img src="/../images/unity(%E4%B8%80)/32.png" alt="32"></p><p>为角色模型设置层次：</p><p><img src="/../images/unity(%E4%B8%80)/33.png" alt="33"></p><p>具体效果展示为：</p><p>当没有设置叠层时(即场景和人物的Layer都为Default)</p><p><img src="/../images/unity(%E4%B8%80)/34.png" alt="34"></p><p>当为角色设置完层次之后</p><p><img src="/../images/unity(%E4%B8%80)/35.png" alt="35"></p><p>同理，通过叠层设置背景效果：</p><p><img src="/../images/unity(%E4%B8%80)/36.png" alt="36"></p><p>通过<code>Tilemap Focus</code>小工具来选定Tilemap，从而让我们更清晰的知道我们当前编辑或要编辑的图层是哪一个</p><p><img src="/../images/unity(%E4%B8%80)/37.png" alt="37"></p><h4 id="规则瓦片和动态瓦片"><a href="#规则瓦片和动态瓦片" class="headerlink" title="规则瓦片和动态瓦片"></a>规则瓦片和动态瓦片</h4><h5 id="规则瓦片"><a href="#规则瓦片" class="headerlink" title="规则瓦片"></a>规则瓦片</h5><p>作用：能够高效率地绘制出相对完整的地图，通过自定义不同瓦片来实现</p><p>在瓦片文件夹(Tiles)下新建存放的规则瓦片文件夹(Rule Tiles)，在该文件夹下创建规则瓦片</p><p><img src="/../images/unity(%E4%B8%80)/38.png" alt="38"></p><p>先对切割好的场景素材重新命名，方便接下来规则瓦片的使用</p><p>命名完成后开始进行规则瓦片的编辑：</p><p><img src="/../images/unity(%E4%B8%80)/39.png" alt="39"></p><p>选择瓦片，同时<strong>定义该瓦片在什么情况下出现</strong></p><p><img src="/../images/unity(%E4%B8%80)/40.png" alt="40"></p><p><img src="/../images/unity(%E4%B8%80)/41.png" alt="41"></p><p>部分瓦片（例如地面中间部分的瓦片）可以进行随机</p><p><img src="/../images/unity(%E4%B8%80)/42.png" alt="42"></p><p><img src="/../images/unity(%E4%B8%80)/43.png" alt="43"></p><p>PS：<code>Noise</code>表示在随机的几个中的比重</p><p>添加完成</p><p><img src="/../images/unity(%E4%B8%80)/44.png" alt="44"></p><p>接下来需要把我们自定义的规则瓦片添加到调色盘上，从而让我们可以直接拿去绘制</p><p><img src="/../images/unity(%E4%B8%80)/45.png" alt="45"></p><p>绘制测试效果</p><p><img src="/../images/unity(%E4%B8%80)/46.png" alt="46"></p><p>拐角处的瓦片过渡不自然，所以要再次修改规则瓦片，添加对应的转角处瓦片</p><p><img src="/../images/unity(%E4%B8%80)/47.png" alt="47"></p><h5 id="动态瓦片"><a href="#动态瓦片" class="headerlink" title="动态瓦片"></a>动态瓦片</h5><p>作用：实现动态效果（比如瀑布）</p><p>原理：几个瓦片逐层逐帧进行切换，实现类似霓虹灯那样的视角效果，从而达到动态</p><p>在瓦片文件夹(Tiles)下新建存放的规则瓦片文件夹(Animated Tiles)，在该文件夹下创建规则瓦片</p><p><img src="/../images/unity(%E4%B8%80)/48.png" alt="48"></p><p>同时为我们要用到的瓦片进行修改命名，随后开始添加到动态瓦片中</p><p>假设瀑布现在要搞成3(列)*4(行)的形式，此时就要分别在左中右各设置一个包含四张瀑布的动态瓦片</p><p><img src="/../images/unity(%E4%B8%80)/49.png" alt="49"></p><p>保存后将该动态瓦片更新到调色盘上：</p><p><img src="/../images/unity(%E4%B8%80)/50.png" alt="50"></p><p>查看效果</p><p><img src="/../images/unity(%E4%B8%80)/51.png" alt="51"></p><p>可以调节动态瓦片的速度：</p><p><img src="/../images/unity(%E4%B8%80)/52.png" alt="52"></p><p>按该步骤继续完成第二列第三列的瀑布编辑</p><p><img src="/../images/unity(%E4%B8%80)/53.png" alt="53"></p><p>最终展示效果：<img src="/../images/unity(%E4%B8%80)/54.png" alt="54"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（四）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><strong>图的基本概念：</strong>在图形结构中，<strong>结点之间的关系可以是任意</strong>的，图中任意两个数据元素之间都可能相关</p><p>图的定义：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302092959390.png" alt="image-20230302092959390"></p><p>PS：线性表可以是空表，树可以是空树，但是<strong>图不可以是空图</strong>（图中不能一个顶点也没有）</p><h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ul><li>无向图</li></ul><p><strong>无向图中的边没有方向</strong>，(vi,vj)表示连接顶点vi和vj之间的一条边，即(vi,vj)和(vj,vi)表示的是同一条边</p><p>树是连通的无回路的无向图，若一棵树有n个顶点，则必有n-1条边</p><ul><li>有向图</li></ul><p><strong>有向图中的边有方向</strong>，&lt;vi,vj&gt;表示从顶点vi到vj的一条有向边，vi是边的起点，vj是边的终点，即&lt;vi,vj&gt;和&lt;vj,vi&gt;表示的不是同一条边</p><p>有向图还可分为<strong>简单图</strong>和<strong>多重图</strong></p><p>多重图：指图中两个顶点之间有重复边</p><ul><li>完全图</li></ul><p>完全图是边数打到最大值的图。若有n个顶点，则完全无向图的边数为<code>n(n-1)/2</code>,完全有向图的边数为<code>n(n-1)</code></p><ul><li>带权图</li></ul><p>带权图指图中的边具有权值（权值有不同的含义）</p><ul><li>邻接顶点</li></ul><p>若(vi，vj)是无向图中的一条边，则vi和vj互为邻接顶点，边(vi，vj)依附于顶点vi和vj</p><p>若&lt;vi，vj&gt;是有向图中的一条边，则vi邻接到vj，vj邻接自vi，边&lt;vi，vj&gt;与vi和vj相关联</p><h3 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h3><p>顶点的度是指与顶点vi关联的<strong>边数</strong>，记作<code>degree(vi)</code></p><p>度为0的顶点称为孤立点，度为1的顶点称为悬挂点</p><p>在有向图中，以<strong>vi为终点的边数称为vi的入度</strong>，记作<code>indegree(vi)</code>；<strong>以vi为起点的边数称为vi的出度</strong>，记作<code>outdegree(vi)</code></p><p>PS：在有向图中，顶点的度 &#x3D; 该顶点的出度 + 该顶点的入度</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><ul><li>路径</li></ul><p>接续的边构成的顶点序列</p><ul><li>路径长度</li></ul><p>路径上边或弧的数目&#x2F;权值之和（不带权图算边数，带权图算权数和）</p><ul><li>回路</li></ul><p>第一个顶点和最后一个顶点相同的路径</p><ul><li>简单路径</li></ul><p>除路径起点和终点可以相同外，其余顶点均不相同</p><ul><li>简单回路(环)</li></ul><p>除路径起点和终点相同且长度大于1的简单路径</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095321818.png" alt="image-20230302095321818"></p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095729492.png" alt="image-20230302095729492"></p><p>以下，(b)和(c)都是(a)的子图</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095751667.png" alt="image-20230302095751667"></p><p>若G1≠G，称图G1是G的<strong>真子图</strong></p><p>若G1是G的子图，但V1&#x3D;V，称G1是G的<strong>生成子图</strong></p><h3 id="连通性、生成树"><a href="#连通性、生成树" class="headerlink" title="连通性、生成树"></a>连通性、生成树</h3><p>在图G中，若从顶点vi到vj有路径，则称vi和vj是连通的。</p><p>若每对顶点vi和vj都是连通的，则称G为<strong>连通图</strong>(强连通图)<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100353660.png" alt="image-20230302100353660"></p><p>（无向图）<strong>非连通图</strong>的极大连通子图成为该图的<strong>连通分量</strong>；</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100519090.png" alt="image-20230302100519090"></p><p>(有向图) <strong>非强连通图</strong>的极大连通子图成为该图的<strong>强连通分量</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100650446.png" alt="image-20230302100650446"></p><p>连通无向图G的<strong>生成树</strong>是指G的一个<strong>极小连通生成子树</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302101202957.png" alt="image-20230302101202957"></p><p>各连通分量均为树的无向图称为森林</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵-数组表示"><a href="#邻接矩阵-数组表示" class="headerlink" title="邻接矩阵(数组表示)"></a>邻接矩阵(数组表示)</h3><p><strong>图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息</strong></p><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）</p><p><strong>无向图的邻接矩阵表示：</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302102452796.png" alt="image-20230302102452796"></p><p><strong>特点：</strong></p><p>无向图的邻接矩阵是对称的</p><p>顶点i的度 &#x3D; 第i行(列)中1的个数</p><p><strong>有向图的邻接矩阵表示：</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302102418265.png" alt="image-20230302102418265"></p><p>特点：</p><p>有向图的邻接矩阵可能是不对称的</p><p>顶点的出度 &#x3D; 第i行元素之和</p><p>顶点的入度 &#x3D; 第i列元素之和</p><p>顶点的度 &#x3D; 第i行元素之和+第i列元素之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="邻接表-链式"><a href="#邻接表-链式" class="headerlink" title="邻接表(链式)"></a>邻接表(链式)</h3><p>邻接表由两部分组成：<strong>表头结点表</strong>和<strong>边表</strong></p><p>邻接表中每个单链表的<strong>第一个结点</strong>存放有关<strong>顶点的信息</strong>，把这一结点看成链表的表头，<strong>其余结点存放有关边的信息</strong></p><p><strong>表头结点表：</strong>包括<strong>数据域</strong>和<strong>链域</strong>，数据域存储<strong>顶点的名称</strong>，链域用于指向链表中第一个结点（<strong>与顶点邻接的第一个顶点</strong>）</p><p><strong>边表：</strong>包括<strong>邻接点域</strong>（指示与顶点邻接的点在图中的位置，即<strong>数组下标</strong>）、(<strong>数据域</strong>（存储和边相关的信息，如<strong>权值</strong>）、)<strong>链域</strong>（指示<strong>与顶点邻接的下一条边的结点</strong>）</p><p>无向图的邻接表：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302131743954.png" alt="image-20230302131743954"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（三）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h2><p>树是由n(n&gt;&#x3D;1)个有限结点组成一个具有层次关系的集合</p><p>树具有以下特点：</p><ul><li>每个结点有零个或多个子结点</li><li>没有父结点的结点为根结点</li><li>每一个非根结点只有一个父结点</li><li>每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树</li></ul><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p><strong>结点的度：</strong></p><p>​一个结点含有的子树的个数称为该结点的度</p><p><strong>叶结点：</strong></p><p>​度为0的结点称为叶结点（也叫终端结点）</p><p><strong>分支结点：</strong></p><p>​度不为0的结点称为分支结点（也叫非终端结点）</p><p><strong>结点的层次：</strong></p><p>​从根结点开始，根结点的层次为1,根的直接后继层次为2，以此类推</p><p><strong>结点的层序编号：</strong></p><p>​将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数</p><p><strong>树的度：</strong></p><p>​树中所有结点的度的最大值</p><p><strong>树的高度：</strong></p><p>​树中结点的最大层次</p><p><strong>孩子结点：</strong></p><p>​一个结点的直接后继结点称为该结点的孩子结点</p><p><strong>双亲结点：</strong></p><p>​一个结点的直接前驱称为该结点的双亲结点</p><p><strong>兄弟结点：</strong></p><p>​同一双亲结点的孩子结点间互称为兄弟结点</p><p><strong>对某个节点</strong>:<br><strong>深度</strong>是指从<strong>根节点到该节点</strong>的<strong>最长</strong>简单路径边的条数；<br><strong>高度</strong>是指从<strong>最下面的叶子结点到该节点</strong>的<strong>最长</strong>简单路径边的条数；</p><p><strong>对二叉树：</strong><br><strong>深度</strong>是从根节点数到它的叶节点；<br><strong>高度</strong>是从叶节点数到它的根节点；<br><strong>注意： 树的深度和高度一样，但是具体到树的某个节点，其深度和高度不一样</strong></p><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><ul><li><strong>满二叉树</strong></li><li><strong>完全二叉树</strong></li><li><strong>二叉搜索树</strong></li><li><strong>平衡二叉搜索树</strong></li></ul><p>具体分辨参考：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB</a></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质1：</strong>若根节点的层次为1，则二叉树第i层最多有<strong>2^i-1</strong>（i&gt;&#x3D;1）个结点</p><p><strong>性质2：</strong>在高度为h的二叉树中，最多有<strong>2^h-1</strong>个结点（h&gt;&#x3D;0）</p><p><strong>性质3：</strong>设一棵二叉树的叶子结点数为n0，2度结点数为n2，则<strong>n0 &#x3D; n2+1</strong></p><p><strong>性质4：</strong>一棵具有n个结点的完全二叉树，其高度h&#x3D;<img src="/./../../../typora-images/image-20240416212437897.png" alt="image-20240416212437897"></p><p><strong>性质5：</strong>一棵具有n个结点的完全二叉树，对序号为i（0&lt;&#x3D;i&lt;&#x3D;n）的结点，有：</p><p>​1）若i&#x3D;0，则i为根结点；若i&gt;0，则i的父母结点序号为**[(i-1)&#x2F;2]**</p><p>​2）若2i+1&lt;n，则i的<strong>左孩子结点序号为2i+1</strong>；否则，i无左孩子</p><p>​3）若2i+2&gt;n，则i的<strong>右孩子结点序号为2i+2</strong>；否则，i无右孩子</p><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><ul><li><p><strong>链式存储</strong></p></li><li><p><strong>线式存储(常用)</strong></p></li></ul><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li><strong>中序遍历</strong></li></ul><p>中序遍历先访问根结点，然后遍历左子树，最后遍历右子树<strong>(左中右)</strong></p><ul><li><strong>先序遍历</strong></li></ul><p>先序遍历是先遍历左子树，然后访问根结点，然后遍历右子树<strong>(中左右)</strong></p><ul><li><strong>后序遍历</strong></li></ul><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问根节点<strong>(左右中)</strong></p><h4 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h4><p>（链式存储的方式来存储的树）</p><p>通过递归三部曲的方式确定递归参数和返回值，确定遍历停止的条件，确定递归逻辑</p><p>以中序遍历来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure><p>前后序遍历的方式也一致，只是递归顺序不同</p><h4 id="非递归方式实现-迭代"><a href="#非递归方式实现-迭代" class="headerlink" title="非递归方式实现(迭代)"></a>非递归方式实现(迭代)</h4><p>迭代方式来进行树的遍历，<strong>主要应用在中序遍历</strong>，由于中序遍历的访问元素与处理元素的顺序不一致，所以可以通过迭代的方式来解决</p><p>讲解可以参考：<a href="https://www.bilibili.com/video/BV1Zf4y1a77g">https://www.bilibili.com/video/BV1Zf4y1a77g</a></p><p>通常使用栈的方式来模拟树的遍历：</p><ul><li>前序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            stack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pre; <span class="comment">// 记录前一个节点的数值</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       stack&lt;TreeNode*&gt; st;</span><br><span class="line">       TreeNode* cur = root;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">NULL</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               st.<span class="built_in">push</span>(cur);</span><br><span class="line">               cur = cur-&gt;right;   <span class="comment">// 右</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               cur = st.<span class="built_in">top</span>();     <span class="comment">// 中</span></span><br><span class="line">               st.<span class="built_in">pop</span>();</span><br><span class="line">               cur-&gt;val += pre;</span><br><span class="line">               pre = cur-&gt;val;</span><br><span class="line">               cur = cur-&gt;left;    <span class="comment">// 左</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>描述：层序遍历一个二叉树就是指 从左到右一层一层的去遍历二叉树</p><p>讲解视频：<a href="https://www.bilibili.com/video/BV1GY4y1u7b2">https://www.bilibili.com/video/BV1GY4y1u7b2</a></p><p>思路：<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑</strong></p><p>模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">while</span> (size--)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//中</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)<span class="comment">//左</span></span><br><span class="line">que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)<span class="comment">//右</span></span><br><span class="line">que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h2><p>例子：</p><p>以<strong>字符串</strong>方式构建二叉树</p><p>描述为：能够根据字符串<code>“A(B(,D),C)”</code>构造二叉树，构建后的树如图</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221112142020303.png" alt="image-20221112142020303"></p><p>解题思路参考：<a href="https://www.bilibili.com/video/BV1CK4y1G7b3">https://www.bilibili.com/video/BV1CK4y1G7b3</a></p><p>采用<strong>栈</strong>的方式来构建</p><p><strong>树结点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">//结点的值</span></span><br><span class="line">    TreeNode left;  <span class="comment">//左孩子</span></span><br><span class="line">    TreeNode right; <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">char</span> data, TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构建树：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span>&#123;</span><br><span class="line">    TreeNode root; <span class="comment">//根结点</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span>&#123;<span class="built_in">this</span>.root = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//用来标记左/右子树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123; <span class="comment">//左括号说明此时结点有子树，同时将结点塞入栈中</span></span><br><span class="line">                st.push(node);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;,&#x27;</span>)&#123;<span class="comment">//逗号说明接下来的结点是右子树</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;<span class="comment">//右括号表示一个子树完成，此时要将子树的根节点弹出栈</span></span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(str.charAt(i));<span class="comment">//初始化赋值   </span></span><br><span class="line">                <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">                    root = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!st.isEmpty())&#123;</span><br><span class="line">                          <span class="keyword">if</span>(flag)&#123;<span class="comment">//为栈顶的结点连接对应的左孩子</span></span><br><span class="line">                    st.peek().left = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//为栈顶的结点连接对应的右孩子</span></span><br><span class="line">                    st.peek().right = node;</span><br><span class="line">                &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历反构建二叉树"><a href="#层序遍历反构建二叉树" class="headerlink" title="层序遍历反构建二叉树"></a>层序遍历反构建二叉树</h2><p>题目链接：<a href="https://kamacoder.com/problempage.php?pid=1221">https://kamacoder.com/problempage.php?pid=1221</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;string&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(nums[<span class="number">0</span>]));</span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>() &amp;&amp; i &lt; nums.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* cur = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//接入左孩子</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] != <span class="string">&quot;null&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(nums[i]));</span><br><span class="line">que.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//接入右孩子</span></span><br><span class="line"><span class="keyword">if</span>(i &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[i] != <span class="string">&quot;null&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(nums[i]));</span><br><span class="line">que.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中查找X值"><a href="#二叉树中查找X值" class="headerlink" title="二叉树中查找X值"></a>二叉树中查找X值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(TreeNode t,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.data==c)&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = findNode(t.left,c);</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findNode(t.right,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>定义结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序遍历方式（中左右）：</p><ul><li><strong>递归（常用）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>栈</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">(TreeNode tree)</span>&#123;</span><br><span class="line">       Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       st.push(tree);</span><br><span class="line">       <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> st.peek();</span><br><span class="line">           st.pop();</span><br><span class="line">           System.out.println(t1.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (t1.right!=<span class="literal">null</span>)</span><br><span class="line">               st.push(t1.right);</span><br><span class="line">           <span class="keyword">if</span> (t1.left!=<span class="literal">null</span>)</span><br><span class="line">               st.push(t1.left);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>参考学习视频：<a href="https://www.bilibili.com/video/BV15f4y1W7i2">https://www.bilibili.com/video/BV15f4y1W7i2</a></p><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>二叉树的<strong>深度</strong>主要通过<strong>后序遍历</strong>来进行，中结点进行最后的判断</p><p>二叉树的<strong>高度</strong>主要通过<strong>前序遍历</strong>来进行，叶子节点进行最后的判断</p><p>核心点在于：<strong>最初根节点的高度其实际上就是该二叉树的最大深度</strong>！</p><p>所以只要通过递归遍历获取根节点的最大高度即可</p><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p>题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/</a></p><p>解题思路：</p><p>一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>代码尝试：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* traversal (vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">       <span class="keyword">if</span> (postorder.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">       <span class="built_in">int</span> rootValue = postorder[postorder.size() - <span class="number">1</span>];</span><br><span class="line">       TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 叶子节点</span></span><br><span class="line">       <span class="keyword">if</span> (postorder.size() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">       <span class="built_in">int</span> delimiterIndex;</span><br><span class="line">       <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.size(); delimiterIndex++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切割中序数组</span></span><br><span class="line">       <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">leftInorder</span>(<span class="params">inorder.begin(</span>), inorder.<span class="title">begin</span>() + delimiterIndex)</span>;</span><br><span class="line">       <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">rightInorder</span>(<span class="params">inorder.begin(</span>) + delimiterIndex + 1, inorder.<span class="title">end</span>() )</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">       postorder.resize(postorder.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切割后序数组</span></span><br><span class="line">       <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">       <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">leftPostorder</span>(<span class="params">postorder.begin(</span>), postorder.<span class="title">begin</span>() + leftInorder.<span class="title">size</span>())</span>;</span><br><span class="line">       <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">rightPostorder</span>(<span class="params">postorder.begin(</span>) + leftInorder.<span class="title">size</span>(), postorder.<span class="title">end</span>())</span>;</span><br><span class="line"></span><br><span class="line">       root-&gt;left = traversal(leftInorder, leftPostorder);</span><br><span class="line">       root-&gt;right = traversal(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h3><p>题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/</a></p><p>解题思路也同中后序一致</p><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p>题目链接：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">https://leetcode.cn/problems/merge-two-binary-trees/description/</a></p><p>解题思路：</p><ol><li><strong>确定递归函数的参数和返回值：</strong></li></ol><p>首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>确定终止条件：</strong></li></ol><p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。</p><p>反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br></pre></td></tr></table></figure><h2 id="删除二叉搜索树中的节点-适合理解递归过程"><a href="#删除二叉搜索树中的节点-适合理解递归过程" class="headerlink" title="删除二叉搜索树中的节点*(适合理解递归过程)"></a>删除二叉搜索树中的节点*(适合理解递归过程)</h2><p>题目链接：<a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">https://leetcode.cn/problems/delete-node-in-a-bst/description/</a></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//删除主要分为五种情况：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.树中无删除的目标值</span></span><br><span class="line"><span class="comment">        2.左为空，右为空 → 删除的是叶子节点</span></span><br><span class="line"><span class="comment">        3.左不为空，右为空  → 根节点左子树跳过删除节点连接其左子树的根节点</span></span><br><span class="line"><span class="comment">        4.左为空，右不为空  → 根节点右子树跳过删除节点连接其右子树的根节点</span></span><br><span class="line"><span class="comment">        5.左不为空，右不为空  → 要删除的节点的右子树找到比其次一级大的节点，将要删除的节点的左子树连在其左子树下，然后根节点右子树跳过删除节点连接其右子树的根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode* deleteNode(TreeNode* root, <span class="built_in">int</span> key) &#123;</span><br><span class="line">        <span class="comment">//终止条件    由于是删除操作，所以实际上不用遍历整个树，当遇到要删除的节点，本质上就已经是终止的时候了，当处理完成即完成了终止条件！</span></span><br><span class="line">        <span class="comment">//第一种情况</span></span><br><span class="line">        <span class="keyword">if</span> (root == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        <span class="comment">//其他情况</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第二种情况</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)</span><br><span class="line">                <span class="keyword">return</span> NULL;</span><br><span class="line">            <span class="comment">//第三种情况</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != NULL &amp;&amp; root-&gt;right == NULL)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            <span class="comment">//第四种情况</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left == NULL &amp;&amp; root-&gt;right != NULL)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="comment">//第五种情况</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left != NULL &amp;&amp; root-&gt;right != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* cur = root-&gt;right;</span><br><span class="line">                <span class="comment">//找到右子树仅次于删除节点的值 (相当于比删除节点大一点点而已)</span></span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left != NULL) cur = cur-&gt;left;</span><br><span class="line">                <span class="comment">//把删除节点的左子树并在其找到的节点的左子树下</span></span><br><span class="line">                cur-&gt;left = root-&gt;left;</span><br><span class="line">                <span class="comment">//此时状态就相当于删除节点处于  左为空，右不为空 的情况</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;val) root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span> (key &gt; root-&gt;val) root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode* test = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode* cur1 = test;</span><br><span class="line">    cur1 = NULL;</span><br><span class="line">    test-&gt;left = cur1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自顶向下系列"><a href="#自顶向下系列" class="headerlink" title="自顶向下系列"></a>自顶向下系列</h2><h3 id="路径和"><a href="#路径和" class="headerlink" title="路径和"></a>路径和</h3><h3 id="路径和-III-双层dfs"><a href="#路径和-III-双层dfs" class="headerlink" title="路径和 III (双层dfs)"></a>路径和 III (双层dfs)</h3><p>题目链接：<a href="https://leetcode.cn/problems/path-sum-iii/description/">https://leetcode.cn/problems/path-sum-iii/description/</a></p><p>相似题目：<a href="https://leetcode.cn/problems/paths-with-sum-lcci/description/">https://leetcode.cn/problems/paths-with-sum-lcci/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res;</span><br><span class="line">   <span class="comment">//暴力解法，双层dfs</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root,<span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span> || targetSum &lt; <span class="number">-1000000000</span> || targetSum &gt; <span class="number">1000000000</span>) <span class="keyword">return</span>;</span><br><span class="line">       </span><br><span class="line">       targetSum -= root-&gt;val;</span><br><span class="line">       <span class="keyword">if</span> (targetSum == <span class="number">0</span>) res++;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">dfs</span>(root-&gt;left, targetSum);</span><br><span class="line">       <span class="built_in">dfs</span>(root-&gt;right, targetSum);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//自顶向下</span></span><br><span class="line"><span class="comment">//外层递归 (相当于基于每个节点都作为根节点)</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//进入内层递归 </span></span><br><span class="line">       <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">       <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="AVL-平衡二叉搜索树"><a href="#AVL-平衡二叉搜索树" class="headerlink" title="AVL(平衡二叉搜索树)"></a>AVL(平衡二叉搜索树)</h2><p>AVL的插入、查询、删除、构建过程都和二叉搜索树一致，只是在失衡状态下要进行调整</p><p>AVL一个特征就是：<strong>所有结点的平衡因子(左子树高度-右子树高度)的绝对值&lt;&#x3D;1</strong></p><p>失衡状态的处理：通过旋转来让保持平衡二叉搜索树</p><p><strong>旋转操作</strong>：<a href="https://www.bilibili.com/video/BV1tZ421q72h">https://www.bilibili.com/video/BV1tZ421q72h</a></p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501203651902.png" alt="image-20240501203651902"></p><p>插入的时候只要对<strong>最近</strong>失衡的父节点进行旋转操作</p><p>删除的时候要对<strong>每个</strong>祖先检查并调整进行旋转操作</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>讲解视频：<a href="https://www.bilibili.com/video/BV1Xm421x7Lg">https://www.bilibili.com/video/BV1Xm421x7Lg</a></p><p>和AVL(平衡二叉搜索树)比较，特点在于：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501180323780.png" alt="image-20240501180323780"></p><h3 id="红黑树的特征"><a href="#红黑树的特征" class="headerlink" title="红黑树的特征"></a>红黑树的特征</h3><ol><li><strong>每个节点非红即黑</strong></li><li><strong>根节点和叶子结点是黑色的</strong></li><li><strong>每一个红色节点的子节点都是黑色的</strong></li><li><strong>任一节点到树尾端(NULL)的路径上的黑色节点数量必须相同</strong></li></ol><p>口诀：左根右、根叶黑、不红红、黑路同</p><p>红黑树的最大高度差：最长高度是最短高度的两倍，所以最大高度差也就是最长高度-最短高度 &#x3D; 最短高度</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501224935675.png" alt="image-20240501224935675"></p><p>各个节点数名称可以简单比作：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501205137332.png" alt="image-20240501205137332"></p><p>进行插入操作，其中的旋转操作和AVL是一致的：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501205301512.png" alt="image-20240501205301512"></p><p><strong>查找、插入和删除操作</strong>：</p><p><strong>平均时间复杂度</strong>和<strong>最坏情况时间复杂度</strong>都是 𝑂(log⁡𝑛)，其中 𝑛 是树中节点的数量</p><h3 id="AVL-树和红黑树的区别"><a href="#AVL-树和红黑树的区别" class="headerlink" title="AVL 树和红黑树的区别"></a>AVL 树和红黑树的区别</h3><ol><li><p><strong>平衡条件</strong>：</p><ul><li><strong>AVL 树</strong>：AVL 树是高度平衡的。每个节点的两个子树的高度差最多为1。这使得<strong>AVL树在查找操作中表现非常好</strong>，因为它确保了树的高度尽可能低。</li><li><strong>红黑树</strong>：红黑树的平衡条件不像AVL树那样严格。红黑树通过确保没有两个连续的红节点并且从每个节点到其所有叶子节点的路径上的黑节点数相同来实现平衡。这种平衡足以<strong>保证操作的最坏时间复杂度</strong>，但允许树稍微高一些。</li></ul></li><li><p><strong>旋转操作</strong>：</p><ul><li><strong>AVL 树</strong>：为了维持严格的平衡，AVL树可能需要在每次插入或删除后进行多次旋转（最多两次）。</li><li><strong>红黑树</strong>：红黑树通常在进行插入或删除操作时需要更少的旋转操作（通常是一次或两次）。这使得红黑树在需要频繁插入和删除的应用中表现更好。</li></ul></li><li><p><strong>优劣势：</strong></p></li></ol><p>​两者优缺点各自相反</p><ul><li><strong>AVL树</strong>：<ul><li><strong>优点</strong>：由于高度平衡，对于查找密集型应用，AVL树提供了更快的查找性能。</li><li><strong>缺点</strong>：每次插入或删除可能需要更多的旋转来维持严格的平衡，这可能导致在更新操作（插入和删除）频繁的场景下性能下降。</li></ul></li><li><strong>红黑树</strong>：<ul><li><strong>优点</strong>：虽然平衡不如AVL树严格，但由于维护这种平衡的成本较低（旋转操作较少），红黑树在实际的增删操作中更为高效。</li><li><strong>缺点</strong>：相较于AVL树，查找操作可能稍慢，因为树的高度可能略高。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（二）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><p>定义：是只允许在一端进行插入或删除的<strong>线性表</strong>。限定这种线性表只能在某一端进行插入和删除操作</p><p><strong>特点：后进先出</strong></p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>根据选用不同的存储结构来构建不同的栈</p><ul><li>顺序栈</li><li>链栈</li><li>共享栈</li></ul><h2 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h2><ul><li>InitStack：初始化一个空栈</li><li>StackEmpty:  判断一个栈是否为空</li><li>Push：进栈</li><li>Pop：出栈</li><li>GetTop：读取栈顶元素</li><li>DestoryStack：销毁栈，释放栈占用的存储空间</li></ul><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p> 定义：队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的<strong>线性表</strong></p><p><strong>特点：先进先出</strong></p><h2 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h2><ul><li>顺序队列</li><li>循环队列</li><li>链队列</li><li>双端队列</li></ul><h2 id="队列的常用操作"><a href="#队列的常用操作" class="headerlink" title="队列的常用操作"></a>队列的常用操作</h2><ul><li>isEmpty：判断队列是否为空</li><li>isFull: 判断队列是否已满</li><li>add：入队</li><li>poll：出队</li><li>peek：返回队头元素</li></ul><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] element;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        element = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否已满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == size-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            size = size*<span class="number">2</span>;</span><br><span class="line">            element = Arrays.copyOf(element,size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (front==-<span class="number">1</span>)</span><br><span class="line">            front++;</span><br><span class="line">        rear++;</span><br><span class="line">        element[rear] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front==rear-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(peek());</span><br><span class="line">        front++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队头元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询队列所有内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front;i&lt;=rear;i++)&#123;</span><br><span class="line">            System.out.println(element[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node rear,front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.rear = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.front = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队(尾插法)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>)&#123;</span><br><span class="line">            front = rear = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = rear.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(peek());</span><br><span class="line">        front = front.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历队列内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.size;i++)&#123;</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2022/11/07/first/"/>
      <url>/2022/11/07/first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构(一)</title>
      <link href="/2022/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>定义：零个或多个数据元素的有限序列</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>线性表的存储结构分为：</p><ul><li>顺序存储</li><li>链式存储</li></ul><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>特点：逻辑上相邻的数据元素，其物理次序也是相邻的</p><p><strong>顺序表的构造与设计：</strong></p><p>SeqList<T>顺序表必有<strong>两个成员变量</strong>，一个数组存放数据，一个表示顺序表元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] element;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeqList</span><span class="params">()</span>&#123;<span class="built_in">this</span>&#123;<span class="number">10</span>&#125;;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增添数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element[n++] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置增添元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i，<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;<span class="built_in">this</span>.element.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//数组下标不合法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">this</span>.element.length-<span class="number">1</span>;j&gt;index;j--)&#123;</span><br><span class="line">        element[j] = element[j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    element[index] = i;</span><br><span class="line">    <span class="built_in">this</span>.n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定下标的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleate</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            element[i] = element[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找对应元素并返回对应下标</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (element[i]==t)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><strong>特点：</strong>单链表<strong>不要求</strong>逻辑上相邻的两个元素在物理位置上也相邻，因此<strong>不需要</strong>连续的存储空间。<strong>查找某个特定的结点时，需要从表头开始遍历，依次查找</strong></p><p>链表设计习题(LeetCode707)：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><p>结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//存放数值</span></span><br><span class="line">    Node next;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&#123;</span><br><span class="line">    Node head;<span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加数据(重点)：</strong></p><p>需求—-</p><p>在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点</p><ul><li>头插法</li><li>尾插法</li><li>第n个结点前插入</li></ul><p><strong>头插法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atTail</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line"> <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾插法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atEnd</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第n个结点插入法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atIndex</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">           atTail(val);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="built_in">this</span>.size)&#123;</span><br><span class="line">           atEnd(val);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           node.next = cur.next;</span><br><span class="line">           cur.next = node;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;<span class="number">0</span>||n&gt;<span class="built_in">this</span>.size)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       cur.next = cur.next.next;</span><br><span class="line">       <span class="built_in">this</span>.size--;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p> 逻辑结构上相邻的数据元素，存储在<em>指定的一块内存空间</em>中，数据元素只允许在这块内存空间中随机存放，这样的存储结构生成的链表称为<strong>静态链表</strong></p><p><strong>(静态链表是用<em>数组</em>来实现链式存储结构)</strong></p><p><strong>特点：</strong>删除和插入元素时间复杂度低(同链表)，不足点是需要提前分配一块较大的空间(同数组)</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/29/hello-world/"/>
      <url>/2022/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
