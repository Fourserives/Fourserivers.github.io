<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>热更新（二）</title>
      <link href="/2024/06/20/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/06/20/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AssetBundle-AB包"><a href="#AssetBundle-AB包" class="headerlink" title="AssetBundle(AB包)"></a>AssetBundle(AB包)</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>AB包是什么？</p><p>AssetBundle即<strong>资源包</strong>，类似压缩文件，它可以把多个游戏对象或者资源以二进制形式保存到AssetBundle文件中，里边单个资源也称之为Asset</p><p>AB包支持unity的格式有：模型、贴图、预制体、音效、材质球等</p><p><strong>AB包的作用：</strong></p><ul><li><strong>相对Resources下的资源，更好管理</strong> (管理资源)<ul><li>将资源打包放到远程服务器上，需要的时候再进行下载</li></ul></li><li><strong>减小包体大小</strong></li><li><strong>热更新的前提</strong></li></ul><p>热更新</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240627100137737.png" alt="image-20240627100137737"></p><h2 id="资源打包"><a href="#资源打包" class="headerlink" title="资源打包"></a>资源打包</h2><p>首先要去Unity下载一个工具<code>Asset Bundle Brower</code>:(通过URL手动安装)</p><p><a href="https://github.com/Unity-Technologies/AssetBundles-Browser.git">https://github.com/Unity-Technologies/AssetBundles-Browser.git</a></p><p>然后便可在Window列表下找到 AB包 可视化界面，可以查看是否有资源打包了</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240621204345692.png" alt="image-20240621204345692"></p><p><strong>PS：C#脚本不能被AB包打包进去！！！预制体绑定的脚本被打包后本质上不是脚本也被打包了，而单纯只是一个绑定的脚本的编号而已</strong></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240620215126986.png" alt="image-20240620215126986"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240620220659721.png" alt="image-20240620220659721"></p><p>Build页签下各个属性值的作用：</p><ul><li>Clear Folders：是否情况文件夹，重新打包</li><li>Copy to StreamingAssets：是否拷贝到StreamingAssets文件夹</li><li><strong>Compression</strong><ul><li><strong>NoCompression：不压缩，解压快，但是包很大（不推荐）</strong></li><li><strong>LZMA：1. 压缩最小，解压慢  2. 用一个资源，会解压所有</strong></li><li><strong>LZ4：1. 压缩，相对LZMA大一点  2. 用什么就解压什么，内存占用低（推荐）</strong></li></ul></li></ul><p>最后是AB包生成的文件：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240620221616069.png" alt="image-20240620221616069"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240621204505059.png" alt="image-20240621204505059"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240621222651254.png" alt="image-20240621222651254"></p><ul><li><strong>AB包文件</strong> （也就是资源文件）</li><li><strong>manifest文件</strong> (固定文件)<ul><li>AB包文件信息</li><li>当加载时，提供的关键信息，资源信息，依赖信息等等</li></ul></li><li><strong>关键AB包</strong>（和目录名一样的包）<ul><li>主包</li><li>AB包依赖关键信息</li></ul></li></ul><p>其中主包的名字就是对应在打包过程中<code>Output Path</code>的值</p><p>详细讲解：<a href="https://blog.csdn.net/qq_36804363/article/details/121084431">https://blog.csdn.net/qq_36804363/article/details/121084431</a></p><h2 id="资源加载与卸载"><a href="#资源加载与卸载" class="headerlink" title="资源加载与卸载"></a>资源加载与卸载</h2><p>资源的加载主要分为几个步骤：</p><ul><li><p><strong>加载AB包</strong></p><ul><li>通过<code>AssetBundle.LoadFromFile(Path)</code>语句进行</li></ul></li><li><p><strong>加载AB包中的资源</strong></p><p>有两种方式进行加载：</p><ul><li><p>泛型加载</p><p>xx.LoadAsset<T>(Name)</p><p>其中xx对应的是前边获取加载的AB包的对象，然后&lt;&gt;填写要加载的资源类型，最后Name则填写对应的该资源的名称</p></li><li><p>Type指定类型加载</p><p>xx.LoadAsset(Name,typeof(类型))</p></li></ul></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//第一步：加载AB包</span></span><br><span class="line">       AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line">       <span class="comment">//第二步：加载AB包中的资源</span></span><br><span class="line">           <span class="comment">//有三种方式进行加载，一般采用其中两种：</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//泛型加载</span></span><br><span class="line">           GameObject obj = ab.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//Type指定类型加载</span></span><br><span class="line">           <span class="comment">//GameObject obj = ab.LoadAsset(&quot;Cube&quot;, typeof(GameObject)) as GameObject;</span></span><br><span class="line">       Instantiate(obj);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同时常用的还有<strong>异步加载</strong>，也就是通过携程来完成资源的异步加载</p><p>异步加载的话需要使用携程，所以一般要创建一个对应的携程，然后传入的参数和前边一样，要有对应加载的AB包的Pat以及AB包要加载的资源的Name</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">LoadABRes</span>(<span class="params"><span class="built_in">string</span> ABName,<span class="built_in">string</span> resName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一步 加载AB包</span></span><br><span class="line">        AssetBundleCreateRequest abcr = AssetBundle.LoadFromFileAsync(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + ABName);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abcr;</span><br><span class="line">        <span class="comment">//第二部 加载资源</span></span><br><span class="line">        AssetBundleRequest abq = abcr.assetBundle.LoadAssetAsync(resName,<span class="keyword">typeof</span>(GameObject));</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> abq;</span><br><span class="line">        <span class="comment">//abq.asset as GameObject</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>资源加载也有其他几种不同的方式：<a href="https://blog.csdn.net/wlqchengzhangji/article/details/107301970">https://blog.csdn.net/wlqchengzhangji/article/details/107301970</a></p><p><strong>PS：AB包不能够重复加载，否则报错</strong></p><p>资源的卸载主要有两种方式：</p><ul><li><p>单个加载的AB包卸载</p><p>使用<code>xx.Unload(bool)</code>语句</p><p>​参数一般默认填写false，这样就只会卸载AB包，而不会卸载掉AB包的资源；如果填写true，则会把AB包加载的资源也一并卸载了</p></li><li><p>卸载所有加载的AB包</p></li></ul><p>​使用<code>AssetBundle.UnloadAllAssetBundles(bool)</code>语句</p><p>​参数同Unload一样，会影响是否连带着卸载AB包加载的资源</p><h2 id="AB包依赖"><a href="#AB包依赖" class="headerlink" title="AB包依赖"></a>AB包依赖</h2><p>在包中，如果一个包里边的某个资源使用了另外一个新的资源，那么该新资源也会被打包进去</p><p>此时如果把新的资源放到另外一个包中，启动就会发现因为缺少资源而导致出现相应的错误</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240621215539747.png" alt="image-20240621215539747"></p><p>这时候就意味着需要用到AB包依赖：</p><p>AB包依赖：当一个资源身上用到了别的AB包中的资源，这个时候通过它创建对象就会出现资源丢失的情况，这时候就要把依赖包一起加载了才能恢复正常，相当于只要加载对应依赖的AB包即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要使用的物体</span></span><br><span class="line">AssetBundle ab = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;model&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该物体要依赖的其他的AB包</span></span><br><span class="line">        AssetBundle ab2 = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;shader&quot;</span>);</span><br></pre></td></tr></table></figure><p>但是这种方式是建立在已知当前资源的依赖有哪些的情况下，那么如果不清楚的情况下，又该如何实现AB包的依赖？</p><p>这时候我们就要<strong>通过主包来获取依赖信息</strong>：</p><ol><li>加载主包</li></ol><p>​ <code>AssetBundle.LoadFromFile(Path)</code>，这里要注意路径使用的是主包的路径</p><ol start="2"><li><p>加载主包中的固定文件</p><p><code>LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;)</code></p></li><li><p>从固定文件中得到依赖信息</p></li><li><p>加载依赖包</p><p>最终代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//依赖包的关键点：利用主包获取依赖信息</span></span><br><span class="line">       <span class="comment">//加载主包</span></span><br><span class="line">       AssetBundle abMain = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + <span class="string">&quot;StandaloneWindows&quot;</span>);</span><br><span class="line">       <span class="comment">//加载主包中的固定文件(一样的ID，在文件夹中查看就是后缀.manifest)</span></span><br><span class="line">       AssetBundleManifest abManifest = abMain.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line">       <span class="comment">//从固定文件中得到依赖信息</span></span><br><span class="line">       <span class="built_in">string</span>[] strs = abManifest.GetAllDependencies(<span class="string">&quot;model&quot;</span>);</span><br><span class="line">       <span class="comment">//得到依赖包的名字并加载</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; strs.Length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + strs[i]);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="AB包加载管理器"><a href="#AB包加载管理器" class="headerlink" title="AB包加载管理器"></a>AB包加载管理器</h2><p>作用：目的是让外部更方便的进行资源加载，同时也是预防AB包被重复加载同时产生错误</p><p>通常设置该管理器为单例模式，然后通过字典来存储加载过的AB包，以此来判断该AB包是否被加载过</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240622232515612.png" alt="image-20240622232515612"></p><p><strong>同步加载：</strong></p><p>同步加载首先依然得要先得到一个主包和一个依赖包对应的配置文件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AssetBundle mainAB = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">private</span> AssetBundleManifest manifest = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>而主包的加载通过<code>AssetBundle.LoadFromFile(Path)</code>，我们知道Path对应的是主包的路径，同时对应的一个是streamingAsset包的位置以及主包的名字，所以为了让其管理器能够正确加载对应的AB主包，仍需设定新的属性来让其使用的时候可以灵活更改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AB包存放路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> PathUrl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Application.streamingAssetsPath+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主包名，方便修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> MainABName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> UNITY_IOS</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;IOS&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">elif</span> UNITY_ANDROID</span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;Android&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;PC&quot;</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以先进行包的加载：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623111356608.png" alt="image-20240623111356608"></p><p>最后再通过资源的加载即可：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623112059732.png" alt="image-20240623112059732"></p><p>当然，正常来说要传入一个泛型类型来表示我们要加载的资源类型，所以可以修改为：</p><p>这种方式会适用于到时候的Lua与C#交互</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623112521695.png" alt="image-20240623112521695"></p><p>或者</p><p>这种方式会适用于单纯通过C#来加载</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623112806638.png" alt="image-20240623112806638"></p><p>最后是对AB包和资源包的卸载，同样也分为单个卸载和所有包卸载：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623113322426.png" alt="image-20240623113322426"></p><p><strong>异步加载：</strong></p><p>这里的异步加载指的是<strong>资源的异步加载</strong>，其AB包加载方式不变，资源的加载就要发生变化，这里就要用到委托的方式，通过委托来传递给外部，让外部去使用，同样的也有三种重载的方式：</p><p>根据名字异步加载</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623145547340.png" alt="image-20240623145547340"></p><p>根据Type异步加载</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623145842880.png" alt="image-20240623145842880"></p><p>根据泛型异步加载</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240623150338877.png" alt="image-20240623150338877"></p><h1 id="Addressables"><a href="#Addressables" class="headerlink" title="Addressables"></a>Addressables</h1><p>Addressables是可以用于替代AssetBundle的高阶资源管理系统</p><p>Addressables的优点主要有：</p><ul><li>自动化管理AB包打包、发布、加载</li><li>可以更方便的进行本地、远程资源的加载</li><li>系统会自动处理资源关联性</li><li>内存管理更方便</li><li>迭代更方便</li></ul><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624172418547.png" alt="image-20240624172418547"></p><p>Addressables也是外部包，所以要先进行导入才能使用</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624173540221.png" alt="image-20240624173540221"></p><p>同时还要创建Addressables的配置文件，这里主要有两种方式来进行创建相关的配置文件：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624173829970.png" alt="image-20240624173829970"></p><p>第二种方式就是直接在资源的Inspector标签下点击Addressable即可自动创建以及生成相关的配置文件，最后是配置文件的截图：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624174053902.png" alt="image-20240624174053902"></p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><h3 id="可寻址资源设置"><a href="#可寻址资源设置" class="headerlink" title="可寻址资源设置"></a>可寻址资源设置</h3><p>可寻址资源设置：当创建物体并作为预制体存入到资源文件夹<code>Resources</code>下，如果我们要让其被Addressable管理器进行管理，那么在勾选其对应选项后，它就会变成可寻址资源并被移动至新的<code>Resources_moved</code>文件夹下</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624174744195.png" alt="image-20240624174744195"></p><p>原因：由于Resources文件夹下资源会最终打包出去，如果变为寻址资源意味着想通过Addressables进行管理，那么就没有必要通过Resources方式去加载和打包，所以会自动迁移避免重复打包导致浪费空间</p><p><strong>PS：C#脚本无法作为可寻址资源！</strong></p><p>最后寻址资源可以在Addressables Groups上看到，同样的也可以选择直接把要变为寻址资源的内容直接拖拽过去，这样也能达到一样的效果</p><p>Addressables Groups上各个资源信息的意思：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624215742049.png" alt="image-20240624215742049"></p><p>GroupName\Addressable Name：分组名\可寻址名（可重名）</p><p>Path：路径（不可重复)</p><p>Labels：标签（可重复，用于区分资源种类）</p><p>创建分组相关：</p><p>通过Create → Group → Packed Assets可以创建打包资源分组，每一个组可以作为一个或多个AB包</p><p>分组会比较常用，其可以按规则将资源分组，比如角色、怪物、UI等等</p><p>Tools工具：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624221125774.png" alt="image-20240624221125774"></p><p>Play Mode Script：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240624221406037.png" alt="image-20240624221406037"></p><h3 id="指定资源加载"><a href="#指定资源加载" class="headerlink" title="指定资源加载"></a>指定资源加载</h3><p><strong>前提：首先要在前边设置完成可寻址的资源</strong></p><p>通过Addressables中的资源标识类来进行使用，将需要用到的资源包进行绑定，在C#脚本下调用：</p><p>Addressables中的资源标识类主要有</p><ul><li>AssetReference通用资源标识类，用来加载任意类型资源</li><li>AssetReferenceAtlasedSprite   图集资源标识类</li><li>AssetReferenceGameObject    游戏对象资源标识类</li><li>AssetReferenceSprite   图片资源标识类</li><li>AssetReferenceTexture 贴图资源标识类</li><li>AssetReferenceTexture2D</li><li>AssetReferenceTexture3D</li><li>AssetReferenceT&lt;&gt;    指定类型标识类</li></ul><p>通过标识类进行对应资源绑定之后，接下来就是要加载资源</p><p>PS：所有Addressables加载相关都使用异步加载</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AsyncOperationHandle&lt;GameObject&gt; handle = assetReference.LoadAssetAsync&lt;GameObject&gt;();</span><br></pre></td></tr></table></figure><p>加载成功后使用</p><ol><li>通过事件函数传入的参数判断加载是否成功</li><li>通过资源标识类对象判断并创建</li></ol><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240625234833153.png" alt="image-20240625234833153"></p><p>通过异步加载返回值对完成进行事件的监听</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle.Completed += XX;</span><br></pre></td></tr></table></figure><h3 id="Label标签"><a href="#Label标签" class="headerlink" title="Label标签"></a>Label标签</h3><p>在实际商业项目开发中，一般来说加载什么资源都是根据配置文件决定的，这些往往都是动态加载，所以我们需要知道如何根据名字或标签去加载对应的资源，这样就可以通过读表进行加载</p><p>通过Addressables Groups界面上直接创建并管理标签，然后为各个可寻址资源绑定对应的标签，完成第一步的操作：</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240626214254742.png" alt="image-20240626214254742"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240626214318611.png" alt="image-20240626214318611"></p><p>同时Labels标签是可以支持多项标签的，比如多加一个颜色的标签</p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240626214857384.png" alt="image-20240626214857384"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240626215041444.png" alt="image-20240626215041444"></p><p><img src="/./../images/%E7%83%AD%E6%9B%B4%E6%96%B0/image-20240626215223921.png" alt="image-20240626215223921"></p><p>Label标签的作用：</p><ul><li>相同作用的不同资源（模型、贴图、材质、UI等）</li><li>可以让其资源名相同但是标签不同</li><li>通过标签Label区分他们的用途，用于后续的动态加载</li><li>利用名字和标签可以单独动态加载某个资源，也可以利用它们共同决定加载哪个资源</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模板</title>
      <link href="/2024/06/11/%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/06/11/%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>如果C++中使用<code>scanf</code>和<code>printf</code>显示报错的话，可以在iostream源文件前边添加上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br></pre></td></tr></table></figure><h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><ol><li><strong>先划分分界点</strong></li><li><strong>进行排序，使左边 &lt; 分界点，右边 &gt; 分界点</strong></li><li><strong>递归左右区间</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ol><li><strong>先划分分界点</strong></li><li><strong>递归左右区间</strong></li><li><strong>归并 —— 合二为一 （双指针）</strong></li></ol><p>[L , R] &#x3D;&gt; [L，mid]，[mid+1，R]</p><p>递归排序[L，mid]和[mid+1，R]</p><p>归并，合二为一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt; q[j]) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span> temp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l,j=<span class="number">0</span>; i &lt;= r; i++,j++)</span><br><span class="line">&#123;</span><br><span class="line">q[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="▲求逆序对的数量"><a href="#▲求逆序对的数量" class="headerlink" title="▲求逆序对的数量"></a>▲求逆序对的数量</h2><p>首先要知道一个前提：</p><p>在计算数组的逆序对的过程中，将原数组排序并不会改变原数组的逆序对数量</p><p>视频讲解：<a href="https://www.acwing.com/video/230/">https://www.acwing.com/video/230/</a></p><p>注意其本质上可以通过归并来直接实现，在排序的时候就可以进行计算了，左区间，右区间，左右出现逆序对三种情况下，都可以在递归的时候就完成整体的排序与寻找对应的逆序对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> temp[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//归排</span></span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//先分化</span></span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="built_in">merge_sort</span>(q, l, mid) + <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j]) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">temp[k++] = q[j++];</span><br><span class="line">res += mid - i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid) temp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)temp[k++] = q[j++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//后归并，合二为一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">&#123;</span><br><span class="line">q[i] = temp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; q[i];</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>)&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>热更新（一）</title>
      <link href="/2024/06/11/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/06/11/%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Lua语言"><a href="#Lua语言" class="headerlink" title="Lua语言"></a>Lua语言</h1><p>概述：</p><p>初尝试：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">第二种</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">]]</span><span class="comment">--</span></span><br></pre></td></tr></table></figure><p><strong>变量类型主要有：</strong></p><p>简单变量类型</p><ul><li><strong>nil</strong></li><li><strong>number</strong></li><li><strong>bool</strong></li><li><strong>string</strong></li></ul><p>复杂变量类型</p><ul><li><strong>function 函数</strong></li><li><strong>table 表</strong></li><li><strong>userdata 数据结果</strong></li><li><strong>thread 协同程序</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- lua中的简单变量</span></span><br><span class="line"><span class="comment">-- nil number string boolean</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua中的变量不需要声明        相当于c#的var</span></span><br><span class="line"><span class="comment">lua中的一个变量 可以被随意赋值  lua会自动识别类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">type函数可以返回当前数值的类型，type返回的内容本质上是string类型</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line">a = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(a)))</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line">a = <span class="number">1.5</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment">-- 这意味着number类型就包含了跟数值有关的其他类型，包括float，double，int等</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==================================&quot;</span>)</span><br><span class="line">a = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="comment">-- 这意味着lua里边没有char类型</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- lua中使用一个未被声明的变量，不会报错，初始是nil</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure><p>需要注意的一个点是：Lua中可以直接使用没有初始化的变量，默认为nil</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Lua字符串基础的操作包括：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--字符串长度 通过#符号来表示</span></span><br><span class="line">s = <span class="string">&quot;abcDEF&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s)</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;abc你好&quot;</span></span><br><span class="line"><span class="built_in">print</span>(#s)</span><br><span class="line"><span class="comment">-- 中文一个字占3个长度，英文占1个长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串多行打印</span></span><br><span class="line"><span class="comment">-- 第一种方式：常规转义字符换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\nabc&quot;</span>)</span><br><span class="line"><span class="comment">-- 第二种方式：中括号打印</span></span><br><span class="line">s = <span class="string">[[</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">world</span></span><br><span class="line"><span class="string">~~~</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>字符串的拼接：</strong></p><p>字符串的拼接主要通过<code>..</code>符号来进行的，这也意味着如果用了这个符号，表示的就是进行字符串类型的拼接</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串的拼接</span></span><br><span class="line"><span class="comment">-- 第一种方式  通过 .. </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>..<span class="string">&quot;123&quot;</span>)</span><br><span class="line">s1 = <span class="number">123</span></span><br><span class="line">s2 = <span class="number">456</span></span><br><span class="line"><span class="built_in">print</span>(s1..s2)</span><br><span class="line"><span class="comment">-- 第二种方式 string.format</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;我是大学生，今年大%d&quot;</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;大学生%s&quot;</span>,<span class="string">&quot;是我&quot;</span>))</span><br><span class="line"><span class="comment">-- %d：与数字拼接</span></span><br><span class="line"><span class="comment">-- %a：与任何字符拼接</span></span><br><span class="line"><span class="comment">-- %s：与字符配对</span></span><br><span class="line"><span class="comment">-- ......</span></span><br></pre></td></tr></table></figure><p>要注意如果通过<code>string.format</code>进行拼接的话，采用的转义字符不同，拼接的类型也不同</p><p><strong>字符串的公共方法：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 字符串提供的公共方法</span></span><br><span class="line">str = <span class="string">&quot;abcDefG&quot;</span></span><br><span class="line"><span class="comment">-- 小写转大写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">upper</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 大写转小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">lower</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 翻转字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">reverse</span>(str))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;查看原str是否被改变：&quot;</span>,str)</span><br><span class="line"><span class="comment">-- 字符串索引查找</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;Def&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(str,<span class="string">&quot;D&quot;</span>))</span><br><span class="line"><span class="comment">-- find函数查找会返回两个数值，对应起始位置和最终位置，同时要注意Lua的下标都是从1开始，而不是从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串截取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str,<span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(str,<span class="number">3</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串重复</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">rep</span>(str,<span class="number">2</span>))</span><br><span class="line"><span class="comment">-- 字符串修改</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(str,<span class="string">&quot;bcD&quot;</span>,<span class="string">&quot;**&quot;</span>))</span><br><span class="line"><span class="comment">-- 字符转 ASCII码</span></span><br><span class="line">t = <span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;Lua&quot;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"><span class="comment">-- ASCII码 转字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(t))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中有几个点要注意到：</p><ol><li>字符串的方法，如upper，lower，reverse等都不会对原先的字符串造成改变</li><li>字符串索引查找返回的会是两个数值，分别是初始和最终位置</li><li><strong>Lua语言的下标都是默认从1开始的，而不是从0开始的！</strong></li><li>字符串的截取方法也有重载方式，如果单纯输入一个数字，那就会截取数字之后到末尾这一段的内容</li><li>字符串修改，如果打印输出结果的话会有一个数值，该数值表示的是其中修改了几次</li></ol><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>Lua语言中，不支持自增与自减，同时也不支持复合运算符</p><p>但是Lua语言中自带可以在运算过程中把字符串自动转成运算需要的数值number</p><p>同时Lua语言还支持<strong>幂运算</strong>，通过<code>^</code>符号来实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********算数运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中没有自增自减 ++ --</span></span><br><span class="line"><span class="comment">-- Lua中没有复合运算符 += -= *= /= %=</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;加法运算：&quot;</span>.<span class="number">.1</span>+<span class="number">2</span>)</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="comment">-- Lua语言中，字符串如果与数值进行运算的话，会自动转成number类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>+<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;减法运算：&quot;</span>.<span class="number">.1</span><span class="number">-2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span><span class="number">-1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span><span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;乘法运算：&quot;</span>.<span class="number">.1</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;除法运算：&quot;</span>.<span class="number">.1</span>/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;取余运算：&quot;</span>.<span class="number">.1</span>%<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>%<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>%<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;幂运算：&quot;</span>.<span class="number">.2</span>^<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>^<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123.6&quot;</span>^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>条件运算符、逻辑运算符在Lua的使用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********条件运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- &gt; &lt; &gt;= &lt;= == ~=</span></span><br><span class="line"><span class="comment">-- 在Lua语言中, != 是用 ~= 来实现</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********逻辑运算符************&quot;</span>)</span><br><span class="line"><span class="comment">-- &amp;&amp;   ||   !   </span></span><br><span class="line"><span class="comment">-- and  or   not</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="literal">true</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 短路</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>) <span class="keyword">and</span> <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>Lua中不支持位运算符和三目运算符</p><p><strong>条件分支语句：</strong></p><p>注意的是，Lua语言中没有 switch 语句</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;**********条件分支语句************&quot;</span>)</span><br><span class="line">a = <span class="number">9</span></span><br><span class="line"><span class="comment">-- 单分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 双分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多分支</span></span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">5</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;小于5&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">6</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">7</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;7&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a==<span class="number">8</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;8&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>循环语句：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 循环语句</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================while=====================&quot;</span>)</span><br><span class="line"><span class="comment">-- while ....... do .......end</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num&lt;<span class="number">5</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================do while=====================&quot;</span>)</span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="comment">-- repeat ....... until .......    PS：条件是结束条件，而不是进入条件</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line"><span class="built_in">print</span>(num)</span><br><span class="line">num = num + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span> num &gt; <span class="number">5</span>  <span class="comment">-- 结束条件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#x27;================for=====================&quot;</span>)</span><br><span class="line"><span class="comment">-- for ....... do ...... end</span></span><br><span class="line"><span class="comment">-- Lua语言中，for里边是默认递增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span> <span class="keyword">do</span> <span class="comment">-- 默认递增+1</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span> <span class="keyword">do</span> <span class="comment">-- 自定义每次增加是2</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">5</span>,<span class="number">1</span>,<span class="number">-1</span> <span class="keyword">do</span> <span class="comment">-- 自定义递减</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Lua语言中的循环语句与其他语法都不太一样，尤其是do while以及for循环</p><p>其中 do while 变为了 repeat until，并且最本质的区别在于：</p><p>前者在其他语言，条件都是相当于<strong>输入条件</strong>，而后者变成了条件是<strong>结束条件</strong></p><p>最后是Lua语言的for循环，其中对应的定义，条件，递增&#x2F;递减直接通过三个数值两个逗号即可表示完整</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Lua语言中函数的使用更加简便，其中函数的传参</p><p><strong>函数的定义：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================函数==============================&quot;</span>)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">两种写法：</span></span><br><span class="line"><span class="comment">第一种 </span></span><br><span class="line"><span class="comment">function function_name()</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二种</span></span><br><span class="line"><span class="comment">a = function()</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F1</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用了函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F1() <span class="comment">-- 使用函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种方式有点类似于 C#中的 委托和事件</span></span><br><span class="line">a = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二种调用&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中函数的有参、有返回区别很大，要注意其在Lua的使用：</p><ul><li>函数传参时<ul><li>个数多了或少了，不会报错</li><li>多了会丢弃</li><li>少了会补空</li></ul></li><li>函数返回时<ul><li>允许有多个返回值，外部用多个变量来接取，接多接少不影响</li><li>少了会丢弃，多了会自动赋值为nil</li></ul></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================有参数==================================&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中函数的参数不需要声明类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(a)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line">test(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">test(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">-- 如果传入的参数和函数的参数不匹配，没传入或者超过个数</span></span><br><span class="line"><span class="comment">-- 不会报错，会自动补空nil  或者 丢弃</span></span><br><span class="line">test()</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================有返回值==================================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span><span class="params">(a)</span></span></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp = F3(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line">temp1 = F3(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(temp1)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多返回值时，在前面声明多个变量来接取即可</span></span><br><span class="line"><span class="comment">-- 如果变量不够也不会报错，值接取对应位置的返回值</span></span><br><span class="line"><span class="comment">-- 如果变量多了也不会影响，值赋值为nil</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F3</span><span class="params">(a)</span></span></span><br><span class="line"><span class="keyword">return</span> a,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">temp = F3(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line">temp2,temp3,temp4 = F3(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(temp2)</span><br><span class="line"><span class="built_in">print</span>(temp3)</span><br><span class="line"><span class="built_in">print</span>(temp4)</span><br><span class="line"><span class="built_in">print</span>(temp5)</span><br></pre></td></tr></table></figure><p>函数的类型就是function，和其他语法不一样，Lua中函数只有function一种</p><p>Lua中函数也不支持重载：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua中 函数不支持重载</span></span><br><span class="line"><span class="comment">-- 默认调用最后一个声明的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;无参函数&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F6</span><span class="params">(str)</span></span></span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">F6()</span><br></pre></td></tr></table></figure><p>Lua中函数也可以定义变长参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;==========================变长参数==============================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F7</span><span class="params">(...)</span></span></span><br><span class="line"><span class="comment">-- 变长参数使用 一个表 来存起来</span></span><br><span class="line"><span class="built_in">arg</span> = &#123;...&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#<span class="built_in">arg</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">arg</span>[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">F7(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>可以发现其变长参数，如果传入的参数类型都不相同，依旧不影响其正常使用，同时表格存储的数据也会跟着对应的类型</p><p>Lua语言的函数嵌套：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F8</span><span class="params">(x)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">f8 = F8(<span class="number">10</span>)</span><br><span class="line">f8()</span><br></pre></td></tr></table></figure><p>同时这块还有一个面试知识点：<strong>闭包</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F9</span><span class="params">(x)</span></span></span><br><span class="line"><span class="comment">--改变传入参数的生命周期</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(y)</span></span></span><br><span class="line"><span class="keyword">return</span> x+y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f9 = F9(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(f9(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>其本质就是让传入的参数的生命周期发生了变化，从而就实现了闭包</p><h3 id="表-Table"><a href="#表-Table" class="headerlink" title="表(Table)"></a>表(Table)</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--所有复杂类型都是table（表）</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">--lua中索引从 1开始</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">6</span>])</span><br><span class="line"><span class="comment">--打印长度会忽略空</span></span><br><span class="line"><span class="built_in">print</span>(#a)</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="literal">nil</span>,<span class="string">&quot;123&quot;</span>,<span class="literal">true</span>,<span class="literal">nil</span>&#125;</span><br><span class="line"><span class="comment">--如果表中(数组中)某一位变成nil 会影响#获取的长度</span></span><br><span class="line"><span class="built_in">print</span>(#b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 数组的遍历</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(a[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 二维数组</span></span><br><span class="line">a = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,#a <span class="keyword">do</span></span><br><span class="line">b = a[i]</span><br><span class="line"><span class="keyword">for</span> j=<span class="number">1</span>,#b <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(b[j])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 自定义索引</span></span><br><span class="line">c = &#123;[<span class="number">0</span>]=<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">-1</span>]=<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(c[<span class="number">0</span>])</span><br><span class="line"><span class="comment">-- 自定义索引不会影响原来数组的顺序，如c数组塞了两个，实际上 1 2 3 5 7仍然是按顺序排列的</span></span><br></pre></td></tr></table></figure><p>通过测试就会发现：</p><p>Lua中通过<code>#</code>直接获取长度并进行遍历会出现&lt;&#x3D;0索引的情况下无法完全遍历整体的数组，还会出现数组中断的后果，所以Lua语言还提供了迭代器遍历的方式</p><ul><li><strong>ipairs</strong></li><li><strong>pairs</strong></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- 迭代器遍历</span></span><br><span class="line"><span class="comment">-- ipairs</span></span><br><span class="line"><span class="comment">-- ipairs遍历仍然是从 1开始往后遍历的 &lt;=0的索引的值都得不到</span></span><br><span class="line"><span class="comment">-- 只能找到连续索引的键 如果中间断续了 也无法得到后续的内容</span></span><br><span class="line">   <span class="comment">-- 这里连续索引被中断的意思，指的相当于 1 2 3 [5]=-1   这时候索引4直接被跳过了，就相当于中断了</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">ipairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键值：&quot;</span>..i..<span class="string">&quot;-&quot;</span>..k)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================================&quot;</span>)</span><br><span class="line"><span class="comment">-- pairs</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">pairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键值：&quot;</span>..i..<span class="string">&quot;-&quot;</span>..v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 遍历键</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">pairs</span>(c) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ipairs遍历键：&quot;</span>..i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过比较可以发现两者的区别，这也是面试的一个知识点：</p><p><strong>ipairs</strong>跟原始的用#进行遍历的方式一样，都会遇到相同的问题，存在丢失后续数组内容，在里边插入了自定义索引的情况下</p><p>而<strong>pairs</strong>最全面，其可以找到所有的数组元素</p><p>通过表可以定义复杂数据类型：</p><ul><li><strong>字典</strong></li><li><strong>类</strong></li></ul><p>字典的定义与操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;====================字典============================&quot;</span>)</span><br><span class="line"><span class="comment">-- 字典是由键值对构成</span></span><br><span class="line">a = &#123;[<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;测试字典&quot;</span>,[<span class="string">&quot;age&quot;</span>]=<span class="number">1145</span>,[<span class="string">&quot;233&quot;</span>]=<span class="literal">true</span>&#125;</span><br><span class="line"><span class="comment">-- 第一种字典访问方式</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;233&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种字典访问方式 通过.成员变量方式获取值</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"><span class="built_in">print</span>(a.age)</span><br><span class="line"><span class="comment">-- 这种方式有一个缺陷，不能使用.数字来获取</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&quot;233&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改</span></span><br><span class="line">a[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;waou&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line">a.name = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增添</span></span><br><span class="line">a.sex = <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(a.sex)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="comment">-- 直接赋值为nil即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========字典遍历==============&quot;</span>)</span><br><span class="line"><span class="comment">-- 一定要用pairs</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获得键</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>类的定义与操作：</strong></p><p>类成员变量的声明</p><ul><li>表内部声明</li><li>表外部声明</li></ul><p>类成员函数的声明</p><ul><li><p>表内部声明</p></li><li><p>表外部声明</p><ul><li>变量的形式</li><li>function + 名字的形式</li></ul><p>在表内部函数要访问表内部的变量或方法时，要先知道他们来自于哪里</p></li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;====================类和结构体============================&quot;</span>)</span><br><span class="line"><span class="comment">-- Lua中默认没有面向对象，需要自己实现</span></span><br><span class="line">Student = &#123;</span><br><span class="line">age = <span class="number">10</span>,</span><br><span class="line">sex = <span class="string">&quot;male&quot;</span>,</span><br><span class="line"><span class="comment">--函数</span></span><br><span class="line">Up = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">-- 如果要在方法里边调用类里边的属性的话，要通过表名.成员变量/函数来声明</span></span><br><span class="line"><span class="built_in">print</span>(age)</span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成长&quot;</span>)</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"></span><br><span class="line">Learn = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="comment">-- 第二种方式就是</span></span><br><span class="line"><span class="comment">-- 把自己作为一个参数传进来，让其在内部能被访问</span></span><br><span class="line"><span class="built_in">print</span>(t.sex)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;经验&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(Student.age)</span><br><span class="line">Student.Up()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 声明表后，可以在表外去声明变量和方法</span></span><br><span class="line">Student.name = <span class="string">&quot;test&quot;</span></span><br><span class="line">Student.Speak = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;说话&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 函数的第三种声明方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student.Talk</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;聊天&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Student.Speak()</span><br><span class="line">Student.Talk()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 面试考点之一： .和:的区别！</span></span><br><span class="line">Student.Learn(Student)</span><br><span class="line"><span class="comment">-- Lua中，冒号调用方法，会默认把调用者作为第一个参数传入方法中</span></span><br><span class="line">Student:Learn()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 同样的在外部声明的时候也可以直接使用冒号，这样就默认外部声明的函数有一个默认传入值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:Talk2</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">-- 这里另外一个新的内容：</span></span><br><span class="line"><span class="comment">-- 通过 self 关键字来获取默认第一个传入的值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.name..<span class="string">&quot;聊天&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Student:Talk2()</span><br></pre></td></tr></table></figure><p>其中类函数定义这块有两个面试注意点：</p><ol><li><code>.</code>和<code>:</code>的区别</li></ol><p>   <strong>冒号会把调用者作为第一个参数传入</strong></p><p>   冒号也可以用来声明函数，同时这种方式声明<strong>只能是function +  名字的形式</strong></p><p>   <strong>冒号声明函数只能在外部进行声明</strong></p><ol start="2"><li>self关键字</li></ol><p>这两个知识点都是应用在类声明的有参传入函数的使用上</p><p>表提供的一些公共方法：</p><p>主要也是增删改查，同时也提供了排序与拼接的相关操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">t1 = &#123;&#123;name = <span class="string">&quot;lili&quot;</span>,sex = <span class="string">&quot;male&quot;</span>&#125;,&#123;name = <span class="string">&quot;wuh&quot;</span>,age = <span class="number">14</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">t2 = &#123;name=<span class="string">&quot;lucy&quot;</span>,id=<span class="string">&quot;233&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="comment">-- 插入语句</span></span><br><span class="line"><span class="comment">-- 把t2插入给t1</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(t1,t2)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>].name)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除语句</span></span><br><span class="line"><span class="comment">-- remove方法 会移除最后一个索引的元素</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- remove方法传入两个参数 根据第二个参数，移除第二个参数代表的索引位置所在的内容</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(t1,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(#t1)</span><br><span class="line"><span class="built_in">print</span>(t1[<span class="number">1</span>].name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line"><span class="comment">-- 排序</span></span><br><span class="line">test = &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(test)</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(test) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================&quot;</span>)</span><br><span class="line"><span class="comment">-- 降序</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(test,<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="keyword">if</span> a &gt; b <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">for</span> _,v <span class="keyword">in</span> <span class="built_in">pairs</span>(test) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 拼接</span></span><br><span class="line">tb = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;456&quot;</span>,<span class="string">&quot;789&quot;</span>,<span class="string">&quot;10101&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(#tb)</span><br><span class="line">str = <span class="built_in">table</span>.<span class="built_in">concat</span>( tb, <span class="string">&quot;,&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br></pre></td></tr></table></figure><h2 id="多脚本执行"><a href="#多脚本执行" class="headerlink" title="多脚本执行"></a>多脚本执行</h2><p>Lua语言中也分有 <strong>全局变量</strong>和<strong>本地变量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================全局变量和本地变量======================&quot;</span>)</span><br><span class="line"><span class="comment">--全局变量</span></span><br><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="string">&quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">c = <span class="string">&quot;测试全局&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">--本地(局部)变量关键字 local</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> d = <span class="string">&quot;测试本地&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure><p>通过local来定义本地变量，这两种变量与其他语言差不多，都是代表外部和内部</p><p>lua语言中有多脚本执行的功能，这里就可以体会到全局与本地的区别：</p><p>Require.Lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多脚本执行======================&quot;</span>)</span><br><span class="line"><span class="comment">-- 关键字  require(&quot;脚本名&quot;)</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(testA)</span><br><span class="line"><span class="built_in">print</span>(localTestA)</span><br><span class="line"><span class="comment">-- 此时就可以体现出来 全局与本地的区别了，新加载的脚本的本地变量无法被获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新内容：require 执行一个脚本时，如果希望获取到需要的内容，比如新脚本的一个本地变量</span></span><br><span class="line"><span class="comment">-- 这时候就可以在新脚本的最后添加一个return 来返回需要的类型，然后这边定义一个变量来获取</span></span><br><span class="line"><span class="keyword">local</span> testLa = <span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(testLa)</span><br></pre></td></tr></table></figure><p>test.Lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试脚本&quot;</span>)</span><br><span class="line">testA = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">local</span> localTestA = <span class="string">&quot;259&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> localTestA</span><br></pre></td></tr></table></figure><p>可以看到test的本地变量无法被获取，不过这里也可以衍生出另外一个内容，那就是可以通过return的方式，然后在另外一边设置一个新的变量来接收，这样就能够获取得到</p><p>脚本卸载：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================脚本卸载======================&quot;</span>)</span><br><span class="line"><span class="comment">-- require加载完的脚本不会再加载第二次</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment">-- package.loaded[&quot;脚本名&quot;]</span></span><br><span class="line"><span class="comment">-- 返回值是boolean 表示脚本是否被执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="comment">-- 卸载已经执行过的脚本 只要让其为nil即可</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">loaded</span>[<span class="string">&quot;test&quot;</span>])</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>大G表：_G表是一个总表(table) 它将我们声明的所有全局的变量都存储在内；本地变量(local) 不会存放到大G表中</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================大G表======================&quot;</span>)</span><br><span class="line"><span class="comment">-- _G表是一个总表(table) 它将我们声明的所有全局的变量都存储在内</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(<span class="built_in">_G</span>) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- PS： 本地变量(local) 不会存放到大G表中</span></span><br></pre></td></tr></table></figure><h2 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================特殊用法====================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多变量赋值====================&quot;</span>)</span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="string">&quot;133&quot;</span>,<span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="comment">-- 多变量赋值 如果后面的值不够会自动补空</span></span><br><span class="line">a,b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 多变量赋值 如果后面的值多了，会自动省略</span></span><br><span class="line">a,b,c = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================多返回值====================&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 多返回值也同上边多变量赋值一样，多了会省略，少了不会报错</span></span><br><span class="line">a,b,c,d,e = Test()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========================and or====================&quot;</span>)</span><br><span class="line"><span class="comment">-- AND OR 可以连接任何东西</span></span><br><span class="line"><span class="comment">-- 在lua中 只有nil 和 false才认为是假</span></span><br><span class="line"><span class="comment">-- &quot;短路&quot;   →  对于and 来说 有假则假 对于or来说 有真则真</span></span><br><span class="line"><span class="comment">-- 所以只需要判断第一个是否满足就会停止计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">and</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">and</span> <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">and</span> <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">true</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">false</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">nil</span> <span class="keyword">or</span> <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于以上该特性，可以自定义 三目运算符</span></span><br><span class="line"><span class="comment">-- 由于Lua语言本身没有三目运算符，所以只能自定义</span></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> res = (x&gt;y) <span class="keyword">and</span> x <span class="keyword">or</span> y</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line"><span class="keyword">local</span> res = (x&gt;y) <span class="keyword">and</span> x <span class="keyword">or</span> y</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- (x&gt;y) and x ——&gt; x</span></span><br><span class="line"><span class="comment">-- x or y ——&gt; x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- (x&gt;y) and x ——&gt; (x&gt;y)</span></span><br><span class="line"><span class="comment">-- (x&gt;y) or y ——&gt; y</span></span><br></pre></td></tr></table></figure><p>这部分主要要注意的一个点就是<strong>人为构建三目运算符</strong></p><h2 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h2><p>也就是协程，但是与C#的携程不一样</p><p><strong>协程的本质是一个线程</strong>！</p><p>协程的创建有两种方式：</p><ul><li>create(函数)</li><li>wrap(函数)</li></ul><p>根据创建的方式不同，后续的启动方式也不同</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协同函数==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程创建==============================&quot;</span>)</span><br><span class="line"><span class="comment">--常用方式</span></span><br><span class="line"><span class="comment">--coroutine.create()</span></span><br><span class="line">fun = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun)</span><br><span class="line"><span class="comment">--协程的本质是一个线程对象！</span></span><br><span class="line"><span class="built_in">print</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co))</span><br><span class="line"></span><br><span class="line"><span class="comment">--coroutine.wrap()</span></span><br><span class="line">co2 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun)</span><br><span class="line"><span class="built_in">print</span>(co2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(co2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的运作==============================&quot;</span>)</span><br><span class="line"><span class="comment">-- 第一种方式 对应的是通过 create创建的协程</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="comment">-- 第二种方式</span></span><br><span class="line">co2()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的挂起==============================&quot;</span>)</span><br><span class="line">fun2 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">--协程的挂起函数</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">co3 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun2)</span><br><span class="line"><span class="comment">-- 这里就可以看出与C#的携程有所不同</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">co4 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun2)</span><br><span class="line">co4()</span><br><span class="line">co4()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协程的yield也可以有返回值，同时也能够被获取得到</span></span><br><span class="line">fun3 = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">--协程的挂起函数</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">yield</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">test1 = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(fun3)</span><br><span class="line"><span class="comment">-- 这样就能直接获取到协程返回的内容了</span></span><br><span class="line"><span class="comment">-- 该方式默认第一个返回值一定是bool类型的值，表示启动成功或者失败</span></span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line">isOk,tempi = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(test1)</span><br><span class="line"><span class="built_in">print</span>(isOk,tempi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2 = <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(fun3)</span><br><span class="line"><span class="comment">-- 这种方式也有返回值，且没有默认第一个是bool类型返回值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;返回值&quot;</span>..test2())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;========================协程的状态==============================&quot;</span>)</span><br><span class="line"><span class="comment">-- coroutine.status(协程对象)</span></span><br><span class="line"> <span class="comment">-- dead 结束</span></span><br><span class="line"> <span class="comment">-- suspended 暂停</span></span><br><span class="line"> <span class="comment">-- running 进行中</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co3))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- coroutine.running()</span></span><br><span class="line"><span class="comment">-- 该函数可以得到当前正在运行的协程的线程号</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h2><p>概述：</p><p>任何<strong>表变量</strong>都可以作为另一个表变量的元表<br>任何表变量都可以有自己的元表（父亲），当子表中进行一些特定操作时，会执行元表中的内容</p><p>首先是元表的创建(定义：)</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================元表======================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================元表概念======================&quot;</span>)</span><br><span class="line"><span class="comment">--任何表变量都可以作为另一个表变量的元表</span></span><br><span class="line"><span class="comment">--任何表变量都可以有自己的元表（父亲）</span></span><br><span class="line"><span class="comment">--当子表中进行一些特定操作时</span></span><br><span class="line"><span class="comment">--会执行元表中的内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================设置元表======================&quot;</span>)</span><br><span class="line">meta = &#123;&#125;</span><br><span class="line">myTable = &#123;&#125;</span><br><span class="line"><span class="comment">--设置元表函数</span></span><br><span class="line"><span class="comment">--第一个参数 子表</span></span><br><span class="line"><span class="comment">--第二个参数 元表(父亲)</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable,meta)</span><br></pre></td></tr></table></figure><p>元表的特定操作：</p><p>这块主要要了解的是</p><ul><li><strong>__toString</strong></li><li><strong>__call</strong></li></ul><p>分别对应了子表被当做字符串以及函数来使用，使用会比较多一些</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作======================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================__toString======================&quot;</span>)</span><br><span class="line">meta2 = &#123;</span><br><span class="line"><span class="comment">-- 当子表要被当做字符串使用时 会默认调用这个元表中的tostring方法</span></span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myTable2 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable2,meta2)</span><br><span class="line"><span class="comment">--当字符串</span></span><br><span class="line"><span class="built_in">print</span>(myTable2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================__call======================&quot;</span>)</span><br><span class="line">meta3 = &#123;</span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当子表被当做一个函数来使用时，会默认调用这个__call中的内容</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable3 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable3,meta3)</span><br><span class="line"><span class="comment">--当函数</span></span><br><span class="line">myTable3()</span><br><span class="line"></span><br><span class="line">meta4 = &#123;</span><br><span class="line"><span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(t)</span></span></span><br><span class="line"><span class="keyword">return</span> t.name</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当子表被当做一个函数来使用,同时还有参数传入的话，需要注意：</span></span><br><span class="line"><span class="comment">--此时第一个参数会默认是该子表本身！</span></span><br><span class="line"><span class="built_in">__call</span> = <span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line">myTable4 = &#123;</span><br><span class="line">name = <span class="string">&quot;你好呀&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable4,meta4)</span><br><span class="line">myTable4(<span class="number">233</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作-运算符重载======================&quot;</span>)</span><br><span class="line">meta5 = &#123;</span><br><span class="line"><span class="comment">--相当于运算符重载 当子表使用&quot;+&quot;运算符时 会调用该方法</span></span><br><span class="line"><span class="comment">-- +</span></span><br><span class="line"><span class="built_in">__add</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age + t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--当使用&quot;-&quot;运算符时 会调用该方法</span></span><br><span class="line"><span class="comment">-- -</span></span><br><span class="line"><span class="built_in">__sub</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age - t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- *</span></span><br><span class="line"><span class="built_in">__mul</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age * t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- /</span></span><br><span class="line"><span class="built_in">__div</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age / t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- %</span></span><br><span class="line"><span class="built_in">__mod</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age % t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- ^</span></span><br><span class="line"><span class="built_in">__pow</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age ^ t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- ==</span></span><br><span class="line"><span class="built_in">__eq</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- &lt;</span></span><br><span class="line"><span class="built_in">__lt</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age &lt; t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">-- &lt;=</span></span><br><span class="line"><span class="built_in">__le</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> t1.age &lt;= t2.age</span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="comment">--这里要注意：lua语言这个模块下，只有&lt;和&lt;=相关的，但是没有&gt;和&gt;=</span></span><br><span class="line"><span class="comment">-- ..</span></span><br><span class="line"><span class="built_in">__concat</span> = <span class="function"><span class="keyword">function</span><span class="params">(t1,t2)</span></span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myTable5 = &#123;age=<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable5,meta5)</span><br><span class="line">myTable6 = &#123;age=<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myTable5 + myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 - myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 * myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 / myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 % myTable6)</span><br><span class="line"><span class="built_in">print</span>(myTable5 ^ myTable6)</span><br><span class="line"></span><br><span class="line"><span class="comment">--如果要用条件运算符来比较两个对象</span></span><br><span class="line"><span class="comment">--这两个对象的元表一定要一致才能调用！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--不一致情况下：</span></span><br><span class="line"><span class="built_in">print</span>(myTable5 == myTable6)</span><br><span class="line"><span class="comment">--一致情况下：</span></span><br><span class="line"><span class="built_in">setmetatable</span>(myTable6,meta5)</span><br><span class="line"><span class="built_in">print</span>(myTable5 == myTable6)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;===========================================&quot;</span>)</span><br></pre></td></tr></table></figure><p>元表另外两个比较重要的特定操作：</p><ul><li>__index</li><li>newindex</li></ul><p>这两个操作可以实现类似于继承的操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================特定操作-__index和__newindex======================&quot;</span>)</span><br><span class="line">meta6Father = &#123;</span><br><span class="line">age = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">meta6Father.<span class="built_in">__index</span> = meta6Father</span><br><span class="line">meta6 = &#123;</span><br><span class="line"><span class="comment">--age = 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--__index的赋值最好写在表外边来初始化</span></span><br><span class="line">meta6.<span class="built_in">__index</span> = meta6</span><br><span class="line"></span><br><span class="line">myTable7 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(meta6,meta6Father)</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable7,meta6)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--__index 当子表中找不到一个属性时 会到元表中的__index指定的表去找</span></span><br><span class="line"><span class="built_in">print</span>(myTable7.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--newindex 当赋值时，如果赋值一个不存在的索引，那会把这个值赋值到newindex所指向的表中，而不会修改自己</span></span><br><span class="line">meta7 = &#123;&#125;</span><br><span class="line">meta7.<span class="built_in">__newindex</span> = &#123;&#125;</span><br><span class="line">myTable8 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(myTable8,meta7)</span><br><span class="line">myTable8.age = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(myTable8.age)</span><br><span class="line"></span><br><span class="line"><span class="comment">--元表的其他方法</span></span><br><span class="line"><span class="comment">--rawget 使用时会去找当前表自己的身上有没有这个变量    可以绕开__index</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">rawget</span>(myTable8,<span class="string">&quot;age&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--rawset 可以绕开newindex</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="★面向对象"><a href="#★面向对象" class="headerlink" title="★面向对象"></a>★面向对象</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>表就是实现类的一种形式</p><p>封装主要是实现了new方法</p><ul><li>本质上是创建了一个空表</li><li>元表</li><li>__index</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================面向对象==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================封装==============================&quot;</span>)</span><br><span class="line"><span class="comment">--面向对象，类，都是基于 table来实现</span></span><br><span class="line">Object = &#123;&#125;</span><br><span class="line">Object.id = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--冒号 会自动将调用这个函数的对象作为第一个参数传入</span></span><br><span class="line"><span class="comment">--定义new方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object:new</span><span class="params">()</span></span></span><br><span class="line"><span class="comment">--self 代表默认传入的第一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--对象就是变量，相当于要返回一个新的变量</span></span><br><span class="line"><span class="comment">--返回出去的内容其实就是该表的对象</span></span><br><span class="line"><span class="keyword">local</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line"><span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">return</span> obj</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> newObj = Object:new()</span><br><span class="line"><span class="built_in">print</span>(newObj.id)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================继承==============================&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================多态==============================&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承与封装不同的是需要调用_G表来创建一个新表&#x2F;类</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================继承==============================&quot;</span>)</span><br><span class="line"><span class="comment">--写一个用于继承的方法</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Object:subClass</span><span class="params">(className)</span></span></span><br><span class="line"> <span class="comment">--_G 是总表，所有声明的全局变量都以键值对的形式存在其中</span></span><br><span class="line"> <span class="built_in">_G</span>[className] = &#123;&#125;</span><br><span class="line"> <span class="comment">--写相关继承的规则</span></span><br><span class="line"> <span class="comment">--用到元表</span></span><br><span class="line"> <span class="keyword">local</span> obj = <span class="built_in">_G</span>[className]</span><br><span class="line"> <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line"> <span class="built_in">setmetatable</span>(obj,<span class="built_in">self</span>)</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于Person表继承了Object表</span></span><br><span class="line">Object:subClass(<span class="string">&quot;Person&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(Person)</span><br><span class="line"><span class="built_in">print</span>(Person.id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p1 = Person:new()</span><br><span class="line"><span class="built_in">print</span>(p1.id)</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>相同方法名，不同处理逻辑</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=============================多态==============================&quot;</span>)</span><br><span class="line"><span class="comment">--相同方法 不同执行逻辑</span></span><br><span class="line">Object:subClass(<span class="string">&quot;GameObject&quot;</span>)</span><br><span class="line">GameObject.posX = <span class="number">0</span>;</span><br><span class="line">GameObject.posY = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GameObject:Move</span><span class="params">()</span></span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.posX)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">self</span>.posY)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">GameObject:subClass(<span class="string">&quot;Player&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player:Move</span><span class="params">()</span></span></span><br><span class="line"> <span class="comment">--base指的是GameObject表</span></span><br><span class="line"> <span class="comment">--如果要执行父类逻辑，不要使用冒号，而是使用逗号，将自己作为第一个参数</span></span><br><span class="line"><span class="built_in">self</span>.base.Move(<span class="built_in">self</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p1 = Player:new()</span><br><span class="line">p1:Move()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p2 = Player:new()</span><br><span class="line">p2:Move()</span><br></pre></td></tr></table></figure><p>复习视频：<a href="https://www.bilibili.com/video/BV1iA411n7oQ?p=21&amp;vd_source=2120a503db4ff85e38e1bba833eae2e6">https://www.bilibili.com/video/BV1iA411n7oQ?p=21&amp;vd_source=2120a503db4ff85e38e1bba833eae2e6</a></p><h2 id="自带库"><a href="#自带库" class="headerlink" title="自带库"></a>自带库</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================自带库======================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================时间======================&quot;</span>)</span><br><span class="line"><span class="comment">--系统时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br><span class="line"><span class="comment">--自己传入参数 得到时间</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>(&#123;year = <span class="number">2024</span>,month=<span class="number">8</span>,day=<span class="number">11</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> nowTime = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(nowTime) <span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(nowTime.hour)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================数学运算======================&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--绝对值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">abs</span>(<span class="number">-11</span>))</span><br><span class="line"><span class="comment">--弧度转角度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">deg</span>(<span class="built_in">math</span>.<span class="built_in">pi</span>))</span><br><span class="line"><span class="comment">--三角函数 math.cos(math.pi)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--向上取整 math.floor</span></span><br><span class="line"><span class="comment">--向下取整 math.ceil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--最大值 math.max</span></span><br><span class="line"><span class="comment">--最小值 math.min</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--小数分离 分成整数和小数部分 math.modf</span></span><br><span class="line"><span class="comment">--幂运算 math.pow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--随机数 先设置随机数种子 math.randomseed(os.time()) math.random</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--开方 math.sqrt</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=================路径======================&quot;</span>)</span><br><span class="line"><span class="comment">--lua脚本加载路径</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">package</span>.<span class="built_in">path</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（四）</title>
      <link href="/2024/06/07/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/06/07/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="UI部分"><a href="#UI部分" class="headerlink" title="UI部分"></a>UI部分</h1><p>诸如血条、能量条等要显示在各个对象头上的情况下，要注意Canvas组件下的模式(Render Mode)要切换为<code>World Space</code>模式，要实现的大致效果为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220036939.png" alt="image-20240607220036939"></p><p>同时由于是3D项目，如果要使用Sprite 2D的图片内容来实现UI的话，还要先手动下载并导入<code>2D Sprite</code></p><p>将对应的UI做好之后，一般都是要通过C#脚本来调用和绑定的，这里就有个小技巧：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220613669.png" alt="image-20240607220613669"></p><p>在脚本要挂载到各个对象并要进行绑定的情况下，可以通过在文件夹下点击脚本，先把要挂载的预制体绑定起来，这样只要对象上挂载该脚本，绑定的预制体也会跟着移动过去</p><p>若要绑定在怪物头顶上，则可以通过直接在预制体创建对应的一个空容器来对应头顶的坐标，这样可以方便后续的UI绑定操作：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607220946406.png" alt="image-20240607220946406"></p><p>同时对应的UI脚本初始化的属性内容也和2D有所不同：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607222348957.png" alt="image-20240607222348957"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607222752393.png" alt="image-20240607222752393"></p><p>以及血条要一直处于摄像机视角位置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607233021610.png" alt="image-20240607233021610"></p><p>同时，如果场景下怪物过多，就没必要开启所有的血条一直保持显示状态，而是可以通过创建一个计时器，在攻击的时候打开，持续几秒后就关闭，减少显示的内容过多导致的资源浪费</p><h1 id="场景切换与跨场景交互"><a href="#场景切换与跨场景交互" class="headerlink" title="场景切换与跨场景交互"></a>场景切换与跨场景交互</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（三）</title>
      <link href="/2024/06/04/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/06/04/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="人物基本属性"><a href="#人物基本属性" class="headerlink" title="人物基本属性"></a>人物基本属性</h1><p>通过Scriptable容器设置一个装基础数值的SO容器，再UI上创建SO容器对应的内容：玩家数据存储容器、怪物数据存储容器等，定义用来连接该容器的类，比如：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604191213093.png" alt="image-20240604191213093"></p><p>最后再把脚本挂载到对应的物体上，通过在物体上绑定对应的容器，就可以通过不同的操作来访问或者修改SO容器里边的数值内容了</p><h2 id="攻击实现"><a href="#攻击实现" class="headerlink" title="攻击实现*"></a>攻击实现*</h2><p>通常来说，一个游戏如果搭建有战斗系统或者比较成熟一点的武器框架，那么<strong>攻击力一般不会作为人物的基本属性来进行定义，而是单独拎出来作为一个数据容器进行定义</strong>，这样可以通过一个容器来分别代表不同类型武器或者职业，对应的攻击力、攻击CD、攻击Buff、攻击距离等内容自定义：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//近战攻击距离</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> attackRange;</span><br><span class="line">   <span class="comment">//远程攻击距离</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> skillRange;</span><br><span class="line">   <span class="comment">//间隔CD</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> coolDown;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> minDamage;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> maxDamage;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//暴击倍率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> criticalMultiplier;</span><br><span class="line">   <span class="comment">//暴击几率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">float</span> criticalChance;</span><br><span class="line">... <span class="comment">//等等</span></span><br></pre></td></tr></table></figure><p>这样就可以创建该类型容器，然后为其自定义修改数值，再通过挂载的脚本进行绑定，有利于快速搭建</p><p>同时可以看到里边涉及到的有暴击率的内容，暴击率可以通过爆伤和爆率两个部分，其中演示了下暴击率的具体使用，比如可以通过<strong>Random.value</strong>方法的方式来计算本次攻击是否暴击：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604210516685.png" alt="image-20240604210516685"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">characterStart.isCritical = Random.<span class="keyword">value</span> &lt; characterStart.attackData.criticalChance;</span><br></pre></td></tr></table></figure><p>该方法随机取0.0 - 1.0的数字，只要让其满足在<strong>暴击率区间内</strong>即可判定是触发暴击了</p><p>接下来就是对攻击力进行处理，通常来说要根据自己定义的数值内容进行计算，比如游戏中的防御力、闪避率、debuff等都会影响到最终收到的伤害，所以要定义一个对应的计算公式或者一个简单的乘除方法来计算受到的伤害，攻击的内容一般也可以在Character类下进行，可以通过其本身绑定的其他容器来快捷进行计算：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">CharacterStart attacker,CharacterStart defener</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">int</span> damage = (<span class="built_in">int</span>)Mathf.Max(attacker.CurrentDamage() - defener.BaseDefence, <span class="number">0</span>);</span><br><span class="line">      currentHealth = Mathf.Max(currentHealth - damage, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="built_in">int</span> <span class="title">CurrentDamage</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//攻击力</span></span><br><span class="line">      <span class="built_in">float</span> coreDamage = UnityEngine.Random.Range(attackData.minDamage,attackData.maxDamage);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//暴击</span></span><br><span class="line">      <span class="keyword">if</span>(isCritical)</span><br><span class="line">      &#123;</span><br><span class="line">          coreDamage *= attackData.criticalMultiplier;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">int</span>)coreDamage;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后是为其绑定触发攻击事件的方法，在定义了调用Character里边的Damage方法后，可以通过动画帧的方式来直接调用该方法：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604222555483.png" alt="image-20240604222555483"></p><p>在右上角的Function选择刚创建的造成攻击的方法即可，当然这种方法也有一些弊端，所以具体实现还是有很多不同方式可以来执行的，具体就靠个人实践了</p><p>死亡动画一般是在AnyState下连接的，这块有个要注意的设置的点：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605101155929.png" alt="image-20240605101155929"></p><p>要关闭，否则会一直播放</p><p>最后还有一些要注意到的细节点进行调整，其中一个就是到达目标点位置可能会带来的一些需要被优化的影响，如果指定一个比较大的物体，该物体模型过大可能会导致人物在即将到达目标点的时候左右移动缓慢寻找该目标点</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607135621710.png" alt="image-20240607135621710"></p><p>其中一个方式可以通过在代码中针对特定场景下调整Stopping Distance的距离，再下次移动的时候复原就行</p><h2 id="▲泛型单例模式"><a href="#▲泛型单例模式" class="headerlink" title="▲泛型单例模式"></a>▲泛型单例模式</h2><p>在制作Manager管理器相关的脚本内容的时候，通常这些管理器的脚本都要设置为单例模式来进行统一管理，方便我们进行一些功能的实现，这时候就可以使用到泛型单例模式，通过这个模式让我们节省很多创建单例的时间，而是通过一个泛型可被继承的自定义工具类来实现：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singletion</span>&lt;<span class="title">T</span>&gt; : <span class="title">MonoBehaviour</span> <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singletion</span>&lt;<span class="title">T</span>&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            instance = (T)<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否创建成功</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> IsInitialized</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> instance != <span class="literal">null</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">this</span>) &#123; instance = <span class="literal">null</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以直接通过继承该泛型单例类来完成单例的创建：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605110020624.png" alt="image-20240605110020624"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>通过定义接口的方式来作为订阅与广播方来往的途径之一，让继承了该接口方式的类对象都作为订阅方，这样来实现观察者模式</p><p>首先定义订阅接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEndGameObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结束游戏的广播</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EndNotify</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着比如为每个怪物都绑定该接口并实现该方法，方法内容可以自定义，比如结束游戏时停止移动，停止动画等等一系列操作，接着是要在Manager管理器下来收集这些<strong>所有订阅了该方法的对象</strong>，同时定义添加和移除方法，方便让每创建一个该对象就能自动调用管理器下的这两个方法自动的添加到我们收集的列表中去：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//收集订阅方</span></span><br><span class="line">List&lt;IEndGameObserver&gt; endGameObservers = <span class="keyword">new</span> List&lt;IEndGameObserver&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddObserver</span>(<span class="params">IEndGameObserver observer</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       endGameObservers.Add(observer);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveObserver</span>(<span class="params">IEndGameObserver observer</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       endGameObservers.Remove(observer);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>再将这些类对象脚本设置启动&#x2F;关闭时候通过管理器的两个方法自动加入&#x2F;退出该订阅列表即可，最后再回到管理器上实现广播的通知，比如</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotifyObserver</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> observer <span class="keyword">in</span> endGameObservers) </span><br><span class="line">        &#123;</span><br><span class="line">            observer.EndNotify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>广播可以在需要触发的对象或者内容里边自己去设置和调整在什么时候开启这个广播，从而来让所有订阅方都能接收并完成后续的操作，这块就自主去制作就行</p><h1 id="多怪物设置"><a href="#多怪物设置" class="headerlink" title="多怪物设置"></a>多怪物设置</h1><p>当怪物有多个的情况下，要考虑到单纯复制会导致所有怪物都共用一个SO容器，这样就会导致一个怪物死亡其他怪物也跟着死亡的局面，这里就要了解到SO容器本质上也是一个模板，可以通过脚本的方式来复制模板给予到新创建的怪物，实现每个怪物都有单独独立的一个SO存储数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//模板</span></span><br><span class="line">   <span class="keyword">public</span> CharacterData_SO templateData;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> CharacterData_SO characterData;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(templateData != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           characterData = Instantiate(templateData);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>新怪物动画创建可以用一个可覆盖的动画控制器来进行重构，这样会缩短开发的时间：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605220751713.png" alt="image-20240605220751713"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605220851182.png" alt="image-20240605220851182"></p><p>这样就可以基于之前已经做好的怪物动画控制器来进行修改，也能快速的构建出来我们新的怪物动画内容，提高我们开发的效率</p><p>别的怪物素材可以选择一些免费的素材，比如<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240605221112337.png" alt="image-20240605221112337">等FREE资源</p><h2 id="设置其他类型怪物效果"><a href="#设置其他类型怪物效果" class="headerlink" title="设置其他类型怪物效果"></a>设置其他类型怪物效果</h2><p>玩家碰撞时触发，把玩家击飞，在对应的动画帧里边添加对应的方法，击飞的主要来源一个就是力量，一个就是方向，通过对两个物体之间的坐标进行运算来得到一个相对坐标，再通过归一化后乘以力量，这样就能达到一个击飞的效果，像挑飞等动作大致相同，后续也可以去了解一下，这里简单看一下代码展示：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">KickOff</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(attackTarget != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.LookAt(attackTarget.transform);</span><br><span class="line"></span><br><span class="line">            Vector3 dir = attackTarget.transform.position - transform.position;</span><br><span class="line">            <span class="comment">//归一化</span></span><br><span class="line">            dir.Normalize();</span><br><span class="line"></span><br><span class="line">            attackTarget.GetComponent&lt;NavMeshAgent&gt;().isStopped = <span class="literal">true</span>;</span><br><span class="line">            attackTarget.GetComponent&lt;NavMeshAgent&gt;().velocity = dir*kickForce;</span><br><span class="line">            attackTarget.GetComponent&lt;Animator&gt;().SetTrigger(<span class="string">&quot;Dizzy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时如果要更加现实一点，那么还要为动画播放的时候也绑定一个脚本，通过进入动画、动画进行中、动画结束三个阶段来实现对应的代码，从而可以实现类似被眩晕&#x2F;受伤时候无法移动的效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606172359477.png" alt="image-20240606172359477"></p><h3 id="石头砸人-▲网格碰撞体"><a href="#石头砸人-▲网格碰撞体" class="headerlink" title="石头砸人(▲网格碰撞体)"></a>石头砸人(▲网格碰撞体)</h3><p>设置怪物投石效果，具体表现为：发现玩家后丢出石头 → 石头砸到玩家 → 玩家被击退并眩晕</p><ol><li><p>第一步就是要创建对应的投掷物</p><p>首先这块需要添加刚体组件，因为我们要让石头被丢出去，且实际表现就是自由落体，所以需要刚体来实现运行轨迹</p></li></ol><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607163943339.png" alt="image-20240607163943339"></p><p>​新内容：<strong>网格碰撞体</strong> <strong>Mesh Collider</strong></p><p>​由于我们要实现石头碰到人物的时候会触发相应的代码内容，这意味着要有一个碰撞体，而对于石头这种不规则形状的3D物体，我们就需要用到一个新的组件<code>Mesh Colider</code>来实现这块内容，从而达到相同的效果：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607164331180.png" alt="image-20240607164331180"></p><ol start="2"><li><p>让石头被投掷出去</p><p>这意味着要对石头的刚体组件进行相应的操作，其实际上就是要有一个方向以及一个力，同时该内容的触发也要在动画的关键帧上去进行，单纯让石头动起来的代码大体为：</p></li></ol> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FlyToTarget</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//细节修改  生成石头瞬间脱战，仍能把石头丢出去</span></span><br><span class="line">       <span class="keyword">if</span> (target == <span class="literal">null</span>)</span><br><span class="line">           target = FindObjectOfType&lt;PlayerController&gt;().gameObject;</span><br><span class="line"> </span><br><span class="line">       dir = (target.transform.position - transform.position + Vector3.up).normalized;</span><br><span class="line">       rb.AddForce(dir * force, ForceMode.Impulse);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>石头的生成并触发</p><p>石头的生成和触发可以绑定在对应的物体或者怪物身上，生成的时候使用<code>Instantiate</code>即可，同时让石头身上绑定的脚本对应的目标也赋值为当前物体要攻击的目标即可，最后是在对应的动画帧上设置Animation Event，然后选择该方法内容即可实现</p></li></ol><p>最后有一个细节需要考虑到，如果要让丢石头的时候，在石头生成再到丢出去的时间里边，如果玩家离开了攻击范围，那么这时候石头默认就不再被显示出来了，这里使用<code>FindObjectOfType&lt;PlayerController&gt;().gameObject</code>的方式直接查找到对应的Player对象解决的该问题，或许有其他方法</p><p>另外一个就是玩家会穿模石头，这块可以用为角色添加刚体组件来避免，要注意的是：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607213817812.png" alt="image-20240607213817812"></p><h2 id="正面存在敌人再进行攻击"><a href="#正面存在敌人再进行攻击" class="headerlink" title="正面存在敌人再进行攻击*"></a>正面存在敌人再进行攻击*</h2><p>新内容：<strong>扩展方法</strong></p><p><strong>概述：</strong> 在C#中，扩展方法是一种特殊的静态方法，它能够对现有类型进行增强，无需修改原始类型的情况下，添加新的方法。扩展方法是通过<strong>使用 <code>this</code> 关键字</strong>在一个<strong>非抽象的静态类</strong>中定义的，并且它<strong>必须有至少一个参数</strong>。<strong>第一个参数指定了你要扩展的类型，并且该参数前面的 <code>this</code> 关键字是不可省略的</strong></p><p>通过扩展方法的方式来进行定义，实现该内容主要就是通过敌人的正面一个扇形范围内检测是否有敌人，如果有则进行攻击，否则则继续其他操作，比如移动等</p><p>此时还要用到一个新的方法——<strong>点乘法</strong>，该方法就是用于通过扇形面积判断内容的，本质上也就是通过余弦值的大小来判断物体处于当前位置的哪个方位(正面or背面)：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606212944022.png" alt="image-20240606212944022"></p><p>可以看到官方给的实例为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606221945449.png" alt="image-20240606221945449"></p><p>这块可以通过该视频的详解：<a href="https://www.bilibili.com/video/BV1M2421u7Bm">https://www.bilibili.com/video/BV1M2421u7Bm</a></p><p>最后编写的扩展类就为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtensionMethod</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">float</span> dotThreshold = <span class="number">0.5f</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsFacingTarget</span>(<span class="params"><span class="keyword">this</span> Transform transform,Transform target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> vectorToTarget = target.position - transform.position;</span><br><span class="line">        vectorToTarget.Normalize();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> dot = Vector3.Dot(transform.forward,vectorToTarget);</span><br><span class="line">        <span class="keyword">return</span> dot &gt;= dotThreshold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以方便让其他有需要的类可以直接使用扩展的方法，比如怪物类就可以采用该扩展类来进行需求判断，比如：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(attackTarget != <span class="literal">null</span> &amp;&amp; transform.IsFacingTarget(attackTarget.transform))</span><br></pre></td></tr></table></figure><h1 id="Particle-System特效"><a href="#Particle-System特效" class="headerlink" title="Particle System特效"></a>Particle System特效</h1><p>通过Particle System实现一些特效效果，该组件的内容很多，具体内容需要去查看中文官方文档或者其他详细教程，一般在实践过程中根据需要再去了解具体实现即可</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240607215316930.png" alt="image-20240607215316930"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（二）</title>
      <link href="/2024/06/02/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/06/02/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="鼠标控制人物移动"><a href="#鼠标控制人物移动" class="headerlink" title="鼠标控制人物移动"></a>鼠标控制人物移动</h1><p>通过事件的方式来实现，实际上具体的流程大致就分为：</p><p>鼠标点击的时候获取当前点位(Vector3) → 把点位传给对应的脚本进行处理，该脚本调用挂载角色身上的组件 → 赋值给组件上对应的方法，从而让人物移动到目标点位</p><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测*"></a>射线检测*</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602205859494.png" alt="image-20240602205859494"></p><p>可以直接通过该文档里的实例在实践中看到该射线</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602211958995.png" alt="image-20240602211958995"></p><p>所以只要让我们鼠标点击某个位置的时候，该射线就跟着我们的鼠标指向对应的位置，这样就可以通过射线来检测到点位了</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602212226729.png" alt="image-20240602212226729"></p><p>检测物品信息则是通过<strong>Raycast</strong>来实现的,能够被Raycast射线检测的物体的前提有：</p><ol><li><strong>具有 Collider 组件</strong>：</li></ol><ul><li>物体必须拥有 Collider 组件，如 BoxCollider, SphereCollider, MeshCollider 等，没有 Collider 的物体不会与射线发生交互。</li></ul><ol start="2"><li><strong>正确的层（Layer）设置</strong>：</li></ol><ul><li>Unity 允许你为每个物体设置层（Layer），并在执行 Raycast 时选择射线可以检测哪些层的物体，这是通过 Raycast 函数中的 Layer Mask 参数来实现的</li></ul><ol start="3"><li><strong>Collider 必须启用</strong>：</li></ol><ul><li>如果 Collider 组件被禁用，即使物体上有 Collider，射线也无法检测到它</li></ul><ol start="4"><li><strong>非触发器模式</strong>：</li></ol><ul><li>Collider 可以设置为“触发器”模式（Is Trigger 属性设置为 true）。在触发器模式下，Collider 用于触发事件而不是物理碰撞，通常射线不会检测到设置为触发器的 Collider，确保 Collider 的“Is Trigger”属性设置为 false。</li></ul><p>接着挂载对应的事件：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602211315747.png" alt="image-20240602211315747"></p><p>最后是实现脚本内容并进行测试</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新射线</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetCursorTexture</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Physics.Raycast(ray, <span class="keyword">out</span> hitInfo))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鼠标点击移动</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MouseController</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Input.GetMouseButtonDown(<span class="number">0</span>) &amp;&amp; hitInfo.collider != <span class="literal">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (hitInfo.collider.gameObject.CompareTag(<span class="string">&quot;Ground&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                OnMouseClicked?.Invoke(hitInfo.point);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同时细节调整还有人物在移动和转向时的内容</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602215103663.png" alt="image-20240602215103663"></p><p>其中Stopping Distance指的是到达目标点 x 距离就停止，这种比较常用于不同长度武器下如果指向敌人要进行攻击的话，就可以运用到</p><p>Auto Braking则是刹车的意思，相当于人物到达目标点一定距离是就会平缓减速</p><p>最后实现鼠标控制移动，分别通过在角色身上挂载的角色控制脚本绑定事件，定义移动的函数，然后在Manager下挂载的对应脚本内容实现事件的注册与启用，检测鼠标点击也在该脚本下完成</p><h2 id="摄像机跟踪和后处理"><a href="#摄像机跟踪和后处理" class="headerlink" title="摄像机跟踪和后处理"></a>摄像机跟踪和后处理</h2><p>安装<code>Cinemachine</code>脚本，创建虚拟摄像机，创建完成后虚拟摄像机(<strong>CinemachineVirtualCamera</strong>)就会顶替掉Main Camera，同时这里还有个操作可以让<code>#Scene</code>视角也锁定到我们的相机视角：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602221755447.png" alt="image-20240602221755447"></p><p>然后对虚拟相机进行配置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602222144619.png" alt="image-20240602222144619"></p><p>这里要注意的是，当前跟踪相机它对准的中心点默认就是人物最底的一个点，如果要让视角在人物上某一位置的话，可以通过在人物创建一个子物体，通过调整子物体的坐标，然后再让虚拟相机跟随的视角是该子物体即可</p><p>跟随效果下还有多种效果可以实现，具体的数值更改有很多</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602231703920.png" alt="image-20240602231703920"></p><p>可以参考<a href="https://www.bilibili.com/video/BV1FN4y1G7n1">https://www.bilibili.com/video/BV1FN4y1G7n1</a></p><p><a href="https://blog.csdn.net/linxinfa/article/details/124537415">https://blog.csdn.net/linxinfa/article/details/124537415</a></p><p>同时在修改过程中，还可以通过可视化加快捷键的方式快速的对虚拟相机的角度进行更改：</p><p>选中虚拟相机 → GameObject下Align View to Selected → 鼠标或者AWSD调整新的角度 → 快捷键<code>Ctrl＋shift＋f</code>即可调整完成</p><h3 id="自由视角相机"><a href="#自由视角相机" class="headerlink" title="自由视角相机"></a>自由视角相机</h3><p>通过设置<code>FreeLook Cinema</code>来设置自由相机，对自由相机进行调整，了解里边对应的内容分别起到什么作用</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214409088.png" alt="image-20240603214409088"></p><p>这两个内容可以通过在Project Setting的Input Manager下可以查询到，只要把内容改为我们想要使用的按键即可</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214529911.png" alt="image-20240603214529911"></p><p>同时自由视角对应的三个红色圆环也可以自由设置范围大小，从而让视角更加符合实际</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603214927708.png" alt="image-20240603214927708"></p><p>效果可以在实践的时候也进行调整，这时候只要把该虚拟相机里边的 Save During Play 勾选上即可实现在启动过程中也完成修改并保存的操作了</p><p>同时也可以更改相机的模式，比如让自由视角也能跟着人物的移动而发生变化或者跟着鼠标的点击而发生变化等等，只要通过<code>Binding Mode</code>里边选择类型尝试即可</p><p>如果是要实现第三人称视角且切换方向或者移动视角的时候，摄像机都是人物背后，那么可以调整为：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240606172757978.png" alt="image-20240606172757978"></p><h2 id="实现远近景效果"><a href="#实现远近景效果" class="headerlink" title="实现远近景效果"></a>实现远近景效果</h2><p>通过Lighting来实现画面的效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602233316296.png" alt="image-20240602233316296"></p><p>在Scene窗口模式中通过<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602233345607.png" alt="image-20240602233345607"></p><p>显示迷雾，编辑时可以选择忽略</p><h2 id="后处理-后续要深入一点"><a href="#后处理-后续要深入一点" class="headerlink" title="后处理*(后续要深入一点)"></a>后处理*(后续要深入一点)</h2><ul><li><p><strong>Volume的类型</strong></p><ul><li>Global Volume(当前选用)</li><li>Box Volume</li><li>Sphere Volume</li><li>Convex Mesh Volume</li></ul><p><img src="/./../../../typora-images/image-20240602233553204-1717343202890-14.png" alt="image-20240602233553204"></p></li><li><p><strong>Volume下的各种效果</strong>(不仅仅只有这些)</p></li></ul><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234733656.png" alt="image-20240602234733656"></p><p>其中Box Volume是区域处理，比如到达某个场景的时候出现什么效果等，所以该功能相对重要一些，后续有待再继续研究与了解</p><p>大致了解一下</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234233494.png" alt="image-20240602234233494"></p><p>Global下有多种效果可以实现，不同效果都不一样，需要配置的内容也不一样，同时，如果要实现效果，还要在<strong>相机</strong>位置进行启用：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602234408214.png" alt="image-20240602234408214"></p><h2 id="遮挡剔除-后续要深入一点"><a href="#遮挡剔除-后续要深入一点" class="headerlink" title="遮挡剔除*(后续要深入一点)"></a>遮挡剔除*(后续要深入一点)</h2><p>通过创建<code>Shader Graph</code>来完成遮挡剔除的操作，创建方式：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603154017784.png" alt="image-20240603154017784"></p><p>然后基于该shader graph再创建一个material材质球，双击shader graph进入对应的编辑页面：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603154631849.png" alt="image-20240603154631849"></p><p>然后通过构建不同的效果以及数值来达到遮挡的效果，这里主要试用了Fresnel Effect、Multiply、Dither等来实现大致的效果：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603160956610.png" alt="image-20240603160956610"></p><p>其实<strong>本质上就是创建一个新的材质球</strong>，然后通过判定角色遮挡的时候调用该材质球，所以要在渲染管线位置进行条件切换的设置</p><p>PS：完成修改后要记得使用<code>Save Asset</code>选项进行保存！</p><p>回到URP渲染管线位置，在<strong>Universal Render Pipeline Asset_Renderer</strong>里进行设置：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604143301027.png" alt="image-20240604143301027"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603161948511.png" alt="image-20240603161948511"></p><p>然后选择刚才创建的材质盒，同时为其设置好开启该材质盒的要求</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603162057342.png" alt="image-20240603162057342"></p><p>如图该条件表示就是通过深度来确定什么时候调整的，比如人物在树后边，则相当于经过树之后才是人物，这意味着人的深度比树的要高，所以选用greater的情况</p><p>同时不要忘了<code>Later Mask</code>也要调整起作用的图层是哪个，比如要对人物起遮挡效果，那么Later Mash就要切换为人物所在的图层</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603163249337.png" alt="image-20240603163249337"></p><p>同时还要多创建一个Render Object来让角色在没被遮挡的情况下材质为正常的材质：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603163357695.png" alt="image-20240603163357695"></p><p>最后是要修改一下树木遮挡鼠标点击，可以通过直接为树木添加一个忽略射线的图层<code>Ignore Raycast</code>，也可以通过直接删除树木里边的<code>Collider</code>组件，从而失去被射线检查到的情况</p><h1 id="怪物设定"><a href="#怪物设定" class="headerlink" title="怪物设定"></a>怪物设定</h1><p>这里有一个新的知识点，已知每个怪物到时候都要继承有一个基类，同时一些基础的组件是每个怪物都应该有的，那么就可以通过以下这种方式来实现当怪物<strong>挂载一个通用的脚本的时候同时也自动挂载其他需要的组件</strong>：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603201159185.png" alt="image-20240603201159185"></p><p>同时要注意挂载NavMeshAgent的时候也要调整一下该组件的数值，同时结合实际需求可能也要为其增加一个新的碰撞体，方便进行检查，交互等其他功能实现</p><p>同时视角遮挡也要添加怪物的层数，让怪物也不能被遮挡剔除掉，同上在Layer Mask下进行多选一层Enemy</p><h2 id="怪物范围检测"><a href="#怪物范围检测" class="headerlink" title="怪物范围检测"></a>怪物范围检测</h2><p>与2D不同的是，怪物的范围检测可以通过OverlapSphere球状检测：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240603221211397.png" alt="image-20240603221211397"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> colliders = Physics.OverlapSphere(transform.position, sightRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> collider <span class="keyword">in</span> colliders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(collider.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前提是检测的人物身上也必须绑定有对应的碰撞体，这样才能检测到其身上挂载有colliders，才能进行后续内容判断</p><h2 id="怪物动画切换"><a href="#怪物动画切换" class="headerlink" title="怪物动画切换"></a>怪物动画切换</h2><p>通过不同动画图层Animator Layer管理动画，通过不同图层来实现同一时间播放不同的动画，从而得到一个比较完整的动画效果</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604151253055.png" alt="image-20240604151253055"></p><p>具体介绍可以参考：<a href="https://blog.csdn.net/weixin_39520967/article/details/107372810">https://blog.csdn.net/weixin_39520967/article/details/107372810</a></p><p>具体怪物动画什么时候切换在代码中进行实现，通过游戏设定的不同自己根据合理情况对动画切换的值进行更改</p><p>同时要区分Animator控制器里边Param数值类型的 <strong>Bool</strong> 和 <strong>Trigger</strong>： Trigger可以说相当于一次性的Bool，它在触发True就会自动返回false，在动画控制中也就相当于启动了一次动画，然后回到上一个动画状态</p><p>具体内容可以参考：<a href="https://blog.csdn.net/c3872931/article/details/132820214">https://blog.csdn.net/c3872931/article/details/132820214</a></p><p>怪物动画设置过程中，还有以下两个知识点记录一下：</p><p>除了通过使用Vector3.Distance来判断两点之间的距离，还可以通过<code>Vector3.SqrMagnitude</code>的方式来进行计算：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Vector3.SqrMagnitude(guardPos-transform.position)&lt;=agent.stoppingDistance)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Walk = <span class="literal">false</span>;</span><br><span class="line">                        transform.rotation = Quaternion.Lerp(transform.rotation, guardRotation, <span class="number">0.01f</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>这种方式要比Distance的花销要小一些</p><p>第二个就是对于转向的控制，通常是使用Quaternion.Lerp进行一个缓慢转向而不是瞬间转向</p><h2 id="怪物巡逻"><a href="#怪物巡逻" class="headerlink" title="怪物巡逻"></a>怪物巡逻</h2><p>这里有个新的实用内容点：通过**OnDrawGizmosSelected()**方法来在场景里边可视化显示范围</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604171042562.png" alt="image-20240604171042562"></p><p>定义需要的巡逻实现内容，本质上就是在圈定的范围内计算随机点，当怪物到达随机点后再生成一个新的巡逻点，以此往复</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巡逻实现</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">       <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">       Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">       wayPoint = randomPoint;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>细节处理除了通过Vector3.Distance计算当前怪物与巡逻点的位置之外，还要增加<strong>对障碍物的判断</strong>，以防止随机点在障碍物必经过导致怪物重复被阻挡的情况，这时候要通过NavMesh组件下的<strong>SamplePosition</strong>方法来解决这个问题：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604163354347.png" alt="image-20240604163354347"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604163438854.png" alt="image-20240604163438854"></p><p>其中需要注意的是<code>areaMask</code>值,该值表示的是成功被过滤的区域类型，对应界面里边的：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240604165246170.png" alt="image-20240604165246170"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//巡逻实现</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">       <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">       Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">       <span class="comment">//修改后：</span></span><br><span class="line">       NavMeshHit hit;</span><br><span class="line">       wayPoint = NavMesh.SamplePosition(randomPoint,<span class="keyword">out</span> hit,patrolRange,<span class="number">1</span>)?hit.position:transform.position;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中填入的值为1，这意味着能够通过筛选的只有索引为0(列表下标)的区域，也就是Walkable</p><p><a href="">该索引是不是可以理解成Areas下该列表的下标值？比如第一行就是索引0，第二行就是索引1？</a></p><p>最终参考代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnemyState</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//站桩、巡逻、追击、死亡</span></span><br><span class="line">    GUARD,PATROL,CHASE,DEAD</span><br><span class="line">&#125;</span><br><span class="line">[<span class="meta">RequireComponent(typeof(NavMeshAgent))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> NavMeshAgent agent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EnemyState enemyState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否为站桩怪</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGUARD;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Basic Settings&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//检测范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> sightRadius;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameObject attackTarget;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animator animator;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Walk;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Chase;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> Follow;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//巡逻点到达后停留时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lookAtTime;</span><br><span class="line">    <span class="comment">//准备下一个巡逻的计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> remainLookAtTime;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;Patrol State&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//巡逻范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> patrolRange;</span><br><span class="line">    <span class="keyword">private</span> Vector3 wayPoint;</span><br><span class="line">    <span class="comment">//初始点</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 guardPos;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        agent = GetComponent&lt;NavMeshAgent&gt;();</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">        speed = agent.speed;</span><br><span class="line">        guardPos = transform.position;</span><br><span class="line"></span><br><span class="line">        remainLookAtTime = lookAtTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isGUARD)</span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.GUARD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.PATROL;</span><br><span class="line">            GetNewWayPoint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SwithState();   </span><br><span class="line">        SwitchAnimator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchAnimator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Walk&quot;</span>, Walk);</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Chase&quot;</span>, Chase);</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Follow&quot;</span>, Follow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwithState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测附近是否有玩家</span></span><br><span class="line">        <span class="keyword">if</span>(FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            enemyState = EnemyState.CHASE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(enemyState)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.GUARD:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.PATROL:</span><br><span class="line">                Chase = <span class="literal">false</span>;</span><br><span class="line">                agent.speed = speed * <span class="number">0.5f</span>;</span><br><span class="line">                <span class="keyword">if</span> (Vector3.Distance(wayPoint,transform.position)&lt;=<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Walk = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span>(remainLookAtTime &gt; <span class="number">0</span>)</span><br><span class="line">                        remainLookAtTime -= Time.deltaTime;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        GetNewWayPoint();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Walk = <span class="literal">true</span>;</span><br><span class="line">                    agent.destination = wayPoint;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.CHASE:</span><br><span class="line">                changeToChase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EnemyState.DEAD:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> colliders = Physics.OverlapSphere(transform.position, sightRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> collider <span class="keyword">in</span> colliders)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(collider.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                attackTarget = collider.gameObject;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            attackTarget = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeToChase</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//追击player</span></span><br><span class="line">        <span class="comment">//在攻击范围内攻击</span></span><br><span class="line">        <span class="comment">//绑定动画</span></span><br><span class="line">        Walk = <span class="literal">false</span>;</span><br><span class="line">        Chase = <span class="literal">true</span>;</span><br><span class="line">        agent.speed = speed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//返回到上一个状态</span></span><br><span class="line">            Follow = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(remainLookAtTime &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                agent.destination = transform.position;</span><br><span class="line">                remainLookAtTime -= Time.deltaTime;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(isGUARD)</span><br><span class="line">            &#123;</span><br><span class="line">                enemyState = EnemyState.GUARD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                enemyState = EnemyState.PATROL;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Follow = <span class="literal">true</span>;</span><br><span class="line">            agent.destination = attackTarget.transform.position;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//巡逻实现</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetNewWayPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//重置计时器</span></span><br><span class="line">        remainLookAtTime = lookAtTime;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span> randomX = Random.Range(-patrolRange, patrolRange);</span><br><span class="line">        <span class="built_in">float</span> randomZ = Random.Range(-patrolRange, patrolRange);</span><br><span class="line"></span><br><span class="line">        Vector3 randomPoint = <span class="keyword">new</span> Vector3(guardPos.x + randomX, transform.position.y,guardPos.z + randomZ);</span><br><span class="line">        <span class="comment">//修改后：</span></span><br><span class="line">        NavMeshHit hit;</span><br><span class="line">        wayPoint = NavMesh.SamplePosition(randomPoint,<span class="keyword">out</span> hit,patrolRange,<span class="number">1</span>)?hit.position:transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = Color.yellow;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position, patrolRange);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3D项目初试（一）</title>
      <link href="/2024/06/01/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95/"/>
      <url>/2024/06/01/3D%E9%A1%B9%E7%9B%AE%E5%88%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="3D建模渲染管线"><a href="#3D建模渲染管线" class="headerlink" title="3D建模渲染管线"></a>3D建模渲染管线</h1><p>手动安装URP的话，通常要在安装完成URP包后进行以下创建：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609194321333.png" alt="image-20240609194321333"></p><p>同时还要在Unity编辑器下进行渲染管线内容的绑定：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609195953223.png" alt="image-20240609195953223"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240609200019263.png" alt="image-20240609200019263"></p><p>若素材因为渲染问题没有正确显示的情况下，要初始化或导入对应版本的渲染URP管线，然后在<code>Project Setting → Graphics 以及 Quality</code>下进行绑定对应的渲染URP</p><p>然后在如图的内容下进行使用，从而让建模重新被渲染</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601111222861.png" alt="image-20240601111222861"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601111426637.png" alt="image-20240601111426637"></p><p>具体的渲染内容，针对物品不同或内容不同可能需要进行不同的调整，该界面下如何使用到时候可以在遇到问题的情况下再去了解不同选择的作用，在对人物建模重新渲染这块，通过勾选<code>Material Upgrade</code>然后进行覆盖处理就能让人物建模重新显示出来了</p><h2 id="天空盒的使用与切换"><a href="#天空盒的使用与切换" class="headerlink" title="天空盒的使用与切换"></a>天空盒的使用与切换</h2><p>在<code>Window → Rendering → Lighting</code>打开可以让我们更改的页面</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601142753229.png" alt="image-20240601142753229"></p><p>在Environment选项下切换天空盒</p><p><strong>细节处理：</strong></p><p>调整阴影，通过减少渲染距离渲染阴影从而达成优化效果，节省资源开支，这部分需要切换到渲染管线位置来进行调整：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601143628824.png" alt="image-20240601143628824"></p><p>如果为了视角效果的逼真，通常阴影部分还可以添加多段层，从而来达到不同距离下看到的影子效果各不一样：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601143922397.png" alt="image-20240601143922397"></p><p>这块了解即可</p><h2 id="创建光线"><a href="#创建光线" class="headerlink" title="创建光线"></a>创建光线</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144533623.png" alt="image-20240601144533623"></p><p>以上选项对应的内容参考Unity文档手册即可</p><p>自己调整成需要的光线后点击<code>Generate Lighting</code>完成光线的编辑</p><p>接下来是环境光的设置，<strong>环境光源的类型可分为 天空盒、渐变和颜色</strong></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144917171.png" alt="image-20240601144917171"></p><p>其中天空盒是默认设置，其光源要比较自然；渐变则是一种环境光源，<strong>利用渐变来表现天空、空气、地面三种光源的颜色</strong>，可以创造出具有强烈冲击力的场景；色彩以单一颜色来表达环境光，因此可以创造出非常生动的印象</p><p>同时如果因为有天空盒，天空盒的存在也会影响环境光，导致照射的环境光的色彩不一样，这也可以进行调整，比如调整成默认的环境光，也支持自己调整对应颜色：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601144851658.png" alt="image-20240601144851658"></p><p>这部分环境光的内容也可以参考：<a href="https://styly.cc/tips/unity-lighting/">https://styly.cc/tips/unity-lighting/</a></p><p>详细讲解也可以参考：<a href="https://www.youtube.com/watch?v=VnG2gOKV9dw">https://www.youtube.com/watch?v=VnG2gOKV9dw</a></p><h2 id="一些3D快捷键使用技巧"><a href="#一些3D快捷键使用技巧" class="headerlink" title="一些3D快捷键使用技巧"></a>一些3D快捷键使用技巧</h2><p>第一个是物品的摆放，一般情况下场景地图不是平坦的而是凹凸的，当我们新创建一个物品或者拖拽一个预制体进行摆放的时候，很难准确地把物品完整地与当前摆放角度摆放界面放置完整下去，这时候就可以通过**<code>V</code>键**来通过顶点快捷置入当前鼠标对应的地面</p><p>需要注意的是，该快捷键的摆放遇到凹凸不平，崎岖位置进行摆放，可能会因为顶点的偏移导致很难精准地放置到我们想要放到的斜面位置上</p><p>不过也可以通过<code>ctrl ＋ shift</code>拖动物体来与放置的位置进行缝合</p><p>第二个就是摄像机地快捷设置，在3D搭建场景里边，为了让Game窗口能够在一个比较符合我们的角度上进行摆放，通常可以在Scene先切换到一个合适地视角里，然后通过选中相机，快捷键<code>Ctrl+shift＋f</code>进行设置，这样相机的视角就是我们当前Scene下的视角了</p><h1 id="地图场景"><a href="#地图场景" class="headerlink" title="地图场景"></a>地图场景</h1><h2 id="场景快速搭建-polybrush"><a href="#场景快速搭建-polybrush" class="headerlink" title="场景快速搭建(polybrush)"></a>场景快速搭建(polybrush)</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601201010428.png" alt="image-20240601201010428"></p><p>导入成功后就可以看到多了一个Tool选项，选择PloyBrush即可打开对应的窗口，通过在窗口中进行场景编辑</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601203517685.png" alt="image-20240601203517685"></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602173000978.png" alt="image-20240602173000978"></p><p>通常可以直接<img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602173031063.png" alt="image-20240602173031063">基于这两个右键Material创建出对应的材质球，这样就可以继续通过Polybrush工具进行绘制了</p><p>polybrush提供了五个小功能，这些功能可以快速进行场景的搭建，具体的运用可以参考：<a href="https://blog.csdn.net/qq_57250692/article/details/132864343">https://blog.csdn.net/qq_57250692/article/details/132864343</a></p><p><a href="https://blog.csdn.net/weixin_50114337/article/details/128314370">https://blog.csdn.net/weixin_50114337/article/details/128314370</a></p><h2 id="场景地图扩大-probuilder"><a href="#场景地图扩大-probuilder" class="headerlink" title="场景地图扩大(probuilder)"></a>场景地图扩大(probuilder)</h2><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601204630548.png" alt="image-20240601204630548"></p><p>导入成功后也在Tool下启动ProBuilder的编辑页面，通过probuilder窗口来进行场景制作</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240601212525838.png" alt="image-20240601212525838"></p><p>通常是左键选择对应的内容，然后再左边的Shape Tool下选择模板，同时可以调整该场景(物体)的大小以及网格数量(1*1)</p><p>如果需要细微调动地图位置移动可以了解下<code>ProGrids</code></p><p>然后是地图(一般是用Plane图形)创建好要为其加上颜色，相当于陆地颜色，则要创建一个<code>Material</code>的材质球，然后把材质球拖动过去，进行自定义调色即可</p><p>最后是基础地形场景构建可以参考学习的内容：<a href="https://blog.csdn.net/WGYHAPPY/article/details/117851090">https://blog.csdn.net/WGYHAPPY/article/details/117851090</a></p><h1 id="地图烘焙"><a href="#地图烘焙" class="headerlink" title="地图烘焙"></a>地图烘焙</h1><p>首先还是要先下载对应的插件<code>AI Navigation</code>，然后便可以在<code>Window → AI → Navigation</code>打开对应的窗口</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602194856863.png" alt="image-20240602194856863"></p><p>该圆柱就是表示人物的大小与宽展，以及能够爬坡的角度等，然后是对当前主场景或者说主地形进行设置，让其选为可行区域(Walkable)或者不可行区域(Not Walkable)</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602195430995.png" alt="image-20240602195430995"></p><p>然后通过在<code>Bake</code>选项下进行设置应用</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602195739356.png" alt="image-20240602195739356"></p><p>这样就能在场景里看到哪部分区域是可行区域或者不可行区域了(有浅蓝色覆盖就是可行区域)，然后也要对场景里的一些物体，比如树木、巨石、城楼等实际物体的Navigation也进行调整，原理也和上边的操作一样，设置区域完成后也要记得按<code>Bake</code>进行运用，最后可以观察到：</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602200316196.png" alt="image-20240602200316196"></p><p><strong>PS：</strong>该方法主要是用来设置地图场景<strong>默认本身就不能移动的物体</strong>，所以通过Navigation里边直接设置可以更加方便，但是如果我们只要让单个物品设置为障碍物不能被经过呢？</p><p>这时候可以为单独的物体添加一个障碍物的组件<strong>Nav Mesh Obstacle</strong>，通过这种方式设置的障碍物&#x2F;碰撞体本身可以允许被移动，其移动的时候不可行区域也会跟着移动</p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602201745481.png" alt="image-20240602201745481"></p><p>以上两种方式分别对应了场景物体里边静态&#x2F;不可移动以及动态&#x2F;可被移动的设置，当前者物体被移动的时候，其不可行区域依然保持不变，而后者则可以跟着物体被移动</p><p>诸如此类下显示的绿色范围就是不可行区域的范围大小了，而由于默认范围大小没有调整，就是按照人物的宽展来的，所以还要对人物的宽展与大小进行设置：</p><p>为人物添加一个新的组件<strong>Nav Mesh Agent</strong></p><p><img src="/./../images/3D%E5%88%9D%E8%AF%95/image-20240602200742269.png" alt="image-20240602200742269"></p><p>同时在调整完成后还要对Navigation对应的Bake数值上也进行更改，其大小与宽展也要同人物该组件绑定的数值保持一致！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串篇</title>
      <link href="/2024/05/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/"/>
      <url>/2024/05/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串的基本操作"><a href="#字符串的基本操作" class="headerlink" title="字符串的基本操作"></a>字符串的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串输入</span></span><br><span class="line"><span class="comment">/*string str1;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; str1;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*string str2;</span></span><br><span class="line"><span class="comment">getline(cin, str2);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容量操作</span></span><br><span class="line"><span class="comment">/*cout &lt;&lt; str2.size();</span></span><br><span class="line"><span class="comment">str2.clear();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2.size();*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*cout &lt;&lt; str2.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">str2.resize(10);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2.size() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; str2 &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 将s中有效字符个数增加到10个，多出位置用&#x27;a&#x27;进行填充</span></span><br><span class="line"><span class="comment">// “aaaaaaaaaa”</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将s中有效字符个数增加到15个，多出位置用缺省值&#x27;\0&#x27;进行填充</span></span><br><span class="line"><span class="comment">// &quot;aaaaaaaaaa\0\0\0\0\0&quot;</span></span><br><span class="line"><span class="comment">// 注意此时s中有效字符个数已经增加到15个</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">15</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 将s中有效字符个数缩小到5个</span></span><br><span class="line">s.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;测试 reverse&quot;</span> &lt;&lt; endl;</span><br><span class="line">s.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试reserve参数小于string的底层空间大小时，是否会将空间缩小</span></span><br><span class="line">s.<span class="built_in">reserve</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：reserve()一般和插入、operator+=配合     它只是扩充容量，size仍为原大小。</span></span><br><span class="line"><span class="comment">//resize()一般operator[]配合。                  它既扩容，又改变了size值，这样就可以通过[]访问。</span></span><br></pre></td></tr></table></figure><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string/description/">https://leetcode.cn/problems/reverse-string/description/</a></p><h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-string-ii/description/">https://leetcode.cn/problems/reverse-string-ii/description/</a></p><h2 id="反转字符串里的单词"><a href="#反转字符串里的单词" class="headerlink" title="反转字符串里的单词*"></a>反转字符串里的单词*</h2><p>题目链接：<a href="https://leetcode.cn/problems/reverse-words-in-a-string/description/">https://leetcode.cn/problems/reverse-words-in-a-string/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapString</span><span class="params">(string&amp; s, <span class="type">int</span> front, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=front,j=end; i &lt; j; i++, j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(s[i], s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去掉字符串开头的空格</span></span><br><span class="line">        <span class="keyword">while</span> (fast &lt; s.<span class="built_in">size</span>()&amp;&amp;s.<span class="built_in">size</span>()&gt;<span class="number">0</span>&amp;&amp;s[fast] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//去掉字符串中间多余的空格，只留下一个空格</span></span><br><span class="line">        <span class="keyword">for</span> (; fast &lt; s.<span class="built_in">size</span>(); fast++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[fast] == s[fast - <span class="number">1</span>] &amp;&amp; s[fast] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            s[slow++] = s[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slow - <span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; s[slow - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123; <span class="comment">// 去掉字符串末尾的空格</span></span><br><span class="line">            s.<span class="built_in">resize</span>(slow - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.<span class="built_in">resize</span>(slow); <span class="comment">// 重新设置字符串大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swapString</span>(s, <span class="number">0</span>, s.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>||i==s.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swapString</span>(s, start, i<span class="number">-1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>next数组的设计：</p><ul><li>初始化</li><li>前后缀不相同</li><li>前后缀相同</li><li>next更新</li></ul><h3 id="实现strStr"><a href="#实现strStr" class="headerlink" title="实现strStr"></a>实现strStr</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="img"></p><h2 id="解题五部曲"><a href="#解题五部曲" class="headerlink" title="解题五部曲"></a>解题五部曲</h2><ul><li><strong>dp数组以及下标含义</strong></li><li><strong>递推公式</strong></li><li><strong>dp数组初始化</strong></li><li><strong>遍历顺序</strong></li><li><strong>打印数组</strong></li></ul><h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>题目：<a href="https://leetcode.cn/problems/fibonacci-number/">https://leetcode.cn/problems/fibonacci-number/</a></p><p>解题思路：</p><p>先进行五部曲分析：</p><p>1、dp数组以及下标含义——dp[i] 第i个斐波那契的dp[i]</p><p>2、递推公式</p><p>本题的斐波那契数本身的公式就是一个递推公式，即</p><p>dp[i] &#x3D; dp[i-1]+dp[i-2]</p><p>3、dp数组初始化</p><p>由于斐波那契数列本身的特性，相当于只有第一个和第二个是1，其他都是公式推算</p><p>4、遍历顺序</p><p>从前到后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">50</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>题目：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：第i阶楼梯总共有dp[i]种方式到达</p><p>2、递推公式</p><p>第一阶楼梯：1种</p><p>第二阶楼梯：2种</p><p>第三阶楼梯：3种</p><p>第四阶楼梯：5种</p><p>…</p><p>根据实际推算，以每次可以爬1-2个台阶的方式可以得出：</p><p>dp[i] &#x3D; dp[i-1]+dp[i-2]</p><p>3、dp数组初始化</p><p>这里要注意特殊情况0阶，第0阶楼梯默认1种</p><p>dp[0] &#x3D; 1，dp[1] &#x3D; 1</p><p>其他遵循递推公式</p><p>4、遍历顺序</p><p>从前往后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>, dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p>题目：<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：第i阶楼梯所需要的<strong>最小</strong>花费dp[i]</p><p>2、递推公式</p><p>cost[i]是i阶楼梯跳跃所需要的花费，i则是表示第i阶的楼梯</p><p>则当从第1阶楼梯进行跳跃，可以通过支付cost[1]来实现</p><p>当从第2阶楼梯进行跳跃，可以通过支付cost[2]来实现</p><p>如果要跳跃到第三阶，则有以下可能：</p><p>从第一阶楼梯支付，跳跃两层：dp[3] &#x3D; dp[1] + cost[1]</p><p>从第二阶楼梯支付，跳跃一层：dp[3] &#x3D; dp[2] + cost[2]</p><p>其中dp[1]表示到达第一阶已经花费的数量，dp[2]表示到达第二阶已经花费的数量</p><p>综上所述，可以得到递推公式为：</p><p>dp[i] &#x3D; min( (dp[i-1]+cost[i-1])，(dp[i-2]+cost[i-2]))</p><p>3、dp数组初始化</p><p>由于题目需求是可以选择从第0阶或者第1阶开始爬，所以：</p><p>dp[0] &#x3D; 0，dp[1] &#x3D; 0</p><p>4、遍历顺序</p><p>从前往后</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> dp[<span class="number">1005</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>, dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cost.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           dp[i] = <span class="built_in">min</span>((dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]), (dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>]));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[cost.<span class="built_in">size</span>()];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i ] [0]：持有股最大值</p><p>dp[i ] [1]：无持股最大值</p><p>2、递推公式</p><p>由于dp[i ] [0]表示持有股所得现金最大值，所以dp[i ] [0]最大值是在两种情况下取：</p><p>第一种情况：dp[i-1] [0]也就是之前就买入股的现金</p><p>第二种情况：- prices[i]也就是刚买入股的现金</p><p>由于dp[i ] [1]表示无持股所得现金最大值，所以dp[i ] [1]最大值是在两种情况下取：</p><p>第一种情况：dp[i-1] [1]也就是之前已经把股票售出(所以是无持股)的现金</p><p>第二种情况：dp[i ] [0]+prices[i]也就是刚售出股的现金</p><p>综上所述，递推公式即：</p><p><strong>dp[i] [1] &#x3D; max(dp[i-1] [1]，dp[i ] [0]+prices[i])</strong></p><p><strong>其中，dp[i ] [0] &#x3D; max(dp[i-1] [0]，-prices[i])</strong></p><p>3、初始化</p><p>由递推公式可知，初始要从dp[0 ] [0]，dp[0 ] [1]开始，所以初始化为：</p><p><strong>dp[0 ] [0] &#x3D; -prices[0]</strong> ， 由于dp[0 ] [0]表示持有股且它为首位，所以只能取第一天就买入股消费的现金，因为只有这样才满足我们对dp[i] [0]的定义！</p><p><strong>dp[0 ] [1] &#x3D; 0</strong>，由于dp[0 ] [1]表示无持股且它为首位，所以取第一天没买入股，也就是0</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机II"><a href="#买卖股票的最佳时机II" class="headerlink" title="买卖股票的最佳时机II"></a>买卖股票的最佳时机II</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>解题思路：</p><p>1、dp数组与I相同</p><p>2、递推公式</p><p>dp[i ] [1]表示未持有股状态，也就是之前售出或者刚售出，所以</p><p>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i] [0]+prices[i])，同I相比无变化</p><p>dp[i ] [0]表示持有股状态，也就是之前入股或者刚入股，而由于该题表示可以多次买卖股，只要当天只持有一股就行，相当于可能之前就已经售出过，处于无持股但是已经有了现金的状态，也就是dp[i-1] [1]，所以</p><p>dp[i ] [0] &#x3D; max(dp[i-1 ] [0]，dp[i-1] [1] - prices[i])，同I相比变化了</p><p>所以综上所述，递推公式为：</p><p><strong>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i] [0]+prices[i])</strong></p><p>其中，<strong>dp[i ] [0] &#x3D; max(dp[i-1 ] [0]，dp[i-1] [1] - prices[i])</strong></p><p>3、初始化与I相同</p><p>4、</p><p>5、</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(len, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//持有股的最大现金</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line"><span class="comment">//无持股的最大现金</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机III"><a href="#买卖股票的最佳时机III" class="headerlink" title="买卖股票的最佳时机III"></a>买卖股票的最佳时机III</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>由于该题为至多两次买卖股票，所以dp数组用二维来方便记录如下情况：</p><p>dp[i] [0] ：不操作时现金</p><p>dp[i] [1]：第一次持有股票的最大现金</p><p>dp[i] [2]：第一次无持股的最大现金</p><p>dp[i] [3]：第二次持有股票的最大现金</p><p>dp[i] [4]：第二次无持股的最大现金</p><p>2、递推公式</p><p>dp[i] [0]：若不进行任何操作，则dp[i] [0] &#x3D; 0</p><p>dp[i] [1]为第一次持有股票的最大现金，所以有两种可能：</p><p>第一种为之前就已经第一次持有股票dp[i-1] [1]，</p><p>第二种为这次刚买入第一次股票dp[i-1] [0] - prices[i]</p><p>则<strong>dp[i ] [1] &#x3D; max(dp[i-1] [1]，dp[i-1] [0] - prices[i])</strong></p><p>dp[i] [2]为第一次无持股的最大现金，所以有两种可能：</p><p>第一种为之前就已经把第一次股票出售出去，dp[i-1] [2]，</p><p>第二种为这次刚把第一次买入的股票出售出去，dp[i-1] [1] + prices[i]</p><p><strong>dp[i] [2] &#x3D; max(dp[i-1] [2]，dp[i-1] [1] + prices[i])</strong></p><p>dp[i] [3]为第二次持有股票的最大现金，所以有两种可能：</p><p>第一种为之前就已经第二次持有股票dp[i-1] [3]，</p><p>第二种为刚买入第二次股票dp[i-1] [2] - prices[i]</p><p><strong>dp[i] [3] &#x3D; max(dp[i-1] [3]，dp[i-1] [2] - prices[i])</strong></p><p>dp[i] [4]为第二次无持股的最大现金，所以有两种可能：</p><p>第一种为之前就已经第二次无持股dp[i-1] [4]，</p><p>第二种为刚把第二次股票售出去，dp[i-1] [3] + prices[i]</p><p><strong>dp[i] [4] &#x3D; max(dp[i-1] [4]，dp[i-1] [3] + prices[i])</strong></p><p>3、初始化</p><p>dp[0] [0]：无操作，dp[0] [0] &#x3D; 0</p><p>dp[0] [1]为第一次持有股，即dp[0] [1] &#x3D; -prices[0]</p><p>dp[0] [2]为第一次不持有股，即dp[0] [1] &#x3D; 0</p><p>dp[0] [3]为第二次持有股，即dp[0] [2] &#x3D; -prices[0]</p><p>dp[0] [4]为第二次不持有股，即dp[0] [4] &#x3D; 0</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机IV"><a href="#买卖股票的最佳时机IV" class="headerlink" title="买卖股票的最佳时机IV"></a>买卖股票的最佳时机IV</h2><p>题目：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/</a></p><p>解题思路：</p><p>同买卖股票的最佳时机III，要注意</p><p>dp[0] [0]表示的是不操作</p><p>这样才可以方便后续以每次+2的情况下去推到 第x次持有股票以及第x次不持有股票的状态</p><h2 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h2><p>题目：<a href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[ i] [j]：从起点到达<strong>第i行第j列</strong>共有dp[ i] [j]种方式</p><p>2、递推公式</p><p>通过画图可以清晰地发现</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png" alt="62.不同路径1"></p><p>相当于每个格子的到达方式是由它<strong>上一个格子向下走</strong>，<strong>左一个格子向右走</strong>得到的，所以能够得到对应的推导公式为：</p><p>dp[ i] [j] &#x3D; dp[ i-1] [j] + dp[ i] [j-1]</p><p>3、初始化</p><p>由于dp数组的含义可以知道，当起始点到同行右边任何点位的方式只有一种（只能向右走到达），起始点到同列下边任何点位的方式也只有一种（只能向下走到达），所以初始化为：</p><p>遍历第一行右边(dp[ 0] [j])都为1，只有一种方式能到达</p><p>遍历第一列下边(dp[ i] [0])都为1，只有一种方式能到达</p><p>4、遍历方式</p><p>从左到右，从上到下</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> dp[<span class="number">105</span>][<span class="number">105</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">       <span class="comment">//初始化</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">           dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">           dp[j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//递推公式</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">               dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p>题目：<a href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p><p>解题思路：</p><p>1、dp数组以及下标的含义</p><p>dp[i]：小偷在第i个房间内能够取得的最高金额dp[i]</p><p>2、递推公式</p><p>由题目可以推测，假设以第三间房间来算小偷的最高金额，则有以下两种情况：</p><p>第一种，小偷进入第一间房间偷取金额dp[0]，间隔一间后偷取本间房间的金额nums[2]</p><p>第二种，小偷进入第二间房间偷取金额dp[1]，第三间为间隔所以无法偷取</p><p>所以第三间的金额计算就是 max(dp[0]，(dp[1]+nums[2]))</p><p>再以第四间房间来算，则两种情况分别是第三间的最高金额dp[2]与第二间的最高金额dp[1]加上相隔一间后本间金额nums[3]</p><p>综上所述，可以得到递推公式为：</p><p><strong>dp[i] &#x3D; max(dp[i-1]，(dp[i-2]+nums[i]))</strong></p><p>3、初始化</p><p>由于dp数组的意义，所以第一间房间金额必然是dp[0] &#x3D; nums[0]</p><p>而第二间房间比较特殊，由于递推公式需要有i-2，如果直接代入公式会导致数组下标为负数，不合法，结合题目情况，有：</p><p>dp[1] &#x3D; max(dp[0],nums[1])</p><p>4、遍历顺序</p><p>从左到右</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">105</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">1</span>)</span><br><span class="line">dp[<span class="number">1</span>] = <span class="built_in">max</span>(dp[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; nums.<span class="built_in">size</span>();i++) </span><br><span class="line">&#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], (dp[i - <span class="number">2</span>] + nums[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍IV"><a href="#打家劫舍IV" class="headerlink" title="打家劫舍IV ()"></a>打家劫舍IV ()</h2><p>题目：</p><p>解题思路：</p><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>题目：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i]：以<strong>nums[i]为尾</strong>的最长递增子序列的长度</p><p>2、递推公式</p><p>以nums &#x3D; [10,9,2,5,3,7,101,18]为例</p><p>当i &#x3D; 1时，dp[i] 表示以 nums[1]为尾的最长递增子序列[9]，dp[1] &#x3D; 1</p><p>当i &#x3D; 2时，dp[i] 表示以nums[2]为尾的最长递增子序列[2]，dp[2] &#x3D; 1</p><p>当i &#x3D; 3时，dp[i] 表示以nums[3]为尾的最长递增子序列[2，5]，dp[3] &#x3D; 2</p><p>…</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j])时，必有 dp[i] &#x3D; max(dp[i], dp[j] + 1)</p><p>综上可以知道，递推公式为：</p><p>dp[i] &#x3D; max(dp[i]，dp[j]+1); （其中j ∈ [0，i-1]）</p><p>3、初始化</p><p>由于dp数组的含义，<strong>每一个i对应的dp[i]（即最长递增子序列）起始大小至少都是1</strong></p><p>4、遍历顺序</p><p>dp[i]：从左到右</p><p>dp[j]：任意</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; res) res = dp[i]; </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><p>题目：<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">https://leetcode.cn/problems/maximum-length-of-repeated-subarray/</a></p><p>解题思路：</p><p>1、dp数组以及下标含义</p><p>dp[i] [j]：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i] [j]</p><p>2、递推公式</p><p>根据dp[i][j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>3、初始化</p><p>根据dp[i] [j]的定义，dp[i] [0] 和dp[0] [j]其实都是没有意义的！</p><p>但dp[i] [0] 和dp[0] [j]要初始值，因为 为了方便递归公式dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1;</p><p>所以dp[i] [0] 和dp[0] [j]初始化为0</p><p>拿示例1中，A: [1,2,3,2,1]，B: [3,2,1,4,7]为例，画一个dp数组的状态变化，如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021011215282060.jpg" alt="718.最长重复子数组"></p><p>4、遍历顺序</p><p>外层for循环遍历A，内层for循环遍历B</p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">       vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                   dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>题目：<a href="https://leetcode.cn/problems/longest-common-subsequence/">https://leetcode.cn/problems/longest-common-subsequence/</a></p><p>这里要理解一个核心的点就是<strong>删除</strong></p><p>解题思路：</p><p>1、dp数组以及下标意义</p><p>dp[i] [j]：长度为[0, i - 1]的字符串A与长度为[0, j - 1]的字符串B的<strong>最长公共子序列长度</strong>为dp[i] [j]</p><p>2、递推公式</p><p>主要就是两大情况： A[i - 1] 与 B[j - 1]相同，A[i - 1] 与 B[j - 1]不相同</p><p>如果A[i - 1] 与 B[j - 1]相同，则<strong>dp[i] [j] &#x3D; dp[i - 1] [j - 1] + 1</strong>;</p><p>如果A[i - 1] 与 B[j - 1]不相同，那就看看A[0, i - 2]与B[0, j - 1]的最长公共子序列 和 A[0, i - 1]与B[0, j - 2]的最长公共子序列，取最大的</p><p>即：<strong>dp[i] [j] &#x3D; max(dp[i - 1] [j], dp[i] [j - 1])</strong>;</p><p>3、初始化</p><p>统一初始为0</p><p>4、遍历顺序</p><p>从前向后，从上到下来遍历</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210204115139616.jpg" alt="1143.最长公共子序列"></p><p>5、打印输出</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(text2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) </span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br></pre></td></tr></table></figure><p>同时另外一道题也一样：<a href="https://leetcode.cn/problems/uncrossed-lines/description/">https://leetcode.cn/problems/uncrossed-lines/description/</a></p><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), INT_MIN)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxx = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (maxx &lt; dp[i])</span><br><span class="line">                maxx = dp[i];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/is-subsequence/">https://leetcode.cn/problems/is-subsequence/</a></p><p>这里也是要理解<strong>删除</strong>的操作</p><h3 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a>不同的子序列</h3><p>题目链接：<a href="https://leetcode.cn/problems/distinct-subsequences/description/">https://leetcode.cn/problems/distinct-subsequences/description/</a></p><p>这里也是要理解核心是<strong>删除</strong></p><p>该题有点难理解，可以看下：<a href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p><h3 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h3><p>题目链接：<a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">https://leetcode.cn/problems/delete-operation-for-two-strings/</a></p><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>题目链接：<a href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p><p>该题要注意一个思考的点：</p><p>虽然本题的操作有添加操作，但实际上<strong>添加的操作 ＝ 删除的操作</strong></p><p>举例： word1 &#x3D; a， word2 &#x3D; ab</p><p>那么word2删除一个元素 b 就相当于 word1添加一个元素 b这两者的最少步数都是一样的！</p><p>所以实际上求最小值的时候，只要是两个字符串各自的删除就可以表示出来删除和添加这两个操作了</p><h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>01背包理论基础详情见：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html</a></p><p>01背包对应的题型各不相同，只是本质上都可以转化为背包问题</p><h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><p>题目链接：<a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">https://leetcode.cn/problems/partition-equal-subset-sum/description/</a></p><p>分割等和子集对应的背包问题相当于：<strong>给我们一个容器，问我们能否装满这个容器</strong></p><p>分析：</p><ul><li>背包的体积为sum &#x2F; 2</li><li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li><li>背包如果正好装满，说明找到了总和为 sum &#x2F; 2 的子集</li><li><strong>背包中每一个元素是不可重复放入</strong>（01背包的前提）</li></ul><p>动规五部曲：</p><ol><li><p><strong>确定dp数组的下标以及含义</strong></p><p>dp[j] 表示装满重量为j的背包 能够放入的最大重量（最大价值）dp[j]  （本题里边每一个元素的值既是重量也是价值）</p><p>所以当dp[target] &#x3D; target  ，也就是<strong>装满</strong>重量为目标值target的背包所能放入的最大重量就等于目标值target的时候，返回true，反之false</p><p>也有装不满的情况：  [1,5,3,7]        dp[7]意味着没有装满的情况，因为此时dp[7]的最大重量只能是6，但是dp[6]则表示可以装满</p></li><li><p><strong>递推公式</strong></p></li></ol><p>​dp[j] &#x3D; max(dp[j], dp[j-nums[i]] + nums[i] )   也就是01背包的式子</p><ol start="3"><li><p>初始化</p><p>从dp[j]的定义来看，首先dp[0]一定是0。</p><p>如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。</p><p><strong>这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了</strong>。</p><p>本题题目中 只包含正整数的非空数组，所以非0下标的元素初始化为0就可以了</p></li><li><p>确定遍历顺序</p><p>采用滚动一维数组的dp数组，所以按照先遍历物品数量再遍历物品重量的顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始 01背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = target; j &gt;= nums[i]; j--) &#123; <span class="comment">// 每一个元素一定是不可重复放入，所以从大到小遍历</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>物品重量的遍历为什么要倒序可以参考讲解：<a href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE</a></p><ol start="5"><li>举例推导dp数组</li></ol></li></ol><p>最后进行代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//容量为j的背包最大能装满dp[j]</span></span><br><span class="line">        <span class="type">int</span> dp[<span class="number">10010</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= nums[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; nums[i])</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[target] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最后一块石头的重量II"><a href="#最后一块石头的重量II" class="headerlink" title="最后一块石头的重量II"></a>最后一块石头的重量II</h3><p>题目链接：<a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">https://leetcode.cn/problems/last-stone-weight-ii/description/</a></p><p>最后一块石头的重量II对应的背包问题相当于：<strong>给我们一个容量的背包，它最多能够装多少</strong></p><p>该题本质上就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小</p><p>动规五部曲：</p><ol><li><strong>确定dp数组以及下标的含义</strong></li></ol><p>​**dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。</p><p>​可以回忆一下01背包中，dp[j]的含义，容量为j的背包，最多可以装的价值为 dp[j]。</p><p>​相对于 01背包，本题中，石头的重量是 stones[i]，石头的价值也是 stones[i] ，所以 “最多可以装的价值为 dp[j]” &#x3D;&#x3D; “最多可以背的重量为dp[j]”</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​依旧是：<strong>dp[j] &#x3D; max(dp[j], dp[j - stones[i]] + stones[i]);</strong></p><ol start="3"><li><strong>dp数组如何初始化</strong></li></ol><p>​既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和</p><p>​因为提示中给出1 &lt;&#x3D; stones.length &lt;&#x3D; 30，1 &lt;&#x3D; stones[i] &lt;&#x3D; 1000，所以最大重量就是30 * 1000 </p><p>​而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了</p><p>​接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了</p><ol start="4"><li><p><strong>确定遍历顺序</strong></p><p>同分割等和子集一致</p></li><li><p>举例推导dp数组</p></li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += stones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">15000</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">//dp[j] 容量为j的背包 最大装满(类似 最大价值)为dp[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; stones.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; target &gt;= stones[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; stones[i])</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum1 = sum - dp[target];<span class="comment">//第二堆物品</span></span><br><span class="line">        res = sum1 - dp[target];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h3><p>题目链接：<a href="https://leetcode.cn/problems/target-sum/description/">https://leetcode.cn/problems/target-sum/description/</a></p><p>目标和对应的背包问题相当于：<strong>给我们一个容器，问装满这个容器有多少种方法</strong></p><p>分析：</p><p>把集合分为两个子集，一个代表正数集left，一个代表负数集right，那么有：<br>left + right &#x3D; sum  (总和)         </p><p>PS：right虽然表示负数集合，但是意思是该里边的数值之和带上负号才是负数，所以此时可以先计算总和(相当于取绝对值)</p><p>题目意思可以表示为：<br>left - right &#x3D; target（目标值）<br>综上可以得到式子：<br>left &#x3D; (target + sum) &#x2F; 2      其中target和sum都是已知的值，所以可以求得left</p><p>此时问题就转化为<strong>在集合nums中找出和为left的组合</strong></p><p>动规五部曲：</p><ol><li><strong>确定dp数组以及下标的含义</strong></li></ol><p>​dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p><p>​其实也可以使用二维dp数组来求解本题，dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​有哪些来源可以推出dp[j]呢？</p><p>​只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法</p><p>​例如：dp[j]，j 为5</p><ul><li><p>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</p></li><li><p>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</p></li><li><p>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</p></li><li><p>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</p></li><li><p>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</p><pre><code>相当于，如果要装满容量为1的背包，则有dp[1]种方法实现，此时装满容量1的背包的方法就是dp[1]</code></pre></li></ul><p>​  如果要装满容量为2的背包，则有dp[2]种方法实现，……而要装满容量5的背包，它对应的可以装满的方法就有：</p><p>​  dp[j - nums[i]]累加起来的结果，如何理解？</p><p>​ 比如dp[5-nums[i]]，如果nums[i]为3，那么就相当于dp[5-3]是要达到目标值5的其中一种方法之一，这意味着dp[2]有多少种方法可以       达到dp[5]</p><p>所以求组合类问题的公式，都是类似这种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] += dp[j - nums[i]]</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>dp数组如何初始化</strong></li></ol><p>​从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0</p><ol start="4"><li><p>确定遍历顺序</p><p>同上边两个背包问题一致</p></li><li><p>举例推导dp数组</p></li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(target) &gt; sum)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(left+<span class="number">1</span>,<span class="number">0</span>)</span></span>; <span class="comment">//dp[j] 表示装满容量j的背包 有dp[j]种方式</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &gt;= nums[i]; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//递推公式</span></span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[left];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><p>题目链接：<a href="https://leetcode.cn/problems/ones-and-zeroes/description/">https://leetcode.cn/problems/ones-and-zeroes/description/</a></p><p>一和零对应的背包问题就是：<strong>装满这个背包最多有多少个物品</strong></p><p>分析：</p><p><strong>m 和 n相当于是一个背包，两个维度的背包</strong></p><ol><li><strong>确定dp数组（dp table）以及下标的含义</strong></li></ol><p>​dp[i] [j]：最多有<strong>i个0</strong>和<strong>j个1</strong>的strs的最大子集的<strong>大小为dp[i] [j]</strong>  （这样就把三个变量都囊括下去了）</p><ol start="2"><li><strong>确定递推公式</strong></li></ol><p>​dp[i] [j] 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1(也就是dp[i-x] [j-y]    x表示当前子集0的个数，y表示当前子集1的个数)</p><p>​所以可以推出递推公式：</p><p>​<strong>dp[i] [j] &#x3D; max(dp[i] [j], dp[i-x] [j-y] + 1)</strong>;</p><ol start="3"><li><strong>dp数组初始化</strong></li></ol><p>​因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖</p><ol start="4"><li>遍历顺序</li></ol><p>​外层for循环遍历物品，内层for循环遍历背包容量且从后向前遍历！</p><p>​物品就是strs里的字符串，背包容量就是题目描述中的m和n</p><p>​所以顺序就为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (string str : strs) <span class="comment">//物品数量</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    <span class="comment">//背包容量   两个维度(顺序颠倒也没问题)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= x; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= y; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>举例推导dp数组</li></ol><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">605</span>][<span class="number">605</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (string str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> s : str)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    x++;</span><br><span class="line">                <span class="keyword">if</span> (s == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    y++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= x; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= y; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - x][j - y] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p><strong>每件物品都有无限个（也就是同个物品可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p>完全背包与01背包在动规五部曲的唯一区别就是遍历顺序的不同，01背包的遍历顺序是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而完全背包的遍历顺序是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; weight.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者区别： 01背包是倒序遍历背包容量，而完全背包是正序遍历背包容量；同时完全背包的双层循环可以互相转换，而01背包不能</p><p>举例推导dp数组来了解为什么正序和倒序会导致物品复用</p><p>01倒序:</p><p><img src="/./../../../typora-images/20210110103614769-1716344111006-1.png" alt="动态规划-背包问题9"></p><p>完全正序：</p><p><img src="/./../../../typora-images/20210126104510106-1716344123969-3.jpg" alt="动态规划-完全背包"></p><h3 id="零钱兑换II"><a href="#零钱兑换II" class="headerlink" title="零钱兑换II"></a>零钱兑换II</h3><p>题目链接：<a href="https://leetcode.cn/problems/coin-change-ii/description/">https://leetcode.cn/problems/coin-change-ii/description/</a></p><p>分析：本质上和 目标和  题目一样，相当于求装满该容量的背包有多少种方式</p><p>动规五部曲也同目标和一致，由于是完全背包问题，所以遍历顺序有区别，同时又因为该题目跟顺序有要求，所以不能像纯完全背包问题一样可以让两层循环随意颠倒</p><p>这时候区别在于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设：coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p><p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p><p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p><p>如果把两个for交换顺序，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p><p><strong>此时dp[j]里算出来的就是排列数！</strong></p><p>最后代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">5005</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// dp[j]表示填满j容量的背包有dp[j]种方法</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合总和IV"><a href="#组合总和IV" class="headerlink" title="组合总和IV"></a>组合总和IV</h3><p>题目链接：<a href="https://leetcode.cn/problems/combination-sum-iv/description/">https://leetcode.cn/problems/combination-sum-iv/description/</a></p><p>该题与上一题极其相似，区别只在于遍历顺序，上一题也提到了：</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong> （先物品再背包）</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。（先背包再物品）</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h2 id="背包问题总结"><a href="#背包问题总结" class="headerlink" title="背包问题总结"></a>背包问题总结</h2><h2 id="背包递推公式"><a href="#背包递推公式" class="headerlink" title="背包递推公式"></a>背包递推公式</h2><p>问<strong>能否能装满背包</strong>（或者最多装多少）：<strong>dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html">动态规划：416.分割等和子集(opens new window)</a></li><li><a href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html">动态规划：1049.最后一块石头的重量 II(opens new window)</a></li></ul><p>问<strong>装满背包有几种方法</strong>：<strong>dp[j] +&#x3D; dp[j - nums[i]]</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html">动态规划：494.目标和(opens new window)</a></li><li><a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html">动态规划：518. 零钱兑换 II(opens new window)</a></li><li><a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html">动态规划：377.组合总和Ⅳ(opens new window)</a></li><li><a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html">动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)</a></li></ul><p>问<strong>背包装满最大价值</strong>：<strong>dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</strong> ，对应题目如下：</p><ul><li><a href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html">动态规划：474.一和零(opens new window)</a></li></ul><p>问<strong>装满背包所有物品的最小个数</strong>：<strong>dp[j] &#x3D; min(dp[j - coins[i]] + 1, dp[j]);</strong> ，对应题目如下：</p><ul><li><p><a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html">动态规划：322.零钱兑换</a></p></li><li><p><a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html">动态规划：279.完全平方数(opens new window)</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/05/17/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2024/05/17/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="dfs-与-bfs-区别"><a href="#dfs-与-bfs-区别" class="headerlink" title="dfs 与 bfs 区别"></a>dfs 与 bfs 区别</h2><p>提到深度优先搜索（dfs），就不得不说和广度优先搜索（bfs）有什么区别</p><p>两者的区别：</p><ul><li>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</li><li>bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li></ul><h1 id="dfs-深度优先搜索"><a href="#dfs-深度优先搜索" class="headerlink" title="dfs(深度优先搜索)"></a>dfs(深度优先搜索)</h1><p>dfs解决的是<strong>路怎么走</strong>的问题</p><p>dfs的关键点在于：</p><ul><li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li><li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程</li></ul><p>所以回溯算法本质上就是dfs，回溯的模板也就是dfs的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>深搜三部曲：</strong></p><ol><li><p><strong>确认递归函数与参数</strong></p><p>通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以</p><p>一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多</p></li><li><p><strong>确认终止条件</strong></p></li><li><p><strong>处理目前搜索节点出发的路径</strong></p><p>一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">dfs</span>(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h2><p>题目链接：<a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">https://leetcode.cn/problems/all-paths-from-source-to-target/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 收集符合条件的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 0节点到终点的路径</span></span><br><span class="line">    <span class="comment">// x：目前遍历的节点</span></span><br><span class="line">    <span class="comment">// graph：存当前的图</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要求从节点 0 到节点 n-1 的路径并输出，所以是 graph.size() - 1</span></span><br><span class="line">        <span class="keyword">if</span> (x == graph.<span class="built_in">size</span>() - <span class="number">1</span>) &#123; <span class="comment">// 找到符合条件的一条路径</span></span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[x].<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 遍历节点n链接的所有节点</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(graph[x][i]); <span class="comment">// 遍历到的节点加入到路径中来</span></span><br><span class="line">            <span class="built_in">dfs</span>(graph, graph[x][i]); <span class="comment">// 进入下一层递归</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销本节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="bfs-广度优先搜索"><a href="#bfs-广度优先搜索" class="headerlink" title="bfs(广度优先搜索)"></a>bfs(广度优先搜索)</h1><p>bfs解决的是<strong>路有多长</strong>的问题</p><p><strong>bfs求的是点与点之间的最短路径！</strong></p><p>广度优先搜索一般采用<strong>队列</strong>的结构来进行</p><p>广搜的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; cur = que.<span class="built_in">front</span>(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        que.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="type">int</span> curx = cur.first;</span><br><span class="line">        <span class="type">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.<span class="built_in">push</span>(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>int dir[4][2] = &#123;0, 1, 1, 0, -1, 0, 0, -1&#125;;</code> </p><p>这个数组是用来表示从当前位置可以移动到的四个方向：右、下、左、上。每个方向由一对坐标偏移量表示：</p><ul><li><code>&#123;0, 1&#125;</code>：向右移动，即当前列坐标 +1，行坐标不变。</li><li><code>&#123;1, 0&#125;</code>：向下移动，即当前行坐标 +1，列坐标不变。</li><li><code>&#123;-1, 0&#125;</code>：向左移动，即当前列坐标 -1，行坐标不变。</li><li><code>&#123;0, -1&#125;</code>：向上移动，即当前行坐标 -1，列坐标不变。</li></ul><p><strong>pari</strong>的描述：</p><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量</p><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><h2 id="dfs解法"><a href="#dfs解法" class="headerlink" title="dfs解法"></a>dfs解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt; &gt;&amp; grid,vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt;&amp; visited,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> newR = r+dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> newC = c+dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(newR &gt;= <span class="number">0</span>&amp;&amp;newR &lt; grid.<span class="built_in">size</span>()&amp;&amp;newC &gt;= <span class="number">0</span>&amp;&amp;newC &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[newR][newC]&amp;&amp;grid[newR][newC]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[newR][newC] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid,visited,newR,newC);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="bfs解法"><a href="#bfs解法" class="headerlink" title="bfs解法"></a>bfs解法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125; &#125;;</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; que;</span><br><span class="line">que.<span class="built_in">push</span>(&#123;r,c&#125;);</span><br><span class="line">visited[r][c] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; top = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> newR = top.first + dir[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> newC = top.second + dir[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (newR &gt;= <span class="number">0</span> &amp;&amp; newR &lt; grid.<span class="built_in">size</span>() &amp;&amp; newC &gt;= <span class="number">0</span> &amp;&amp; newC &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (grid[newR][newC] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[newR][newC])</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(&#123; newR,newC &#125;);</span><br><span class="line">visited[newR][newC] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="太平洋大西洋水流问题"><a href="#太平洋大西洋水流问题" class="headerlink" title="太平洋大西洋水流问题"></a>太平洋大西洋水流问题</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// 保存四个方向</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从低向高遍历，注意这里visited是引用，即可以改变传入的pacific和atlantic的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 向四个方向遍历</span></span><br><span class="line">            <span class="type">int</span> nextx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> nexty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 超过边界</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= heights.<span class="built_in">size</span>() || nexty &lt; <span class="number">0</span> || nexty &gt;= heights[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 高度不合适，注意这里是从低向高判断</span></span><br><span class="line">            <span class="keyword">if</span> (heights[x][y] &gt; heights[nextx][nexty]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dfs</span> (heights, visited, nextx, nexty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; heights) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = heights[<span class="number">0</span>].<span class="built_in">size</span>(); <span class="comment">// 这里不用担心空指针，题目要求说了长宽都大于1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录从太平洋边出发，可以遍历的节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; pacific = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录从大西洋出发，可以遍历的节点</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; atlantic = vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最上最下行的节点出发，向高处遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span> (heights, pacific, i, <span class="number">0</span>); <span class="comment">// 遍历最左列，接触太平洋 </span></span><br><span class="line">            <span class="built_in">dfs</span> (heights, atlantic, i, m - <span class="number">1</span>); <span class="comment">// 遍历最右列，接触大西 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从最左最右列的节点出发，向高处遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="built_in">dfs</span> (heights, pacific, <span class="number">0</span>, j); <span class="comment">// 遍历最上行，接触太平洋</span></span><br><span class="line">            <span class="built_in">dfs</span> (heights, atlantic, n - <span class="number">1</span>, j); <span class="comment">// 遍历最下行，接触大西洋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果这个节点，从太平洋和大西洋出发都遍历过，就是结果</span></span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) result.<span class="built_in">push_back</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/./../../../typora-images/image-20240528235811656.png" alt="image-20240528235811656"></p><p><img src="/./../../../typora-images/image-20240528235757959.png" alt="image-20240528235757959"></p><p>35%通过而已</p><p>加上 记忆化搜索   优化的是bfs</p><p>dfs 路怎么走   bfs是路有多长</p><p>A* B* 跳点</p><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集主要有两个功能：</p><ul><li><strong>将两个元素添加到一个集合中</strong></li><li><strong>判断两个元素在不在同一个集合</strong></li></ul><p>并查集模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inti</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集里查找根结点(祖先)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="built_in">father</span>(u)) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">father</span>(u) = <span class="built_in">find</span>(<span class="built_in">father</span>(u));<span class="comment">//路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并集合 v→u</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根(祖先)</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根(祖先)</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;<span class="comment">//v的根指向u的根(v的祖先指向u的祖先)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习题：<a href="https://kamacoder.com/problempage.php?pid=1179">https://kamacoder.com/problempage.php?pid=1179</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2024/05/03/%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/05/03/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p><strong>链表的类型</strong></p><ul><li>单链表</li><li>双链表</li><li>循环链表</li></ul><p><strong>链表的存储方式</strong></p><p>链表是通过指针域的指针链接在内存中各个节点。</p><p>所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</p><p><strong>链表的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240503103823542.png" alt="image-20240503103823542"></p><p><strong>链表的操作</strong></p><p>删除节点</p><p>添加节点</p><h2 id="移除链表元素"><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">https://leetcode.cn/problems/remove-linked-list-elements/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; head-&gt;val == val) &#123;</span><br><span class="line">ListNode* tmp = head;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* cur = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">cur-&gt;next = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next-&gt;val == val)</span><br><span class="line">&#123;</span><br><span class="line">ListNode* del = cur-&gt;next;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p>题目链接：<a href="https://leetcode.cn/problems/design-linked-list/description/">https://leetcode.cn/problems/design-linked-list/description/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* cur = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        dummyHead-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &gt; size)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        LinkedNode* node = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        temp = <span class="literal">nullptr</span>;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印链表</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LinkedNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    LinkedNode* dummyHead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a>两两交换链表中的结点</h2><p>题目链接：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">https://leetcode.cn/problems/swap-nodes-in-pairs/description/</a></p><p>代码尝试:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       dummyHead-&gt;next = head;</span><br><span class="line">       ListNode* cur = dummyHead;</span><br><span class="line">       <span class="keyword">while</span> (cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ListNode* temp = cur-&gt;next;</span><br><span class="line">           ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">           cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">           cur-&gt;next-&gt;next = temp;</span><br><span class="line">           cur-&gt;next-&gt;next-&gt;next = temp1;</span><br><span class="line"></span><br><span class="line">           cur = cur-&gt;next-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode* result = dummyHead-&gt;next;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">         ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">2</span> &amp;&amp; n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (size - n - <span class="number">1</span> &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        cur = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - n <span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">       </span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><p>题目链接：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/">https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getIntersectionNode</span><span class="params">(ListNode* headA, ListNode* headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> sizeA = <span class="number">0</span>, sizeB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sizeA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sizeB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="type">int</span> startIndex = <span class="built_in">abs</span>(sizeA - sizeB);</span><br><span class="line">        <span class="keyword">if</span> (sizeA &gt; sizeB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; startIndex; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                curA = curA-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; startIndex; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                curB = curB-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">nullptr</span> &amp;&amp; curB != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB)</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="/2024/04/20/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2024/04/20/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="STL标准库"><a href="#STL标准库" class="headerlink" title="STL标准库"></a>STL标准库</h1><p>什么是STL？</p><p>STL主要包括了几个部分：</p><ul><li><strong>容器（Containers）</strong><ul><li>序列容器（vector、deque等）</li><li>关联容器（set、map等）</li><li>无序关联容器（unordered_set等）</li></ul></li><li><strong>算法（Algorithms）</strong><ul><li>非修改序列操作（find、count等）</li><li>修改序列操作（copy，replace，sort等）</li><li>删除操作</li><li>数值算法（accumulate（求和）、inner_product（内积）等）</li></ul></li><li><strong>迭代器（Iterators）</strong></li></ul><p>​迭代器是一种访问容器中元素的<strong>对象</strong>，类似于指针，不同的容器提供了不同类型的迭代器</p><ul><li><strong>函数对象（Function objects）</strong></li></ul><p>​用它们来封装行为或策略（比较、哈希等）</p><ul><li><p><strong>适配器（Adapters）</strong></p><ul><li><p>栈（stack）</p></li><li><p>队列（queue）</p></li><li><p>优先队列（priority_queue）</p><p>…</p></li></ul></li></ul><p>STL有三个版本，目前我们使用的基本上都为<code>SGI STL</code>，它是基于第一个版本HP STL实现的</p><p>面经：C++中stack是容器吗？为什么？</p><p>再解决这个问题时，先了解STL标准库里边的各个概念</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器的概念：</p><p>容器是<strong>存储数据</strong>的<strong>数据结构</strong>，容器类直接管理数据元素的存储，并提供直接的访问和管理数据的方法，所以不同的容器各有各的数据结构和性能特点</p><h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><p>在STL中通常指的是一种特殊的结构，它可以改变一个类（通常是容器或迭代器）的接口，使之适应不同的需求。适配器可以作用于容器、迭代器或函数对象</p><p><strong>适配器本身不直接存储数据，而是利用另外一个容器来存储数据</strong>，同时提供一个修改过的接口来访问这些数据</p><p><strong>容器与适配器的关系：</strong></p><p>容器适配器（eg：stack，queue）使用一个底层容器来存储数据，但是改变了访问这些数据的方式，转而提供了一种限定的接口</p><p>这意味着<strong>适配器依赖于底层容器</strong>来管理数据，但也限制或扩展了用户对数据的操作方式</p><p><strong>容器提供了数据存储和管理的基础功能，而适配器则在这个基础上提供特定的数据访问和操作模式</strong>，STL提供这种方式提高了代码的复用性，也增强了代码的清晰度和可维护性</p><p>更好的理解容器与适配器，比如这样一个例子：</p><p>容器使用了deque（双端队列），特点是可以在两端快速插入和删除元素，deque本身就提供了一个直接接口，接下来使用适配器来改变操作方式</p><ul><li>使用stack适配器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::stack&lt;<span class="type">int</span>, std::deque&lt;<span class="type">int</span>&gt;&gt; st;</span><br></pre></td></tr></table></figure><p>stack是后进先出结构，当用该适配器包装deque时，用户只能从deque的一端添加或移除元素，使其行为类似于栈</p><ul><li>使用queue适配器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::queue&lt;<span class="type">int</span>,std::deque&lt;<span class="type">int</span>&gt;&gt; qe;</span><br></pre></td></tr></table></figure><p>queue是先进先出结构，当用该适配器包装deque时，用户只能从尾部添加元素并从头部移除元素，使其行为类似于队列</p><p>回到上边的问题，我们就可以得到答案：C++中stack不是容器，而是一个容器适配器，因为栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以<strong>栈不提供走访功能，也不提供迭代器</strong></p><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）</strong></p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器的概念：</p><p>迭代器就是一个<strong>类对象</strong></p><p>那么该对象里边有多少个成员变量？</p><p>3个，分别是</p><ul><li>开始指向</li><li>当前指向</li><li>终值指向</li></ul><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>委托与事件</title>
      <link href="/2024/03/08/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/"/>
      <url>/2024/03/08/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>委托的作用：</p><ol><li>将<strong>函数</strong>作为<strong>函数的参数</strong>进行传递</li><li>声明事件并进行注册</li></ol><h2 id="委托类型"><a href="#委托类型" class="headerlink" title="委托类型"></a>委托类型</h2><ul><li><strong>无参无返回</strong></li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis(); <span class="comment">//启用委托</span></span><br><span class="line">pis.Invoke()<span class="comment">//第二种方式（常用）</span></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射子弹&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Pistol</span>()</span>;</span><br></pre></td></tr></table></figure><p><strong>第一个问题：既然初始一定要传入，那委托必须为非空吗？</strong></p><p>在解决这个问题之前，先继续探索委托的使用，在接下来的功能尝试下，就可以找到解决该问题的答案</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet; <span class="comment">//可以通过 &quot;+=&quot; 符号来注册方法</span></span><br><span class="line">pis += Bullet2; <span class="comment">//可以注册多个方法（一同使用）</span></span><br><span class="line"><span class="comment">//pis();</span></span><br><span class="line">pis.Invoke();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射第二颗子弹&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;发射子弹&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该内容最终显示在终端上的结果就为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308143353417.png" alt="image-20240308143353417"></p><p>同时，委托的注册事件严格遵循了<strong>注册的顺序</strong>，比如如果我更换上述注册的顺序，即：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此时在终端上的结果就为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308143525245.png" alt="image-20240308143525245"></p><p>而既然可以注册，那么也就有注销的方式，所以可以通过”-&#x3D;”来注销事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis -= Bullet2;</span><br></pre></td></tr></table></figure><p>最后在终端上显示便只有两个事件了，这时候我们也找到了可以探讨第一个问题的方式，即在初始化的时候便使用注销的方式，这样就可以设置其委托为空(null)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">pis -= Bullet; <span class="comment">//注销事件</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(pis == <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>此时打印出来便可以发现委托已经为空了，所以<strong>委托本身是可以为空的</strong>，而在实际应用开发中，由于委托本身是可能为空的，所以在应用委托的时候我们要对委托进行判断，而上述提到的两种委托启动的方式里，其实可以通过第二种方式的快捷判断来直接启用，语法为：<code>xxx?.Invoke()</code></p><p>该语法通过”?”来直接判断委托是否非空，进而确定是否为我们启用委托</p><ul><li><strong>有参有返回</strong></li></ul><p>接下来是有返回值且有带参数的委托事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); <span class="comment">//初始要传入</span></span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (number+<span class="number">1</span>).ToString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>该种方式的委托，其需要输入的参数与我们要注册的事件需要传入的参数类型要一致但形参名字可以不一致（“a”与“number”），同时可以注意到的是，在我们对委托进行初始化时<code>new Pistol(Bullet)</code>传入的函数并没有输入形参，而这正常来说会报错，但其报错实际上只在我们启动事件的时候才会提示并显示</p><p>如果我们设置了另外一个委托事件并进行注册：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (number+<span class="number">1</span>).ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet2</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span>*number).ToString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>此时的显示结果为最后注册的事件2：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308151510495.png" alt="image-20240308151510495"></p><p>这时再尝试加入一个新的事件或者多注册一次事件1，再查看结果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis += Bullet;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308151911137.png" alt="image-20240308151911137"></p><p><strong>第二个问题：需要返回值的委托进行事件注册，最终只能注册一个吗，如果只能注册一个，那么最终注册的事件是按最新注册的来还是按注册次数来？</strong></p><p>为了探讨该问题，我们需要再次做一个比较，由于刚才尝试的是 1（初始化）2 1的顺序，所以结果显示的是事件1的结果，此时事件1是最后注册的，且出现了两次，为了确定是顺序还是次数造成的最终结果，我们再次调换顺序：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p>此时可以发现结果变为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308152244609.png" alt="image-20240308152244609"></p><p>所以可以初步定下结论，即<strong>带有返回值的委托事件其最终能被注册的有且仅有最后注册的事件</strong>，但是我们还不能确定是不是只有带有返回值的委托才有这种结论，因为我们的委托事件还需要进行传参，所以我们还要进行后边的测试</p><ul><li><strong>有参无返回</strong></li></ul><p>接下来是设置有参数传递但是没有返回值的委托事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet); </span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">pis.Invoke(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number.ToString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bullet2</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine((<span class="number">2</span> * number).ToString()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义委托类型      delegate 类型 函数(函数名(参数...))</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Pistol</span>(<span class="params"><span class="built_in">int</span> a</span>)</span>;</span><br></pre></td></tr></table></figure><p>此时结果变为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308153347679.png" alt="image-20240308153347679"></p><p>我们可以发现，当我们把委托事件更改为无需返回值的时候，此时也有参数传递，但是当我们注册了多个事件后，再启动委托的时候可以发现所有被注册的事件都会被启用，为了再次确定，我们再进行最后一个类型的委托事件尝试</p><ul><li><strong>无参有返回</strong></li></ul><p>最后来进行有返回值但是没有参数传递的委托测试：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pistol pis = <span class="keyword">new</span> Pistol(Bullet);</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet;</span><br><span class="line">pis += Bullet2;</span><br><span class="line">Console.WriteLine(pis.Invoke());</span><br><span class="line"></span><br><span class="line"><span class="comment">//委托事件</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;发射子弹1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Bullet2</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;发射子弹2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终结果为：</p><p><img src="/./../images/%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/image-20240308154321265.png" alt="image-20240308154321265"></p><p>所以我们可以肯定的是：<strong>当委托为无返回值时，委托启用可以启用所有已经注册在委托下的事件；当委托为有返回值时，委托启用有且仅有最后一关注册的事件被启用，其他注册的事件不会被调用</strong></p><p><strong>PS：这里要注意的一点是，当委托为有返回值时，虽然委托最终调用的事件是最后一个注册的事件，但实际上其他事件也有被注册使用，只是最终启用的只是最后一个事件</strong></p><p>同时委托本身也根据这两种情况封装好了对应的可用委托类型（<strong>强类型委托</strong>）：</p><ul><li><strong>Action</strong></li></ul><p>Action是无返回值的泛型委托</p><p>eg：</p><p>Action表示无参无返回值的委托</p><p>Action&lt;int,string&gt;表示有传入参数int，string但是无返回值的委托</p><ul><li><strong>Func</strong></li></ul><p>Func是有返回值的泛型委托</p><p>eg：</p><p><strong>Func<int>表示无参，返回值为int的委托</strong></p><p>Func&lt;object,string,int&gt;表示传入参数为object，string，返回值为int的委托</p><p> Func&lt;T1,T2,,T3,int&gt; 表示传入参数为T1,T2,,T3(泛型)返回值为int的委托</p><p>这两种类型都支持至少0个参数，至多16个参数的传入</p><h2 id="委托应用"><a href="#委托应用" class="headerlink" title="委托应用"></a>委托应用</h2><p>如果是正常的委托，正如上述测试的例子一样：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Callback callback = <span class="keyword">new</span> Callback(MyCallBack);</span><br><span class="line">callback();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCallBack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我的回电&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>()</span>;</span><br></pre></td></tr></table></figure><p>但在实际应用中，我们可能会尝试在我们的功能下（已经封装好内容的函数）进行其他函数的处理，这时候就可以使用委托：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MyTest(MyCallBack); <span class="comment">//启用功能模块</span></span><br><span class="line"><span class="comment">//我的功能模块</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTest</span>(<span class="params">Callback callback</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyCallBack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;我的回电&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Callback</span>()</span>;</span><br></pre></td></tr></table></figure><p>我们还可以有更细致拆分的例子：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MyPlayerChose(<span class="number">30</span>, <span class="number">10</span>, ThePlanB);</span><br><span class="line"><span class="comment">//玩家选择自己的方案</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPlayerChose</span>(<span class="params"><span class="built_in">int</span> A,<span class="built_in">int</span> B,ChosePlan myPlan</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (myPlan(A, B) &gt;= A)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前选择方案为A或C&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;当前选择方案为B或C&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我的第一个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanA</span>(<span class="params"><span class="built_in">int</span> Aa,<span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的第二个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanB</span>(<span class="params"><span class="built_in">int</span> Aa, <span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Ab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我的第三个定制方案</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">ThePlanC</span>(<span class="params"><span class="built_in">int</span> Aa, <span class="built_in">int</span> Ab</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Aa+Ab;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">ChosePlan</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span>;</span><br></pre></td></tr></table></figure><p>通过该例子可以知道，委托可以让我们对函数进行定制化处理，能够让函数构造更加灵活</p><h2 id="委托进阶"><a href="#委托进阶" class="headerlink" title="委托进阶"></a>委托进阶</h2><p>我们在委托使用的时候知道，多端委托可以在我们启用的时候同时启用多个注册了的函数方法，那么如果中间有个注册的方法出现错误，会造成什么影响？</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testEvent eventList = <span class="keyword">new</span> testEvent(myEventA);</span><br><span class="line">eventList += myEventB;</span><br><span class="line">eventList += myEventC;</span><br><span class="line">eventList?.Invoke();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventA</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestA&quot;</span>);</span><br><span class="line"><span class="comment">//第二个注册方法会抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventB</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;TestB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventC</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestC&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">testEvent</span>()</span>;</span><br></pre></td></tr></table></figure><p>通过实践可以发现，最终当我们启用该委托的时候，由于注册的事件B出现错误，所以委托最终会因为B出错，从而事件调用的只有A，而B和C都不会被启用</p><p>也就是说：<strong>调用委托时，如果其中的一个委托报错，则后面的也不会被调用</strong></p><p>同时我们知道的是委托如果有返回值的情况下，也只会启用最后注册的事件，所以另外一个尝试就是如果通过”-&#x3D;”标识符来卸载注册方法，需要的时间又是怎么样的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">testEvent myTestList = <span class="keyword">new</span> testEvent(myEventA);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    myTestList += myEventB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sw = Stopwatch.StartNew();</span><br><span class="line">myTestList += myEventC;</span><br><span class="line">myTestList -= myEventC; <span class="comment">//再将注销掉的事件分别换成A和B</span></span><br><span class="line">sw.Stop();</span><br><span class="line">Console.WriteLine(sw.ElapsedTicks);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventA</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestA&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventB</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestB&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myEventC</span>()</span> =&gt; Console.WriteLine(<span class="string">&quot;TestC&quot;</span>);</span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">testEvent</span>()</span>;</span><br></pre></td></tr></table></figure><p>通过对取消注册最后事件(A，B，C)进行测试：</p><p>分别得到了780、356、265三个时间</p><p>原因是，<strong>委托注册事件本质上就是数组添加，所以remove的复杂度是O（n），且取消注册事件是由下往上进行的</strong></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>事件是一种特殊的委托</strong>，我们知道委托只要在被定义的时候就必须被注册，但是有些时候我们不想要这样做，这时候就可以用到事件了。</p><p>在这里补充一个说明，在定义委托的时候，它只是一个声明，声明这是一个委托；在定义事件的时候，它就已经是一个实例了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> MyDelegate myEvent; <span class="comment">//事件</span></span><br><span class="line"></span><br><span class="line"><span class="function">delegete <span class="keyword">void</span> <span class="title">MyPlan</span>()</span>; <span class="comment">//委托</span></span><br></pre></td></tr></table></figure><p>故而，<strong>事件</strong>一般是作为一个<strong>类的成员</strong>来出现</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void eventTest1()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Console.WriteLine(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">demo.myEvent += eventTest1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//相当于上述的缩写，使用了Lambda表达式</span></span><br><span class="line">demo.myEvent += () =&gt; Console.WriteLine(<span class="string">&quot;hello&quot;</span>);   <span class="comment">//注册委托</span></span><br><span class="line">demo.invokeEvent(); <span class="comment">//启用事件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该代码段中，通过直接使用<code>Action</code>来省略了声明委托的前置，因为<code>Action</code>本身就是一个委托类型</p><p>另外一种案例就是让事件在我们类成员发生了变化的时候才启用，这时候就可以做到事件对成员变量的监听，从而实现我们想要的效果：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Demo2 demo2 = <span class="keyword">new</span> Demo2();</span><br><span class="line"><span class="comment">//注册委托</span></span><br><span class="line">demo2.myEvent += () =&gt; Console.WriteLine(<span class="string">&quot;数值发生了改变&quot;</span>);</span><br><span class="line">demo2.TheNum = <span class="number">1</span>;</span><br><span class="line">demo2.TheNum = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Demo2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> theNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TheNum &#123; <span class="keyword">get</span> =&gt; theNum; </span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            theNum = <span class="keyword">value</span>;</span><br><span class="line">            <span class="comment">//数值发生变化的时候，启用事件</span></span><br><span class="line">            myEvent?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果是采用委托的话，我们并不可以通过这种方式来实现，因为委托需要先对函数事件进行注册</p><p>事件本质上就是C#提供的一个语法糖，它的作用是：</p><ol><li>将委托以私有变量的形式封装在类内，不让外面访问</li><li>对于委托进行封装，从而定义add与remove方法</li><li>在add与remove中通过互锁的方式提供了线程安全性</li></ol><h1 id="Unity中的应用"><a href="#Unity中的应用" class="headerlink" title="Unity中的应用"></a>Unity中的应用</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（三）</title>
      <link href="/2024/03/06/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/03/06/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="人物属性"><a href="#人物属性" class="headerlink" title="人物属性"></a>人物属性</h1><h2 id="人物血条"><a href="#人物血条" class="headerlink" title="人物血条"></a>人物血条</h2><p>人物血条大致要有内容：</p><p><strong>血条GUI设计</strong></p><p><strong>角色属性脚本</strong>(血量健康、法力等)</p><p>首先要制作血条GUI的设计：</p><p>采取三层图层且挂钩于一个幕布容器下，通过一个父级幕布容器来管理三层图，从而来表达出血条(健康，受伤)状态</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306164603902.png" alt="image-20240306164603902"></p><p>其中要注意的内容主要有：</p><p>1、画布缩放器(Canvas Scaler)的内容修改</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170305037.png" alt="image-20240306170305037"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170209695.png" alt="image-20240306170209695"></p><p>2、GUI血条图层的细节</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306170401374.png" alt="image-20240306170401374"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240306173311469.png" alt="image-20240306173311469"></p><p>通过设置图片显示方式来实现接下来应该有的血量减少的效果</p><h2 id="设计脚本"><a href="#设计脚本" class="headerlink" title="设计脚本"></a>设计脚本</h2><p>针对人物血条这个功能，我们可以知道的是其至少要有三个对象内容：</p><ul><li><strong>造成伤害方（怪物&#x2F;其他）</strong></li><li><strong>玩家受伤（玩家属性）</strong></li><li><strong>血条变化（GUI）</strong></li></ul><p>基于此我们可以先定义好玩家的属性脚本(Character)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent&lt;PlayerCharacter&gt; playerHealth;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       maxHealth = <span class="number">100f</span>;</span><br><span class="line">       health = maxHealth;</span><br><span class="line">       playerHealth?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>其中，玩家的属性发生变化的时候会对其他内容造成影响，通常来说我们可以直接通过事件的方式来让其他关联的脚本进行订阅，这样如果我们事件启用的时候也会对关联的脚本进行更改，但是这种方式需要在unity界面上进行绑定，这样还有一种缺点：当我们的场景进行切换（销毁Scene，切换另一个新的Scene），这样会导致我们绑定的容器也丢失，所以我们可以通过采取<code>ScriptableObject</code>来对委托进行数据存储：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Events/CharacterEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;PlayerCharacter&gt; action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEventRaised</span>(<span class="params">PlayerCharacter character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//相当于注册完成了一个带有PlayerCharacter参数的事件</span></span><br><span class="line">        action?.Invoke(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建完成对应的资源文件后将其绑定到人物脚本的事件上，从而实现<strong>广播</strong>（通知订阅方）：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240311205154396.png" alt="image-20240311205154396"></p><p>紧接着我们就需要实现对广播的接收方进行设计，也就是添加订阅方&#x2F;修改订阅方脚本</p><p>在这里先以只对血量变化进行血条GUI显示的脚本内容进行更改，让其订阅事件：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CharacterEventSO healthEvent; <span class="comment">//需要进行绑定</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       healthEvent.action += OnHealthChange;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       healthEvent.action -= OnHealthChange;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//实现血条变化的更改</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params">PlayerCharacter character</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       redHealth.fillAmount = <span class="number">1</span> - character.health / character.maxHealth;</span><br><span class="line">       Debug.Log(redHealth.fillAmount);</span><br><span class="line">       greenHealth.fillAmount = character.health / character.maxHealth;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将其内容进行一一绑定后就完成了整体事件的流程</p><h1 id="怪物设置"><a href="#怪物设置" class="headerlink" title="怪物设置"></a>怪物设置</h1><p>描述：设置怪物，通过怪物的巡逻和对玩家的检测，当两者进行接触时会对玩家造成伤害，具体流程为：</p><ul><li>怪物检测玩家</li><li>怪物追逐玩家</li><li>怪物对玩家造成伤害</li><li>怪物回到原点</li></ul><p>设置怪物的动画与GUI，完成对应的动画绑定后通过脚本实现怪物的追击与动画切换，其中怪物的属性是一个脚本，怪物的控制是另外一个脚本，这样方便接下来为怪物增加一些对应的状态</p><p>定义怪物的属性内容，同时设定事件，通过事件来调用怪物的控制类相关组件，这样只要让其具有检测的功能，而实现功能让另外一个控制脚本进行</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UnityEvent&lt;Vector2&gt; moveToPlayer;</span><br><span class="line"><span class="keyword">public</span> Transform player;</span><br><span class="line"><span class="comment">//怪物攻击力</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> attack;</span><br><span class="line"><span class="comment">//检测范围(仇恨范围)</span></span><br><span class="line">[<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">float</span> chaseDistance = <span class="number">4f</span>;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测玩家</span></span><br><span class="line">        <span class="built_in">float</span> distance = Vector2.Distance(player.position, transform.position);</span><br><span class="line">        <span class="keyword">if</span>(distance &lt; chaseDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//追击玩家</span></span><br><span class="line">            Vector2 dirction = player.position - transform.position;</span><br><span class="line">            <span class="comment">//移动方向(向量)传入</span></span><br><span class="line">            moveToPlayer?.Invoke(dirction.normalized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            moveToPlayer?.Invoke(Vector2.zero);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (collision.transform.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            doDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//怪物接触到玩家则会对其造成伤害</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doDamage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        player.GetComponent&lt;PlayerCharacter&gt;().hurtByEnemy(attack);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>怪物控制的脚本主要要实现怪物的移动、怪物动画的切换、怪物状态等具体内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params">Vector2 direction</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (direction.magnitude &gt; <span class="number">0</span> &amp;&amp; currentSpeed != <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//播放对应的动画</span></span><br><span class="line">         <span class="keyword">if</span> (direction != <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">             animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">             animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="keyword">if</span> (direction.x != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, direction.x);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (direction.y != <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, direction.y);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//进行移动</span></span><br><span class="line">         rb.velocity = direction * currentSpeed;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         rb.velocity = Vector2.zero;</span><br><span class="line">         animator.SetBool(<span class="string">&quot;isWalk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">         <span class="comment">//玩家脱战时让其返回原点</span></span><br><span class="line">         <span class="built_in">float</span> distance = Vector2.Distance(currentPos, transform.position);</span><br><span class="line">         <span class="keyword">if</span>(distance &gt; <span class="number">0.1f</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             Vector2 dir = currentPos - transform.position;</span><br><span class="line">             OnAnimatorMove(dir.normalized);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="更多机制"><a href="#更多机制" class="headerlink" title="更多机制"></a>更多机制</h2><p>怪物的巡逻也分为几种形式：</p><ul><li>固定地点出现，四周进行巡逻</li><li>固定地点出现，多个标记点来回巡逻</li></ul><p>怪物的状态也有几种形式：</p><ul><li><p>待机状态（巡逻状态）</p><ul><li>描述：最初状态（巡逻），速度为初始速度</li></ul></li><li><p>追击状态</p><ul><li>描述：追击玩家，具体效果可以自拟（比如怪物持续加速至攻击了一次停止）</li></ul></li><li><p>攻击状态（暂不实装）</p></li><li><p>受伤状态（暂不实装）</p></li><li><p>死亡状态（暂不实装）</p></li></ul><h3 id="怪物状态机"><a href="#怪物状态机" class="headerlink" title="怪物状态机"></a>怪物状态机</h3><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91(%E4%B8%89)/image-20240315104840991.png" alt="image-20240315104840991"></p><p>OnUpdate()又称为<strong>逻辑更新</strong>，OnFixedUpdate()又称为<strong>物理更新</strong></p><p>这里叙述一下逻辑更新与物理更新的区别：</p><p>逻辑更新它会在<strong>每一帧都被调用一次</strong>，也就是说，根据电脑性能的不同，它被调用的次数也会不同，相当于每“帧”更新，如果电脑240帧，则逻辑更新的内容就会被执行240次</p><p>物理更新的调用频率是固定的，它本质上不受帧率影响。默认情况下，物理更新每秒被调用50次，它会更适合用来处理物理相关的代码内容</p><p>比如逻辑更新更适合于物体瞬间施加的力（跳跃），物理更新则更适合于持续性的物理模拟（比如流动的水）</p><p>要先定义一个状态机接口，以此来实现不同状态进行切换的基础</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnStart</span>()</span>;</span><br><span class="line">    <span class="comment">//逻辑更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span>;</span><br><span class="line">    <span class="comment">//固定更新(物理更新)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnFixedUpdate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后一一定义不同的状态来实现该接口，同时要注意到怪物本身的类上定义好各个枚举变量，从而对怪物自身不同的状态类进行初始化处理，这里简单举例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//敌人状态枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnemyStateType</span><br><span class="line">&#123;</span><br><span class="line">    Idle,Walk,Chase,Hurt,Die</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设定切换状态的方法，同时一般来说，如果怪物有其他属性或者其他数据进行通信，则还要在每个状态类里边定义对应的怪物脚本类属性，这样就能在调用状态切换的情况下把需要的数值传递进来</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置字典键值对存取各个状态并初始化</span></span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;EnemyStateType,BaseState&gt; states = <span class="keyword">new</span> Dictionary&lt;EnemyStateType,BaseState&gt;();</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">public</span> BaseState currentBaseState;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//对每个状态进行初始化</span></span><br><span class="line">        states.Add(EnemyStateType.Idle, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Walk, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Chase, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Hurt, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line">        states.Add(EnemyStateType.Die, <span class="keyword">new</span> EnemyIdle());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始状态</span></span><br><span class="line">        TransitionState(EnemyStateType.Idle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TransitionState</span>(<span class="params">EnemyStateType stateType</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(currentBaseState != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentBaseState.OnExit();</span><br><span class="line">        &#125;</span><br><span class="line">        currentBaseState = states[stateType];</span><br><span class="line">        currentBaseState.OnStart();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>若加入数据通信，则只需要改为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnemyDie</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Enemy enemy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnemyDie</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.enemy = enemy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后在对应的初始化位置实装<code>states.Add(EnemyStateType.Idle, new EnemyIdle(this));</code>即可</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包系统开发</title>
      <link href="/2024/01/27/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/"/>
      <url>/2024/01/27/%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="背包GUI设计"><a href="#背包GUI设计" class="headerlink" title="背包GUI设计"></a>背包GUI设计</h1><p>最终效果：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154046999.png" alt="image-20240131154046999"></p><p>一些实用内容：</p><p>1、取消按钮功能的实现 —— 直接绑定</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154238667.png" alt="image-20240131154238667"></p><p>2、背包格子的布局</p><p>最好创建一个子容器来对接下来各个格子进行排布，尤其是使用相关组件<code>Grid Layout Group</code></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240131154615845.png" alt="image-20240131154615845"></p><p>3、单个物品格子独立设置成一个预制体(<strong>Prefab</strong>)</p><h1 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h1><p>需要用到的核心父类<strong>ScriptableObject</strong></p><ul><li>定义物品类（基类）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Item&quot;</span>,menuName = <span class="string">&quot;Inventory/Item&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Item</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//物品名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> itemName;</span><br><span class="line">    <span class="comment">//物品贴图</span></span><br><span class="line">    <span class="keyword">public</span> Sprite itemImage;</span><br><span class="line">    <span class="comment">//物品数目</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> itemHeld;</span><br><span class="line">    <span class="comment">//物品描述</span></span><br><span class="line">    [<span class="meta">TextArea</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> itemInfo;</span><br><span class="line">    <span class="comment">//是否可以使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> canUse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240219171049446.png" alt="image-20240219171049446"></p><p>自定义出对应的物品Item，后续的存储数据更改就会只针对对应物品下的物品数量属性(Item Held)进行加减</p><ul><li>定义背包类（基类）</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CreateAssetMenu(fileName = <span class="string">&quot;New Bag&quot;</span>, menuName = <span class="string">&quot;Inventory/Bag Inventory&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BagScript</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> List&lt;Item&gt; bagList = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240219171537128.png" alt="image-20240219171537128"></p><p>背包最终存储的会是对应的物品类型，而不会造成同一物品堆叠，让物品数量在对应的物品内容上进行更改即可</p><h2 id="ScriptableObject进行数据存储-重要"><a href="#ScriptableObject进行数据存储-重要" class="headerlink" title="ScriptableObject进行数据存储(重要)"></a>ScriptableObject进行数据存储(重要)</h2><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202111507811.png" alt="image-20240202111507811"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202113637293.png" alt="image-20240202113637293"></p><p><code>CreateAssetMenuAttribute</code>作用：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240202113707681.png" alt="image-20240202113707681"></p><h1 id="背包使用"><a href="#背包使用" class="headerlink" title="背包使用"></a>背包使用</h1><ul><li>打开背包</li></ul><p>玩家打开背包可以通过特定按键（”O”键举例）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openBag</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.O))</span><br><span class="line">       &#123;</span><br><span class="line">           isOpen = !isOpen;</span><br><span class="line">           bag.SetActive(isOpen);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>定义拾取脚本(ItemOnWorld)</li></ul><p>玩家捡起对应的物品时相关的一些逻辑内容</p><p>物品 → 背包 → 当前场景物品消失(隐藏)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//捡起的物品</span></span><br><span class="line">  <span class="keyword">public</span> Item thisItem;</span><br><span class="line">  <span class="comment">//绑定的背包(玩家的背包)</span></span><br><span class="line">  <span class="keyword">public</span> BagScript playerBag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(collision.transform.parent.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//将物品放入背包中</span></span><br><span class="line">          AddNewItem();</span><br><span class="line">          Destroy(gameObject);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加物品到背包中</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNewItem</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(!playerBag.bagList.Contains(thisItem))</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//数据存储层面</span></span><br><span class="line">          playerBag.bagList.Add(thisItem);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         thisItem.itemHeld++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//GUI层面</span></span><br><span class="line">      InventoryManager.instance.refreshItemsInBags();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>物品显示在背包中</p><ul><li><p>单个<strong>物品格子</strong>对应的脚本设计(Slot)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Item item;</span><br><span class="line"><span class="keyword">public</span> Image ItemImage;</span><br><span class="line"><span class="keyword">public</span> Text slotNum;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//点击物品时可以查看物品信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemOnClick</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    InventoryManager.updateItemDescription(item.itemInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>背包数据与物品拾取数据处理的脚本设计（单例模式实现        InventoryManager）</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InventoryManager instance;</span><br><span class="line"><span class="comment">//玩家背包</span></span><br><span class="line"><span class="keyword">public</span> BagScript playerBag;</span><br><span class="line"><span class="comment">//物品内容</span></span><br><span class="line"><span class="keyword">public</span> Slot slot;</span><br><span class="line"><span class="comment">//物品描述</span></span><br><span class="line"><span class="keyword">public</span> Text slotDescription;</span><br><span class="line"><span class="comment">//在背包GUI中对应的格子</span></span><br><span class="line"><span class="keyword">public</span> GameObject slotGrid;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123; </span><br><span class="line">        Destroy(instance);</span><br><span class="line">    &#125;</span><br><span class="line">    instance = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    refreshItemsInBags();</span><br><span class="line">    instance.slotDescription.text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//背包GUI上进行单一物品创建显示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CreateNewItem</span>(<span class="params">Item item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在对应的列表容器位置创建一个新的物品</span></span><br><span class="line">    Slot newItem = Instantiate(instance.slot, instance.slotGrid.transform);</span><br><span class="line">    <span class="comment">//初始化物品信息(包括图片，内容介绍)</span></span><br><span class="line">    newItem.item = item;</span><br><span class="line">    newItem.ItemImage.sprite = item.itemImage;</span><br><span class="line">    newItem.slotNum.text = item.itemHeld.ToString();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//根据背包数据显示在背包GUI上</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshItemsInBags</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先清空背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.slotGrid.transform.childCount;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.slotGrid.transform.childCount == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        Destroy(instance.slotGrid.transform.GetChild(i).gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据背包数据在GUI上逐个创建</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.playerBag.bagList.Count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        CreateNewItem(playerBag.bagList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateItemDescription</span>(<span class="params"><span class="built_in">string</span> itemDescription</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    instance.slotDescription.text = itemDescription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在界面上也要对对应的属性先进行绑定</p></li></ul></li></ul><h1 id="附加：可拖拽背包"><a href="#附加：可拖拽背包" class="headerlink" title="附加：可拖拽背包"></a>附加：可拖拽背包</h1><p>描述：可以自由地将物品从原先的格子拖拽到不同的格子上去，实现背包中内容的拖拽</p><p>原先的背包设计是：</p><p>将物品单元格当做一个容器，若拾取了道具就会在Grid表单中创建对应的一个新的单元格，也就是只有 <strong>Grid → Grid下子单元</strong>(自身就包含物品内容)</p><p>拖拽背包的设计是：</p><p>在Grid表单中一次性创建多个物品单元格容器，物品单元格的内容可以往下一级，形成 <strong>Grid → Grid下子单元 → 子单元下物品内容</strong>，这样就可以实现不同单元格可以被交换</p><p><strong>一 、</strong>GUI的重新设计：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240227162144821.png" alt="image-20240227162144821"></p><p>其中Item就是当前物品内容的父组件(Button)，ItemSec相当于Grid下子单元，初始默认为空</p><p><strong>二、</strong>背包脚本的重新设计：</p><p>背包单元格Slot</p><p>修改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自身挂载的容器 —— 即背包下子单元格</span></span><br><span class="line">   <span class="keyword">public</span> GameObject itemInSlot;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//点击物品时可以查看物品信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemOnClick</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       InventoryManager.updateItemDescription(slotInfo);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//初始化每个GUI单元格的内容</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpItem</span>(<span class="params">Item item</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(item == <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           itemInSlot.SetActive(<span class="literal">false</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       slotImage.sprite = item.itemImage;</span><br><span class="line">       slotNum.text = item.itemHeld.ToString();</span><br><span class="line">       slotInfo = item.itemInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>背包功能处理InventoryManager</p><p>修改后：不需要CreateNewItem内容</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据背包数据显示在背包GUI上</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshItemsInBags</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//先清空背包</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.slotGrid.transform.childCount;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (instance.slotGrid.transform.childCount == <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           Destroy(instance.slotGrid.transform.GetChild(i).gameObject);</span><br><span class="line">           <span class="comment">//背包链表清空</span></span><br><span class="line">           instance.slots.Clear();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据背包数据在GUI上逐个创建</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;instance.playerBag.bagList.Count;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//CreateNewItem(playerBag.bagList[i]);</span></span><br><span class="line">           instance.slots.Add(Instantiate(instance.emptySlot));</span><br><span class="line">           instance.slots[i].transform.SetParent(instance.slotGrid.transform);</span><br><span class="line">           <span class="comment">//将物品内容显示在单元格中</span></span><br><span class="line">           instance.slots[i].GetComponent&lt;Slot&gt;().setUpItem(instance.playerBag.bagList[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>拾取脚本ItemOnWorld</p><p>修改后：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//添加物品到背包中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddNewItem</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!playerBag.bagList.Contains(thisItem))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//playerBag.bagList.Add(thisItem);</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;playerBag.bagList.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (playerBag.bagList[i]==<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                playerBag.bagList[i] = thisItem;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       thisItem.itemHeld++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InventoryManager.instance.refreshItemsInBags();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拖拽内容"><a href="#拖拽内容" class="headerlink" title="拖拽内容"></a>拖拽内容</h2><p>描述：背包内容可以被拖拽</p><p>需要用到<code>EventSystems</code>库下的几个接口（<strong>IBeginDragHandler</strong>、<strong>IDragHandler</strong>、<strong>IEndDragHandler</strong>）来实现点击物品后让物品跟着(“黏住”)鼠标箭头移动</p><p>定义需要用到的脚本，绑定到物品容器(item)上，让其能够被拖拽</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录要拖拽物品的初始位置(当前位置)</span></span><br><span class="line"><span class="keyword">public</span> Transform originalPos;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    originalPos = transform.parent;</span><br><span class="line">    transform.SetParent(transform.parent.parent);</span><br><span class="line">    <span class="comment">//（跟随鼠标移动）  被点击的物品  →  鼠标点击位置</span></span><br><span class="line">    transform.position = eventData.position;</span><br><span class="line">    GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SetDraggedPosition(eventData);</span><br><span class="line">    <span class="comment">//获取当前幕布组件下射线检测到的容器(内容)是什么</span></span><br><span class="line">    <span class="comment">//Debug.Log(eventData.pointerCurrentRaycast.gameObject.name);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着实现在移动物品时能够检测到当前移动指向的格子的内容，为接下来的替换物品位置做准备，在这里采用的是通过<code>Canvas Group</code>幕布容器来实现</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240228142847283.png" alt="image-20240228142847283"></p><p>通过该容器的<strong>Block Raycasts</strong>射线来检测此时鼠标箭头(粘着)上物品移动的地点下方被射线穿透到的是哪个单元格</p><p>其中，Block Raycasts的属性可以勾选</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240229132819741.png" alt="image-20240229132819741"></p><p>该内容表示<strong>是否可以让射线穿透</strong>，若处于空则表示允许穿透，此时如果鼠标已经在拖拽物品，<strong>射线可以穿透该物品而检测到鼠标移动地方下是什么</strong>，若勾上√则表示不允许穿透，此时如果鼠标已经在拖拽物品，射线就不能穿透，只能一直检测到的都是鼠标正在拖拽的物品</p><p>所以通过在不同状态下(开始拖拽、拖拽进行时、结束拖拽)设置该值来实现拖拽物品与要到达的目的地进行检测，从而实现物品交换或填补空白单元格</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>最后填补上最后一个接口实现方法(结束拖拽状态 → 物品替换&#x2F;填补)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnEndDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//鼠标指向的单元格存在物品的情况下</span></span><br><span class="line">    <span class="keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;Image&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GameObject targetSec = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.gameObject;</span></span><br><span class="line">        <span class="comment">//GameObject targetObj = eventData.pointerCurrentRaycast.gameObject.transform.parent.gameObject;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把鼠标抓着的物品放到要交换的当前物品格下</span></span><br><span class="line">        <span class="comment">//transform.SetParent(targetSec.transform);</span></span><br><span class="line">        <span class="comment">//transform.position = targetSec.transform.position;</span></span><br><span class="line">        transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform.parent.parent);</span><br><span class="line">        transform.position = eventData.pointerCurrentRaycast.gameObject.transform.parent.parent.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把被交换的物品放到鼠标最初点击的物品位置下</span></span><br><span class="line">        <span class="comment">//targetObj.transform.SetParent(originalPos);</span></span><br><span class="line">        <span class="comment">//targetObj.transform.position = originalPos.position;</span></span><br><span class="line">        eventData.pointerCurrentRaycast.gameObject.transform.parent.transform.SetParent(originalPos);</span><br><span class="line">        eventData.pointerCurrentRaycast.gameObject.transform.parent.transform.position = originalPos.position;</span><br><span class="line">       </span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(eventData.pointerCurrentRaycast.gameObject.name == <span class="string">&quot;ItemSec(Clone)&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不存在物品的情况下(空单元格)</span></span><br><span class="line">        transform.SetParent(eventData.pointerCurrentRaycast.gameObject.transform);</span><br><span class="line">        transform.position = eventData.pointerCurrentRaycast.gameObject.transform.position;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.SetParent(originalPos);</span><br><span class="line">        transform.position = originalPos.position;</span><br><span class="line">        GetComponent&lt;CanvasGroup&gt;().blocksRaycasts = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDraggedPosition</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rt = gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">    <span class="comment">// transform the screen point to world point int rectangle</span></span><br><span class="line">    Vector3 globalMousePos;</span><br><span class="line">    <span class="keyword">if</span> (RectTransformUtility.ScreenPointToWorldPointInRectangle(rt, eventData.position, eventData.pressEventCamera, <span class="keyword">out</span> globalMousePos))</span><br><span class="line">    &#123;</span><br><span class="line">        rt.position = globalMousePos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要优化以及可以改变的方式"><a href="#需要优化以及可以改变的方式" class="headerlink" title="需要优化以及可以改变的方式"></a>需要优化以及可以改变的方式</h2><ul><li><p>无法将背包中的物品拖拽放置在背包之外</p></li><li><p>无法将背包中的物品拖拽放置在两个单元格之间（已实现）</p></li><li><p>拖拽的物品放到另外一个物品使其弹出并”粘”在鼠标箭头上(MC)</p></li><li><p>背包GUI可以被拖拽（已实现）</p></li><li><p>背包数据在物品位置变换后，重新打开后要依旧是变换后的位置（已实现）</p></li><li><p>物品内容被拖出背包外，可以是物品掉落&#x2F;弹回原位(禁止背包外)</p></li></ul><h3 id="背包GUI界面可以被拖拽"><a href="#背包GUI界面可以被拖拽" class="headerlink" title="背包GUI界面可以被拖拽"></a>背包GUI界面可以被拖拽</h3><p>设计对应的背包拖拽脚本，通过<strong>IDragHandler</strong>接口来实现拖拽状态</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定背包GUI的坐标</span></span><br><span class="line">  <span class="comment">//public Transform bagGUI;</span></span><br><span class="line">  <span class="keyword">public</span> RectTransform bagGUI;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      bagGUI = GetComponent&lt;RectTransform&gt;();</span><br><span class="line">      <span class="comment">//bagGUI = GetComponent&lt;Transform&gt;();</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      bagGUI.anchoredPosition += eventData.delta;</span><br><span class="line">      <span class="comment">//bagGUI.position = eventData.position;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于背包GUI自身是最大的父级容器，同时GUI画面较大，直接通过鼠标拖拽时会使得鼠标也一直在GUI画面的中心位置进行，为了使得效果更加好，通过直接获得<code>RectTransform</code>组件来进行移动，其中<code>RectTransform</code>提供了:</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301161645344.png" alt="image-20240301161645344"></p><p>当前中心位置加上鼠标对应的位置即是背包GUI移动的位置，其中采用了<code>PointerEventData</code>点击事件中的delta方法快速获取鼠标坐标</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301155833328.png" alt="image-20240301155833328"></p><h3 id="背包数据优化-数据同化"><a href="#背包数据优化-数据同化" class="headerlink" title="背包数据优化(数据同化)"></a>背包数据优化(数据同化)</h3><p>当玩家对背包物品进行过拖拽操作，并且改变了原来物品所在的位置时，当玩家重新打开背包或者拾取新的物品时，原先物品发生变化情况下位置要不变（比如进行物品拖拽后，A物品在第二行第三个，再次打开背包或者拾取新物品时，背包数据同步后，A物品依旧在第二行第三个）</p><p>脚本修改分析：</p><p><strong>背包</strong>(最高级父级)绑定的是背包整体处理，涉及的有GUI以及背包数据同步  —— InventoryManager</p><p><strong>单元格</strong>(父级)向上是对背包负责，向下是对物品内容(Item)负责，涉及的有物品内容GUI的展示 —— Slot</p><p><strong>物品内容</strong>(子级)向上是对单元格负责，自身就是最低级，涉及的是自身内容，无展示，同时能够执行拖拽功能 —— ItemOnDrag</p><p>思路：</p><p>背包脚本中具有<strong>链表</strong>属性，该属性的子节点对应每个单元格(Slot)，而单元格下又都一一对应一物品内容(Item)，所以背包中的链表每一个<strong>序号</strong>都可以来表示单元格的序号，<strong>单元格的序号又可以作为物品的序号</strong>，只要通过定义序号，当物品内容进行了拖拽，通过物品内容(Item)自身挂载的脚本，实现的过程中再完成对链表中物品的替换即可(List[A] ,List[B], T)</p><p>单元格脚本的修改：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192633792.png" alt="image-20240301192633792"></p><p>背包数据脚本的修改：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192721771.png" alt="image-20240301192721771"></p><p>物品内容拖拽脚本的增添：</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192912288.png" alt="image-20240301192912288"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301192822520.png" alt="image-20240301192822520"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240302123009763.png" alt="image-20240302123009763"></p><h3 id="拖拽物品闪烁问题的解决"><a href="#拖拽物品闪烁问题的解决" class="headerlink" title="拖拽物品闪烁问题的解决"></a>拖拽物品闪烁问题的解决</h3><p>该问题主要是因为物品在拥有<code>Grid</code>组件的容器下，而拖拽的时候物品是独立出来的，再接进去的话由于Grid的规则，要先按Grid的排序，所以会过渡到n+1行下，导致闪烁的发生</p><p>解决方式：</p><p>在物品内容容器下添加一个可以忽略<code>Grid</code>规则的组件，启用忽略Grid规则即可</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240301195631952.png" alt="image-20240301195631952"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/13/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%9A%BE%E9%A2%98/"/>
      <url>/2024/01/13/%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E9%9A%BE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="同种交互物品不同交互内容"><a href="#同种交互物品不同交互内容" class="headerlink" title="同种交互物品不同交互内容"></a>同种交互物品不同交互内容</h1><p>描述：开发途中需要用到两个交互物体，一个物体要实现玩家交互后进行传送，另外一个物体要实现玩家开启后启用其他被隐藏起来的物品</p><p>定义交互的接口<code>IInteractive</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInteractive</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">achieveEvent</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>交互物体1</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//传送到达的地点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Vector2 endPos;</span><br><span class="line">   <span class="comment">//传送的对象</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> GameObject player;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//将玩家传送到指定目标点</span></span><br><span class="line">       player.transform.position = endPos;</span><br><span class="line">       <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 激活 obj</span></span><br><span class="line">           obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//点亮柱子</span></span><br><span class="line">           StartCoroutine(changeGlow());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>交互物体2</p></li></ul><p>​   实现挑战的开启</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GameObject challenge;</span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//开启收集物</span></span><br><span class="line">       Debug.Log(<span class="string">&quot;开启收集挑战&quot;</span>);</span><br><span class="line">       challenge.GetComponent&lt;StartChallenge&gt;().getAllCollections();</span><br><span class="line">       <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// 激活 obj</span></span><br><span class="line">           obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">           <span class="comment">//点亮柱子</span></span><br><span class="line">           StartCoroutine(changeGlow());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>玩家要绑定的交互脚本要实现同个交互内容但是对应当前被交互的交互物体：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//交互的物体</span></span><br><span class="line">  <span class="keyword">public</span> Collider2D coll;</span><br><span class="line"><span class="keyword">private</span> IInteractive currentInteractiveItem;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//交互</span></span><br><span class="line">          <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E)&amp;&amp;currentInteractiveItem != <span class="literal">null</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              currentInteractiveItem.achieveEvent();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      coll = collision;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (canPress)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//初始化交互物体</span></span><br><span class="line">              IInteractive interactiveItem = coll.GetComponent&lt;IInteractive&gt;();</span><br><span class="line">              currentInteractiveItem = interactiveItem;</span><br><span class="line">          &#125;</span><br><span class="line">          StartCoroutine(waitForSecondOpen());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>通过接口设定同种交互物体需要实现的方法，对方法进行重载，然后通过角色身上的交互检测对应的方法，设置一个该接口的属性，然后通过接口的属性来赋值，获取要交互的物体对应的方法，这样就实现了同种交互物品，当玩家靠近并调用时能够完成其不同的交互内容</p><p>​    </p><h1 id="背包拖拽问题"><a href="#背包拖拽问题" class="headerlink" title="背包拖拽问题"></a>背包拖拽问题</h1><p>背包拖拽通过采用<strong>MonoBehaviour,IBeginDragHandler,IDragHandler,IEndDragHandler</strong>三个接口来进行，在实现接口方式时，由于世界坐标系的问题，可能会导致数值特别大（疑似PointerEventData eventData获取的是世界坐标），原先的方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      transform.position = eventData.position;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这在实际游戏体验时候会发现当你鼠标点击物品后，还没拖拽，该物品就已经飞出你的视野之外了</p><p>修改办法可以是通过<code>ScreenPointToWorldPointInRectangle</code>方法来解决，将屏幕坐标与世界坐标进行转换，修改后的方式：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDrag</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetDraggedPosition(eventData);</span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetDraggedPosition</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> rt = gameObject.GetComponent&lt;RectTransform&gt;();</span><br><span class="line">        <span class="comment">// transform the screen point to world point int rectangle</span></span><br><span class="line">        Vector3 globalMousePos;</span><br><span class="line">        <span class="keyword">if</span> (RectTransformUtility.ScreenPointToWorldPointInRectangle(rt, eventData.position, eventData.pressEventCamera, <span class="keyword">out</span> globalMousePos))</span><br><span class="line">        &#123;</span><br><span class="line">            rt.position = globalMousePos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="2D-x2F-3D鼠标检测"><a href="#2D-x2F-3D鼠标检测" class="headerlink" title="2D&#x2F;3D鼠标检测"></a>2D&#x2F;3D鼠标检测</h1><p>参考：<a href="https://www.bilibili.com/video/BV1pa4y157Qo">https://www.bilibili.com/video/BV1pa4y157Qo</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（二）</title>
      <link href="/2023/12/10/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/10/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="系列挑战"><a href="#系列挑战" class="headerlink" title="系列挑战"></a>系列挑战</h1><p>描述：角色触发挑战后在指定位置刷新几个挑战点位，玩家要到达这些点位开启挑战任务，完成挑战任务后开启门扉</p><h2 id="收集挑战"><a href="#收集挑战" class="headerlink" title="收集挑战"></a>收集挑战</h2><p>描述：角色在指定位置开启挑战，开启后会在地图随机刷取收集物，角色收集完成收集物后回来完成收集目标</p><p>收集挑战的流程大致为：</p><ul><li><p>开启挑战</p><ul><li><p>无时间限制</p></li><li><p>有时间限制</p></li></ul></li><li><p>生成收集物</p><ul><li>生成方式</li></ul></li><li><p>寻找收集物</p></li><li><p>返回提交 (需要背包系统)</p></li></ul><p>收集物的刷新方式可以有</p><p>1）随机位置生成物品</p><p>2）指定位置生成物品（单点位，连续路径）</p><p>3）固定位置重复生成</p><h3 id="生成收集物"><a href="#生成收集物" class="headerlink" title="生成收集物"></a>生成收集物</h3><p>根据玩法不同，可以设置多种不同的收集物生成方式，这里举例三种方式：</p><p>1.随机位置生成</p><p>2.指定位置生成</p><p>3.固定位置重复生成</p><p>其中，随机位置生成类似星露谷的采集品，像一些野菜等随机生成在指定范围或者区域内</p><p>指定位置生成则比较普遍，比如一些固定点位必有的任务物品等</p><p>固定位置重复生成则类似传奇这种玄幻类游戏中采集草药等</p><p>开启挑战的石柱对应绑定的脚本内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要绑定的收集物统一父组件   </span></span><br><span class="line"><span class="keyword">public</span> GameObject challenge;  </span><br><span class="line"><span class="comment">//实现交互功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span>&#123;</span><br><span class="line">        <span class="comment">//开启收集物</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;开启收集挑战&quot;</span>);</span><br><span class="line">        challenge.GetComponent&lt;StartChallenge&gt;().getAllCollections();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 激活 obj</span></span><br><span class="line">            obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//点亮柱子</span></span><br><span class="line">            StartCoroutine(changeGlow());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="随机位置生成"><a href="#随机位置生成" class="headerlink" title="随机位置生成"></a>随机位置生成</h4><h4 id="指定位置生成"><a href="#指定位置生成" class="headerlink" title="指定位置生成"></a>指定位置生成</h4><p>描述：通过<strong>指定坐标</strong>位置地方生成对应收集品</p><p>收集物统一的父组件绑定对应的生成收集物脚本：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;GameObject&gt; collectionList;</span><br><span class="line">   <span class="keyword">public</span> GameObject col1;</span><br><span class="line">   <span class="keyword">public</span> GameObject col2;</span><br><span class="line">   <span class="keyword">public</span> GameObject col3;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       collectionList = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line">       collectionList.Add(col1);</span><br><span class="line">       collectionList.Add(col2);</span><br><span class="line">       collectionList.Add(col3);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//生成收集物</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllCollections</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; collectionList.Count; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           collectionList[i].SetActive(<span class="literal">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240113203747997.png" alt="image-20240113203747997"></p><h4 id="固定位置重复生成"><a href="#固定位置重复生成" class="headerlink" title="固定位置重复生成"></a>固定位置重复生成</h4><h3 id="获取收集物-无背包系统版本"><a href="#获取收集物-无背包系统版本" class="headerlink" title="获取收集物(无背包系统版本)"></a>获取收集物(无背包系统版本)</h3><p>描述：玩家到达收集物位置时按下“F”键进行拾取，收集物会被收集得到，原先的收集物继续被隐藏（<strong>前提：加了时间限制，考虑到没在时间内收集齐导致挑战失败，所以不能直接销毁</strong>）</p><p>玩家身上的交互组件进行修改，添加对获取收集物的记录，同时隐藏收集物即可</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录收集物品的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="built_in">int</span> collNum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment"><span class="doctag">///</span>TOOD：交互部分</span></span><br><span class="line">          <span class="comment">//柱子功能交互</span></span><br><span class="line">     </span><br><span class="line">          ...</span><br><span class="line">              </span><br><span class="line">          <span class="comment">//收集物交互</span></span><br><span class="line">          <span class="keyword">if</span>(Input.GetKeyDown(KeyCode.F) &amp;&amp; coll.CompareTag(<span class="string">&quot;Collection&quot;</span>))</span><br><span class="line">          &#123;</span><br><span class="line">              collNum++;</span><br><span class="line">              coll.GameObject().SetActive(<span class="literal">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该功能还可以继续提高上限 ———— <strong>制作背包系统和任务系统(待定)</strong></p><p>背包系统(已实现)</p><p>任务系统(搁置)</p><p>通过拾取收集物，将收集物放入背包，最后玩家再到挑战任务要提交的地方进行提交（此时也要把已经获得的对应收集物进行销毁）</p><h3 id="获取收集物-背包系统"><a href="#获取收集物-背包系统" class="headerlink" title="获取收集物(背包系统)"></a>获取收集物(背包系统)</h3><p>将收集物绑定到数据容器(ScriptableObject)下即可，接下去的背包系统整体内容开发详见<code>背包系统开发</code>页</p><h3 id="提交物品-待定"><a href="#提交物品-待定" class="headerlink" title="提交物品(待定)"></a>提交物品(待定)</h3><p>描述：将物品提交到指定位置 or 提交给指定npc(前置：任务系统)</p><h2 id="时间竞赛"><a href="#时间竞赛" class="headerlink" title="时间竞赛"></a>时间竞赛</h2><p>描述：角色在限定时间内到达指定目标位置，超过时间限制则挑战失败并返回到起点</p><p>时间竞赛的流程大致为：</p><ul><li>开启挑战<ul><li>启动倒计时(显示GUI)</li><li>标出目标地点</li></ul></li><li>目标设置<ul><li>到达目标</li><li>未在指定位置到达<ul><li>返回起点</li></ul></li></ul></li><li>关闭倒计时(完成该挑战)</li></ul><h3 id="开启挑战"><a href="#开启挑战" class="headerlink" title="开启挑战"></a>开启挑战</h3><p>首先要设计好对应的时间条模板GUI，在这里设计成分和秒一同计时的方式</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240304215045034.png" alt="image-20240304215045034"></p><p>通过设置分钟的文本和秒的文本来表示数字，方便后续脚本内容的管理</p><p>定义的字段大致有：</p><table><thead><tr><th>属性</th><th>类型</th></tr></thead><tbody><tr><td>总计数</td><td>float</td></tr><tr><td>分钟</td><td>float</td></tr><tr><td>秒</td><td>float</td></tr><tr><td>分钟</td><td>Text</td></tr><tr><td>秒</td><td>Text</td></tr><tr><td>初始坐标</td><td>Vector2</td></tr><tr><td>目标地点</td><td>GameObject</td></tr></tbody></table><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//交互内容：开启时间计时</span></span><br><span class="line">        <span class="keyword">if</span>(isCount)</span><br><span class="line">        &#123;</span><br><span class="line">            timeCount -= Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算分钟和秒数</span></span><br><span class="line">            minuteForCount = Mathf.FloorToInt(timeCount / <span class="number">60</span>);</span><br><span class="line">            secForCount = Mathf.FloorToInt(timeCount % <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">            minText.text = minuteForCount.ToString();</span><br><span class="line">            secText.text = secForCount.ToString();</span><br><span class="line">            <span class="keyword">if</span> (timeCount &lt;= <span class="number">0.0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计时器到达零，执行失败操作</span></span><br><span class="line">                isCount = <span class="literal">false</span>;</span><br><span class="line">                timeCanvas.enabled = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来还要标出目的地点，可以通过绑定容器的方式来进行启用，失败时则关闭（gameObject.SetActive(true&#x2F;false)）</p><p>实现交互接口的内容，方便玩家绑定的脚本进行交互</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       startCount();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCount</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="comment">//重新挑战初始化倒计时    </span></span><br><span class="line">       timeCount = <span class="number">100f</span>;</span><br><span class="line">       currentPos = character.transform.position;</span><br><span class="line">       <span class="comment">//开启目标点</span></span><br><span class="line">       targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">       IsCount = <span class="literal">true</span>;</span><br><span class="line">       timeCanvas.enabled = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="挑战结果"><a href="#挑战结果" class="headerlink" title="挑战结果"></a>挑战结果</h3><p><strong>若成功：</strong>完成挑战，可以给予奖励或者出现一个宝箱</p><ul><li>给予奖励（前置：背包系统(√)）</li><li>出现宝箱（前置：宝箱界面(类似背包)）（未实现）</li></ul><p>流程为</p><p><strong>玩家到达目的地 → 倒计时板关闭 → 生成挑战结果</strong>(待定)</p><p>要先在目标点设置可以检测的内容(GUI内容实现)，为其定义一个脚本，方便在该位置来取消倒计时板关闭以及完成后续其他奖励内容操作</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(collision.transform.parent.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           Debug.Log(<span class="string">&quot;玩家已到达&quot;</span>);</span><br><span class="line">           countObj.GetComponent&lt;Stone3UI&gt;().IsCount = <span class="literal">false</span>;</span><br><span class="line">           targetCanvas.enabled = <span class="literal">false</span>;</span><br><span class="line">           Destroy(transform.gameObject);</span><br><span class="line">           <span class="meta">#奖励内容(待定)#</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>若失败：</strong>没有在规定时间内完成，返回起点，可以选择重新开始</p><p>原先的时间挑战开启的脚本要进行一定的修改，要添加能够绑定玩家初始位置的属性，同时还要在每次开启挑战时候初始化倒计时的时间</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录玩家初始位置</span></span><br><span class="line"><span class="keyword">private</span> Vector2 currentPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(IsCount)</span><br><span class="line">      &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (timeCount &lt;= <span class="number">0.0f</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 计时器到达零，执行失败操作</span></span><br><span class="line">              ...</span><br><span class="line">              <span class="comment">//把玩家返回到起点</span></span><br><span class="line">              character.transform.position = currentPos;</span><br><span class="line">              <span class="comment">//关闭目标点</span></span><br><span class="line">              targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCount</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      timeCount = <span class="number">100f</span>;</span><br><span class="line">    <span class="comment">//记录玩家起始位置</span></span><br><span class="line">      currentPos = character.transform.position;</span><br><span class="line">      <span class="comment">//开启目标点</span></span><br><span class="line">      targetPoint.SetActive(<span class="literal">true</span>);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="补充-多个时间挑战"><a href="#补充-多个时间挑战" class="headerlink" title="补充:多个时间挑战"></a>补充:多个时间挑战</h3><p>描述：若该场景下有多个时间挑战的柱子，不同柱子相同挑战但是最终的目的地不同</p><p>首先要定义好各个时间挑战的倒计时时间，同时在开启挑战的时候赋值给初始化的总计时</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前柱子设置的挑战时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> currentTime;</span><br></pre></td></tr></table></figure><p>另外一个是要定义好新的目的地(预制体&#x2F;新容器)，让其脚本绑定对应挂钩的时间挑战的柱子即可</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20240305211900320.png" alt="image-20240305211900320"></p><h2 id="细节调整"><a href="#细节调整" class="headerlink" title="细节调整"></a>细节调整</h2><p>1、时间竞赛中，如果玩家到达目标点，目标点应该顺便销毁</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(collision.transform.parent.gameObject.CompareTag(<span class="string">&quot;Player&quot;</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           ...</span><br><span class="line">           Destroy(transform.gameObject);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>2、系列挑战若为一次性挑战，则要考虑到当玩家完成该挑战时，该挑战不再可以被互动</p><p>方法：由于玩家与不同挑战的交互主要是通过该挑战容器对应的<code>Tag</code>来进行检测是否可以互动，所以只要在挑战结束后对其<code>Tag</code>进行更改即可：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gameObject.tag = <span class="string">&quot;XXX&quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="任务触发-准备ing-▲"><a href="#任务触发-准备ing-▲" class="headerlink" title="任务触发(准备ing)▲"></a>任务触发(准备ing)▲</h1><p>描述：角色在指定位置进行交互，触发要进行的任务，任务可以有多个，完成几个任务后完成解锁条，解锁条达成后开启门扉，可以进入下一关</p><h1 id="额外：多个一样的挑战内容-脚本能力"><a href="#额外：多个一样的挑战内容-脚本能力" class="headerlink" title="额外：多个一样的挑战内容(脚本能力)"></a>额外：多个一样的挑战内容(脚本能力)</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2D俯视游戏开发（一）</title>
      <link href="/2023/12/03/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/12/03/2D%E4%BF%AF%E8%A7%86%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="俯视视角下人物的移动"><a href="#俯视视角下人物的移动" class="headerlink" title="俯视视角下人物的移动"></a>俯视视角下人物的移动</h1><p>在2D俯视视角进行游戏创作，人物的移动应该要根据玩家操控的上下左右进而完成动画的变更与移动的实现</p><p>首先是动画的切换：</p><p>动画主要可以采取树(Bland Tree)的方式，通过设置x轴和y轴的数值(float或int类型)，由两种数值进行动画的切换</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231204110032376.png" alt="image-20231204110032376"></p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231204105941308.png" alt="image-20231204105941308"></p><p>其次是运动的实现：</p><p>运动的实现需要有几个步骤</p><ul><li>获取键盘输入</li><li>数值传递切换移动方向</li><li>移动方向施加力</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取横轴</span></span><br><span class="line">    <span class="built_in">float</span> PosX = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="comment">//获取纵轴</span></span><br><span class="line">    <span class="built_in">float</span> PosY = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    <span class="comment">//动画切换</span></span><br><span class="line">    <span class="keyword">if</span>(PosX != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, PosX);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(PosY != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosY&quot;</span>, PosY);</span><br><span class="line">        animator.SetFloat(<span class="string">&quot;PosX&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动方向归一化(-1 0 1)</span></span><br><span class="line">    Vector2 dir = <span class="keyword">new</span> Vector2(PosX, PosY).normalized;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        animator.SetBool(<span class="string">&quot;Run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//Move(dir);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (dir.x != <span class="number">0</span> &amp;&amp; dir.y != <span class="number">0</span>) rb.velocity = dir * <span class="number">0.25f</span>;</span><br><span class="line">    <span class="keyword">else</span> rb.velocity = dir * <span class="number">0.3f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中通过<code>Input.GetAxisRaw</code>来获取键盘的输入：</p><p><img src="/./../../../typora-images/image-20231204111356029-1701675525882-4.png" alt="image-20231204111356029"></p><p>另外一种移动方式也可以通过采用**rb.velocity &#x3D; new Vector2(dir.x * speed * Time.deltaTime, 0)**来实现</p><p>这样就完成了俯视视角下人物的移动</p><h2 id="人物的物理检测"><a href="#人物的物理检测" class="headerlink" title="人物的物理检测"></a>人物的物理检测</h2><p>人物的移动在遇到障碍物或地图场景边缘受到阻碍，从而无法跨越</p><ul><li><strong>人物添加碰撞体</strong></li></ul><p>碰撞体添加后，还有细节要进行处理，在人物的刚体组件中，要锁定Z轴让其不变，否则会发生碰撞的时候人物Z轴发生变化而导致旋转</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231205103440059.png" alt="image-20231205103440059"></p><ul><li><strong>人物检测碰撞物体</strong></li></ul><p>通过<code>Physics2D.OverlapXX</code>检查碰撞体是否在XX区域内</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     isHit = Physics2D.OverlapCircle(transform.position,<span class="number">0.2f</span>,layer);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231205141314868.png" alt="image-20231205141314868"></p><p>同时可以采用<code>Gizmos.DrawXX</code>方式来可视化检测的范围</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position+bottomOffset, <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="角色穿树透明化"><a href="#角色穿树透明化" class="headerlink" title="角色穿树透明化"></a>角色穿树透明化</h1><p>描述：人物经过树时，树会遮挡人物，但要让树半透明化，使人物能够被看到</p><p>角色穿树主要有几个步骤：</p><ul><li><p>图层覆盖</p></li><li><p>树检测人物</p></li><li><p>更改树贴图</p><ul><li>树上层</li><li>树下层</li></ul></li></ul><p>碰撞体与碰撞体之间的相互接触通过<code>OnTriggerEnter2D</code>来实现检测</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231206110513710.png" alt="image-20231206110513710"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件下所有子组件对应的贴图组件</span></span><br><span class="line"> <span class="keyword">private</span> List&lt;SpriteRenderer&gt; trees = <span class="keyword">new</span> List&lt;SpriteRenderer&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     </span><br><span class="line">     trees.Add(transform.GetChild(<span class="number">0</span>).GetComponent&lt;SpriteRenderer&gt;());</span><br><span class="line">     trees.Add(transform.GetChild(<span class="number">1</span>).GetComponent&lt;SpriteRenderer&gt;());</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//Debug.Log(LayerMask.LayerToName(collision.gameObject.layer));</span></span><br><span class="line">     <span class="keyword">if</span>(LayerMask.LayerToName(collision.gameObject.layer) == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">         changeTransparency(trees);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (LayerMask.LayerToName(collision.gameObject.layer) == <span class="string">&quot;Player&quot;</span>)</span><br><span class="line">         reverseTransparency(trees);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//树叶透明化</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeTransparency</span>(<span class="params">List&lt;SpriteRenderer&gt; sprite</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;sprite.Count;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         sprite[i].color = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5f</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseTransparency</span>(<span class="params">List&lt;SpriteRenderer&gt; sprite</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sprite.Count; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         sprite[i].color = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>树叶的透明化通过贴图颜色的更改即可实现，除了三元色之外，A对应的数值就是调整透明度</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231206110824400.png" alt="image-20231206110824400"></p><h1 id="传送石进行传送▲"><a href="#传送石进行传送▲" class="headerlink" title="传送石进行传送▲"></a>传送石进行传送▲</h1><p>描述：角色在指定传送石位置时弹出交互按键，玩家按下对应的按键后会传送到达指定位置</p><h2 id="触发交互按钮"><a href="#触发交互按钮" class="headerlink" title="触发交互按钮"></a>触发交互按钮</h2><p>交互按钮的图片材质可以选择挂载到角色身上，然后为其他需要进行交互的物体设置好对应的<strong>Tag</strong>标签，可以方便后续直接启用角色身上的交互</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子物体</span></span><br><span class="line"> <span class="keyword">public</span> GameObject obj;</span><br><span class="line"> <span class="comment">//子物体身上的动画</span></span><br><span class="line"> <span class="keyword">public</span> Animator animator;</span><br><span class="line"> <span class="comment">//是否开启子物体</span></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">bool</span> canPress;</span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">     canPress = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     obj.SetActive(canPress);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         canPress = <span class="literal">true</span>;</span><br><span class="line">         obj.SetActive(canPress);</span><br><span class="line">         animator.Play(<span class="string">&quot;StoneUI&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         canPress = <span class="literal">false</span>;</span><br><span class="line">         obj.SetActive(canPress);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过<code>CompareTag</code>方法来判断接触的物体是否具有对应的Tag标签</p><h2 id="按钮监听与交互的实现"><a href="#按钮监听与交互的实现" class="headerlink" title="按钮监听与交互的实现"></a>按钮监听与交互的实现</h2><p>当角色到达交互物品位置并按下按键，通过不同的交互物品来执行不同的交互事件，可以定义需要的接口，然后不同交互物品再实现不同的交互内容</p><p>通过事件的方式来进行不同物体接触后的交互，设置广播方和接收方，当广播方触及条件可以启动事件，在对事件进行绑定后，可以使得事件开启后执行被接触物体对应的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(canPress)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//传送交互</span></span><br><span class="line">          <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.E))</span><br><span class="line">          &#123;</span><br><span class="line">              other?.Invoke();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传送到达的地点</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Vector2 endPos;</span><br><span class="line"> <span class="comment">//传送的对象</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> GameObject player;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     endPos = <span class="keyword">new</span> Vector2(<span class="number">-4</span>, <span class="number">11</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (collision.transform.parent != <span class="literal">null</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//获取交互物体的父物体</span></span><br><span class="line">         player = collision.transform.parent.gameObject;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//实现交互功能</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">achieveEvent</span>()</span></span><br><span class="line"> &#123;</span><br><span class="line">     Debug.Log(endPos);</span><br><span class="line">     <span class="comment">//将玩家传送到指定目标点</span></span><br><span class="line">     player.transform.position = endPos;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过<code>collision.transform.parent</code>来获取当前物体身上的父物体</p><p><strong>PS：</strong>如果要实现多个传送柱子都有相同的方法，则可以设置为单例模式，从而使得不同的预制体要调用自己的内容时保持单一，而不会造成在另外一个物体上调用导致结果为null</p><h2 id="细节处理"><a href="#细节处理" class="headerlink" title="细节处理"></a>细节处理</h2><h3 id="柱子遮挡问题"><a href="#柱子遮挡问题" class="headerlink" title="柱子遮挡问题"></a>柱子遮挡问题</h3><p>在角色到达传送石柱时，由于俯视2D的特性，角色可以处于柱子四周位置，而此时要做到</p><ul><li>当角色在传送石柱上边时，柱子遮挡角色</li><li>当角色在传送石柱下边时，角色遮挡柱子</li></ul><p>通过人物坐标与柱子坐标的Y轴变化来切换柱子图层(Sorting in Layer)，进而修复该问题</p><p><img src="/./../images/2D%E4%BF%AF%E8%A7%86%E5%BC%80%E5%8F%91/image-20231208164057454.png" alt="image-20231208164057454"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(character.playerPos.y - transform.position.y &gt;= <span class="number">0</span> ) </span><br><span class="line">        &#123;</span><br><span class="line">            sprite.sortingLayerName = <span class="string">&quot;StoneBack&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            sprite.sortingLayerName = <span class="string">&quot;StoneFront&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="判定互动的调整"><a href="#判定互动的调整" class="headerlink" title="判定互动的调整"></a>判定互动的调整</h3><p>问题：</p><p>触发互动的方式主要是通过交互组件上的碰撞体与互动物品的碰撞体之间通过<code>Trigger</code>方式来判断的，这样会由于角色身上的交互组件碰撞体面积过长或者过宽，从而导致<strong>角色在交互物品下方一定距离就已经能够触发交互</strong>，所以最好是进行对判定互动的处理</p><p>碰撞体可以调整的数据主要有：</p><ul><li>Offset（偏移量）</li><li>Size（大小）</li></ul><p>基于此可以通过某个判定条件来调整碰撞体的整体框架，从而减少误差，让游戏互动符合实际要求，比如只有人物靠近交互物体才会触发互动</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">          </span><br><span class="line">      <span class="comment">//到达要互动的物品时，调整碰撞体大小和偏移量</span></span><br><span class="line">      <span class="keyword">if</span>(coll!=<span class="literal">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span> (canPress)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//人物在互动物品之下时</span></span><br><span class="line">              <span class="keyword">if</span>(coll.transform.position.y &gt; transform.position.y)</span><br><span class="line">              &#123;</span><br><span class="line">                  box.offset = <span class="keyword">new</span> Vector2(<span class="number">0</span>, <span class="number">0.1f</span>);</span><br><span class="line">                  box.size = <span class="keyword">new</span> Vector2(<span class="number">0.13f</span>, <span class="number">0.17f</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      coll = collision;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">true</span>;</span><br><span class="line">          StartCoroutine(waitForSecondOpen());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//开启互动时的携程</span></span><br><span class="line">  <span class="function">IEnumerator <span class="title">waitForSecondOpen</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line">      obj.SetActive(canPress);</span><br><span class="line">      animator.Play(<span class="string">&quot;StoneUI&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D collision</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (collision.CompareTag(<span class="string">&quot;Interactive&quot;</span>))</span><br><span class="line">      &#123;</span><br><span class="line">          canPress = <span class="literal">false</span>;</span><br><span class="line">          obj.SetActive(canPress);</span><br><span class="line">      &#125;</span><br><span class="line">      StartCoroutine(waitForSecondClose());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//关闭互动时的携程</span></span><br><span class="line">  <span class="function">IEnumerator <span class="title">waitForSecondClose</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.5f</span></span>)</span>;</span><br><span class="line">      box.offset = collOffset;</span><br><span class="line">      box.size = collSize;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过携程的方式设定延迟，避免在交互物品下某个位置时导致物体由于一直在原框架和修改框架来回切换从而让交互按钮一直处于显示状态</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity脚本</title>
      <link href="/2023/11/13/unity%E8%84%9A%E6%9C%AC/"/>
      <url>/2023/11/13/unity%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="2D应用"><a href="#2D应用" class="headerlink" title="2D应用"></a>2D应用</h1><h2 id="对象相关"><a href="#对象相关" class="headerlink" title="对象相关"></a>对象相关</h2><p>对象生成</p><ul><li>GameObject.Instantiate ： 单个对象生成</li></ul><p>  参数构成：</p><table><thead><tr><th>original</th><th>要复制的现有对象。</th></tr></thead><tbody><tr><td>position</td><td>新对象的位置。</td></tr><tr><td>rotation</td><td>新对象的方向。</td></tr><tr><td>parent</td><td>将指定给新对象的父对象。</td></tr><tr><td>instantiateInWorldSpace</td><td>When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.</td></tr></tbody></table><h2 id="脚本API相关"><a href="#脚本API相关" class="headerlink" title="脚本API相关"></a>脚本API相关</h2><h3 id="InvokeRepeating"><a href="#InvokeRepeating" class="headerlink" title="InvokeRepeating"></a>InvokeRepeating</h3><p>方法循环调用 —— <strong>InvokeRepeating</strong></p><p>public void <strong>InvokeRepeating</strong> (string <strong>methodName</strong>, float <strong>time</strong>, float <strong>repeatRate</strong>);</p><p>描述：</p><p>在 <code>time</code> 秒后调用 <code>methodName</code> 方法，然后每 <code>repeatRate</code> 秒调用一次。</p><h3 id="OnMouseDown"><a href="#OnMouseDown" class="headerlink" title="OnMouseDown"></a>OnMouseDown</h3><p>鼠标点击事件 —— <strong>OnMouseDown</strong></p><h3 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h3><p>位移方法 —— <strong>Translate</strong></p><p>参数：</p><ul><li>plane  ———— 平移后的平面</li><li><strong>translation</strong> ———— 在空间中用于移动平面的偏移</li></ul><p>描述：</p><p>在空间中按 <code>translation</code> 矢量移动平面</p><h3 id="Camera-main-ScreenToWorldPoint"><a href="#Camera-main-ScreenToWorldPoint" class="headerlink" title="Camera.main.ScreenToWorldPoint"></a>Camera.main.ScreenToWorldPoint</h3><p>描述：</p><p>将点从屏幕空间变换为世界空间。其中，世界空间定义为位于游戏层级视图最顶层的坐标系统。</p><p>即使以离屏坐标的形式提供时，仍可计算世界空间坐标，例如，用于实例化靠近屏幕特定角的离屏对象。</p><p>屏幕空间以像素定义。屏幕的左下角为 (0,0)，右上角 为 (<a href="https://docs.unity3d.com/cn/current/ScriptReference/Camera-pixelWidth.html">pixelWidth</a>,<a href="https://docs.unity3d.com/cn/current/ScriptReference/Camera-pixelHeight.html">pixelHeight</a>)。z 位置为与摄像机的距离，采用世界单位。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector3 sunNum = Camera.main.ScreenToWorldPoint(UIManager.Instance.GetSunNumTextPos());</span><br></pre></td></tr></table></figure><p>该语句主要对应了幕布的模式，<strong>为了获取UI界面上对应位置的坐标并符合在游戏画面上，进行精确的转换</strong>，由于UI和游戏画面实际上在#Scene界面上相距很远，所以如果要在游戏实现某种动画或者某种效果移动到UI或者涉及到UI界面，此时就要根据我们幕布选择的OverLay模式来进行处理</p><p>PS：</p><p>如果将幕布的模式切换为Camera模式，则可以不用添加该代码进行转换，通过摄像机圈定范围，然后直接赋值即可</p><h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><ul><li>Color.Lerp</li></ul><p>public static <a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>Lerp</strong> (<a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>a</strong>, <a href="https://docs.unity3d.com/cn/current/ScriptReference/Color.html">Color</a> <strong>b</strong>, float <strong>t</strong>);</p><p>概述：在颜色 <code>a</code> 与 <code>b</code> 之间按 <code>t</code> 进行线性插值</p><table><thead><tr><th>a</th><th>颜色 a。</th></tr></thead><tbody><tr><td>b</td><td>颜色 b。</td></tr><tr><td>t</td><td>用于组合 a 和 b 的浮点数。</td></tr></tbody></table><h2 id="包、类、接口相关"><a href="#包、类、接口相关" class="headerlink" title="包、类、接口相关"></a>包、类、接口相关</h2><h3 id="EventSystems"><a href="#EventSystems" class="headerlink" title="EventSystems"></a>EventSystems</h3><p>c#脚本中，可以通过<code>using UnityEngine.EventSystems;</code>来使用EventSystems包内相关内容</p><p>鼠标移入移出的接口事件：IPointerEnterHandler,IPointerExitHandler</p><p>要实现的接口内容：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//鼠标移入</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerEnter</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//鼠标移除</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerExit</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/03/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><p>回溯算法适用的几个类型题目：</p><ul><li><p><strong>组合问题</strong></p><ul><li>组合问题要注意：<strong>组合本身意味着不同顺序代表的是同一个组合</strong>（eg： (2,5)和(5,2)是同一个组合）</li></ul></li><li><p><strong>分割问题</strong></p></li><li><p><strong>子集问题</strong></p></li><li><p><strong>排列问题</strong></p></li><li><p><strong>棋盘问题</strong></p></li></ul><p><strong>回溯三部曲：</strong></p><ul><li><strong>递归函数参数返回</strong></li><li><strong>确定终止条件</strong></li><li><strong>单层递归逻辑</strong></li></ul><p>回溯算法的遍历过程：</p><ul><li>回溯搜索的遍历过程</li></ul><p>在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p><p>如图：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20210130173631174.png" alt="回溯算法理论基础"></p><p><strong>回溯算法模板：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剪枝优化：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;= n - (k-peth.<span class="built_in">size</span>())+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    peth.<span class="built_in">push</span>(i);<span class="comment">//加入集合</span></span><br><span class="line">    递归循环</span><br><span class="line">    回溯撤回</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组问题"><a href="#数组问题" class="headerlink" title="数组问题"></a>数组问题</h2><p>题目：<a href="https://leetcode.cn/problems/combinations/">https://leetcode.cn/problems/combinations/</a></p><p>把组合问题抽象为如下树形结构：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png" alt="77.组合"></p><p>可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。</p><p>第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围</strong>。</p><p><strong>图中可以发现n相当于树的宽度，k相当于树的深度</strong>。</p><p>那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果</strong>。</p><p>相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合</p><p>解题思路：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF</a></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result; <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path; <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n;i++) &#123; <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点</span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>); <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版本：</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>题目链接：<a href="https://leetcode.cn/problems/combinations/description/">https://leetcode.cn/problems/combinations/description/</a></p><h3 id="组合总和-III"><a href="#组合总和-III" class="headerlink" title="组合总和 III"></a>组合总和 III</h3><p>题目：<a href="https://leetcode.cn/problems/combination-sum-iii/">https://leetcode.cn/problems/combination-sum-iii/</a></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975.png" alt="216.组合总和III"></p><p>解题思路：<a href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html#%E6%80%9D%E8%B7%AF</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;sumTarget&quot;&gt;目标和&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;k&quot;&gt;k个数&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;sum&quot;&gt;辅助求和&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;startIndex&quot;&gt;辅助下标&lt;/param&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> sumTarget,<span class="type">int</span> k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>()==k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sumTarget == sum) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">backtracking</span>(sumTarget,k,sum,i+<span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销</span></span><br><span class="line">        sum -= i;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和为n，个数为k</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化版本：</p><h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><p>题目：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p><p>解题思路：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png" alt="17. 电话号码的字母组合"></p><p><strong>数字和字母如何映射：</strong></p><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">string s;<span class="comment">//存储单个结果(集合)</span></span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 0</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>, <span class="comment">// 1</span></span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">// 2</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>, <span class="comment">// 3</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>, <span class="comment">// 4</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>, <span class="comment">// 5</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>, <span class="comment">// 6</span></span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>, <span class="comment">// 7</span></span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>, <span class="comment">// 8</span></span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>, <span class="comment">// 9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits,<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index==digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数字变成对应的字符串集</span></span><br><span class="line">    <span class="type">int</span> digit = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    string letter = letterMap[digit];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; letter.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">        s.<span class="built_in">push_back</span>(letter[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,index+<span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(digits, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h3><p>题目：<a href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p><p>解题思路同组合总和 III</p><p>PS：该题目是可以重复拿取的，所以在纵向遍历的时候<strong>从i开始而不用再从i+1开始</strong>遍历</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> target,vector&lt;<span class="type">int</span>&gt;&amp; k,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; k.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        sum += k[i];</span><br><span class="line">        path.<span class="built_in">push_back</span>(k[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(target,k,sum,i); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">//回溯，撤销处理结果</span></span><br><span class="line">        sum -= k[i];</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtracking</span>(target, candidates, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶版：组合总和II <a href="https://leetcode.cn/problems/combination-sum-ii/description/">https://leetcode.cn/problems/combination-sum-ii/description/</a></p><p>该题涉及到<strong>去重处理</strong>，具体详解内容参考代码随想录的文章：</p><p><a href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html#%E6%80%9D%E8%B7%AF</a></p><p>涉及到去重的两种情况：<strong>树枝去重（递归）、树层去重（for循环）</strong></p><h2 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h2><p>题目链接：<a href="https://leetcode.cn/problems/subsets/description/">https://leetcode.cn/problems/subsets/description/</a></p><p>子集问题相当于把每个遍历过的节点都能作为该集合的子集，代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> startIndex)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (startIndex == nums.<span class="built_in">size</span>())</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">       &#123;</span><br><span class="line">           path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">           result.<span class="built_in">push_back</span>(path);</span><br><span class="line">           <span class="built_in">backtracking</span>(nums, i);</span><br><span class="line">           path.<span class="built_in">pop_back</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进阶版本：子集II<a href="https://leetcode.cn/problems/subsets-ii/description/">https://leetcode.cn/problems/subsets-ii/description/</a></p><p>本质上同组合总和的进阶版(II)一样，区别在于多了一个去重的操作，去重操作也和之前一样，要注意什么时候表示树枝去重(used[i-1]&#x3D;true)，什么时候表示树层去重(used[i-1]&#x3D;false)</p><p>具体去重的讲解参考组合总和II即可</p><p>需要注意的是：<strong>去重操作一般要先对初始数组进行排序</strong>(sort)</p><h2 id="非递减子序列"><a href="#非递减子序列" class="headerlink" title="非递减子序列"></a>非递减子序列</h2><p>题目链接：<a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">https://leetcode.cn/problems/non-decreasing-subsequences/description/</a></p><p>该题和子集进阶很像，但是实际上区别很大：</p><p>一个是初始数组被固定，无法排序，这意味着去重操作也不一样</p><p>该题的去重虽然仍是树层去重，但是却不能用used数组的方式来进行排序后去重的操作</p><p>而是采用了无序容器unordered set来进行重复标记</p><p><code>std::unordered_set</code>是一种无序集合容器，它提供了快速的查找操作。查找元素时，通常使用<code>find</code>成员函数，<strong>如果找到了元素，它会返回一个指向该元素的迭代器；如果没有找到，它会返回一个指向容器<code>end</code>的迭代器</strong></p><h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>题目：<a href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p><p>解题思路：<a href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF</a></p><p>皇后们的约束条件：</p><ol><li>不能同行</li><li>不能同列</li><li>不能同斜线</li></ol><p>验证棋盘是否合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS: 不需要在检查行的原因是在单层搜索的过程中，每一层递归，只会选for循环（也就是同一行）里的一个元素，所以不用去重了</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line"><span class="comment">/* 检测棋盘是否合法：</span></span><br><span class="line"><span class="comment">1. 不能同行</span></span><br><span class="line"><span class="comment">2. 不能同列</span></span><br><span class="line"><span class="comment">3. 不能同斜线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;string&gt;&amp; chessboard, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123; <span class="comment">// 这是一个剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 45度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 135度角是否有皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chessboard[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    回溯算法：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//n —— 棋盘大小</span></span><br><span class="line"><span class="comment">//row —— 当前所在棋盘第row行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n,vector&lt;string&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(chessboard);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层遍历，内层递归</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n;col++) &#123;</span><br><span class="line">        <span class="comment">//验证是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(row, col, chessboard, n)) </span><br><span class="line">        &#123;</span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(row+<span class="number">1</span>,n,chessboard); <span class="comment">// 递归</span></span><br><span class="line">            chessboard[row][col] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">chessboard</span><span class="params">(n, std::string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(<span class="number">0</span>, n, chessboard);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/27/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>题目链接：<a href="https://leetcode.cn/problems/wiggle-subsequence/description/">https://leetcode.cn/problems/wiggle-subsequence/description/</a></p><p>分析：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20201124174327597.png" alt="376.摆动序列"></p><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong></p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p>本题要考虑三种情况：</p><ol><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ol><p>具体讲解看：<a href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html#%E6%80%9D%E8%B7%AF</a></p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">       <span class="type">int</span> pref = <span class="number">0</span>, curf = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">           考虑到：</span></span><br><span class="line"><span class="comment">           情况一：上下坡中有平坡</span></span><br><span class="line"><span class="comment">           情况二：数组首尾两端</span></span><br><span class="line"><span class="comment">           情况三：单调坡中有平坡</span></span><br><span class="line"><span class="comment">       </span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           curf = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">           <span class="keyword">if</span> (pref &lt;= <span class="number">0</span> &amp;&amp; curf &gt; <span class="number">0</span> || pref &gt;= <span class="number">0</span> &amp;&amp; curf &lt; <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               result++;</span><br><span class="line">               pref = curf;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>题目链接：<a href="https://leetcode.cn/problems/maximum-subarray/description/">https://leetcode.cn/problems/maximum-subarray/description/</a></p><p>贪心思路：</p><p>累加之和 + nums[i] &#x3D; 新的累加之和</p><p>最优情况下意味着累加之和不应该 &lt; 0，这样会让nums[i]的数值也降低</p><p>代码尝试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>, maxx = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (maxx &lt; sum)</span><br><span class="line">                maxx = sum;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity内容整理</title>
      <link href="/2023/10/26/unity%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
      <url>/2023/10/26/unity%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="事件方法-委托"><a href="#事件方法-委托" class="headerlink" title="事件方法(委托)"></a>事件方法(委托)</h1><p>以一个例子来理解：</p><p>当场景生成阳光，玩家点击阳光后更新阳光数量，此时植物卡牌会根据当前阳光数量来刷新状态（有阳光有CD、有阳光无CD、无阳光有CD、无阳光无CD）</p><p>其中充当该功能实现的有两个类，在此期间使用了<strong>委托</strong>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PlayerManager Instance;</span><br><span class="line">    <span class="comment">//阳光的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> sunNum;</span><br><span class="line">    <span class="comment">//阳光数量更新事件</span></span><br><span class="line">    <span class="keyword">private</span> UnityAction sunUpdateAction;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SunNum = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> SunNum</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; sunNum;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            sunNum = <span class="keyword">value</span>;</span><br><span class="line">            UIManager.Instance.UpdateSunNum(sunNum);</span><br><span class="line">            sunUpdateAction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阳光数量更新事件监听器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddSunNumUpdateActionListener</span>(<span class="params">UnityAction action</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        sunUpdateAction += action;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>PlayerManager</code> 类中，<code>AddSunNumUpdateActionListener</code> 方法允许其他模块注册一个方法（通过 <code>UnityAction</code> 委托表示）。这个方法会在 <code>PlayerManager</code> 中的 <code>sunUpdateAction</code> 委托被调用时执行</p><p>另外一个类的实现该功能的部分代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIPlantCard</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerEnterHandler</span>,<span class="title">IPointerExitHandler</span>,<span class="title">IPointerClickHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//种植需要消耗的阳光</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> costSun;</span><br><span class="line">    <span class="comment">//冷却时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> CDTime;</span><br><span class="line">    <span class="comment">//当前时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currentTimeForCd;</span><br><span class="line">    <span class="comment">//植物CD是否转好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canPlace;</span><br><span class="line">    <span class="comment">//当前卡片所对应的植物类型</span></span><br><span class="line">    <span class="keyword">public</span> PlantType CardPlantType;</span><br><span class="line">    <span class="comment">//当前植物卡片的状态</span></span><br><span class="line">    <span class="keyword">private</span> CardState cardState = CardState.NotAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerManager.Instance.AddSunNumUpdateActionListener(CheckState);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有CD 有阳光</span></span><br><span class="line">        <span class="keyword">if</span> (canPlace &amp;&amp; PlayerManager.Instance.SunNum &gt;= costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.CanPlace;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有CD 有阳光</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!canPlace &amp;&amp; PlayerManager.Instance.SunNum &gt;= costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotCD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有CD 没有阳光</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (canPlace &amp;&amp; PlayerManager.Instance.SunNum &lt; costSun)</span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotSun;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有CD 没有阳光</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CardState = CardState.NotAll;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PlayerManager.Instance.AddSunNumUpdateActionListener(CheckState)</code>意味着 <code>CheckState</code> 方法被注册到了 <code>PlayerManager</code> 中的 <code>sunUpdateAction</code> 委托中。</p><p>因此，每当 <code>PlayerManager.Instance.SunNum</code> 的值发生变化，并且 <code>sunUpdateAction</code> 被调用时，<code>CheckState</code> 方法会被执行。</p><p>总体流程为：</p><ol><li>在游戏开始时，<code>PlayerManager</code> 的 <code>Awake</code> 方法中会将 <code>sunUpdateAction</code> 委托初始化为空。</li><li>在 <code>Start</code> 方法中，<code>UIPlantCard</code>通过 <code>AddSunNumUpdateActionListener</code> 将 <code>CheckState</code> 方法注册到了 <code>sunUpdateAction</code> 委托中。</li><li>当 <code>PlayerManager.Instance.SunNum</code> 的值发生变化时，<code>PlayerManager</code> 中的 <code>SunNum</code> 的 <code>set</code> 访问器被调用。</li><li>在 <code>set</code> 访问器中，<code>sunUpdateAction()</code> 被调用，触发了 <code>sunUpdateAction</code> 委托。</li><li>因为 <code>CheckState</code> 方法已经被注册到 <code>sunUpdateAction</code> 委托中，所以 <code>CheckState</code> 方法被执行。</li></ol><h1 id="事件方法-UnityEvent"><a href="#事件方法-UnityEvent" class="headerlink" title="事件方法(UnityEvent)"></a>事件方法(UnityEvent)</h1><h1 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h1><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><p><img src="/./../images/unity%E6%80%BB%E7%BB%93(1)/image-20231102143428511.png" alt="image-20231102143428511"></p><ul><li><p>Source Image</p></li><li><p>Color(&amp; Material)</p></li><li><p>Raycast -XX</p><ul><li><strong>Raycast Target</strong></li><li>Raycast Padding</li></ul></li><li><p><strong>Image Type</strong></p></li></ul><h3 id="Image-Type"><a href="#Image-Type" class="headerlink" title="Image Type"></a>Image Type</h3><ul><li>Simple</li><li>Sliced</li><li>Tiled</li><li>Filled</li></ul><p><code>Filled</code>类型含有的参数内容：</p><p>Fill Method —— 变化的类型</p><p>Fill Origin —— 起始位置</p><p>Fill Amount —— 变化的数值</p><p>Preserve Aspect</p><h2 id="Horizontal-Layout-Group"><a href="#Horizontal-Layout-Group" class="headerlink" title="Horizontal Layout Group"></a>Horizontal Layout Group</h2><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><ul><li><p>Render Mode</p><ul><li>Overlay模式</li><li>Camera模式</li><li>World Space</li></ul></li></ul><h1 id="携程-IEnumerator"><a href="#携程-IEnumerator" class="headerlink" title="携程(IEnumerator)"></a>携程(IEnumerator)</h1><h1 id="枚举-Enum"><a href="#枚举-Enum" class="headerlink" title="枚举(Enum)"></a>枚举(Enum)</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十四）</title>
      <link href="/2023/10/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/10/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十四"><a href="#Unity开发日记-十四" class="headerlink" title="Unity开发日记(十四)"></a>Unity开发日记(十四)</h1><h2 id="暂停面板以及声音控制"><a href="#暂停面板以及声音控制" class="headerlink" title="暂停面板以及声音控制"></a>暂停面板以及声音控制</h2><p>在unity界面上创建<code>Panel</code>容器：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164208317.png" alt="image-20231025164208317"></p><p>然后在该容器下创建滑动条容器<code>Slider</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164508062.png" alt="image-20231025164508062"></p><p>通过滑条的该位置来调整数值，同时还能添加事件，从而实现我们通过滑条来修改游戏音乐：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025164733362.png" alt="image-20231025164733362"></p><p>回到unity界面上调出音频设置：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165126484.png" alt="image-20231025165126484"></p><p>此时可以观察到之前设置的音频内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165152780.png" alt="image-20231025165152780"></p><p>同时为了能够实现通过滑条来控制音量，则音频设置需要有暴露参数让其可以通过数值来修改音量：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025173033444.png" alt="image-20231025173033444"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165506338.png" alt="image-20231025165506338"></p><p>在<code>Audio Mixer</code>下能够查看到我们暴露出来的参数，可以为其重命名方便管理</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165616087.png" alt="image-20231025165616087"></p><p>接着在音量控制脚本<code>AudioManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025165920483.png" alt="image-20231025165920483"></p><p>为了让音量控制脚本能够得到音量调整的参数(float类型)，所以在事件脚本文件夹·<code>ScriptableObject</code>下创建传递Float参数的事件<code>FloatEventSO</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170316910.png" alt="image-20231025170316910"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170750720.png" alt="image-20231025170750720"></p><p>然后回到unity界面中，先在事件文件下创建该Float类型的事件，然后将其在滑动条容器下的事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025170908332.png" alt="image-20231025170908332"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171047947.png" alt="image-20231025171047947"></p><p>然后再次回到音量控制脚本<code>AudioManager</code>下进行修改，添加监听事件与要实现监听后的方法：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171442073.png" alt="image-20231025171442073"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171503797.png" alt="image-20231025171503797"></p><p>回到unity界面，检查可以发现，滑动条可以移动传递的float类型是在0-1之间，而音量的调整缺有-80-20之间，所以代码位置还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025171611696.png" alt="image-20231025171611696"></p><p>最后在unity界面为音量监听组件重新绑定事件，然后进行测试</p><p>设计可以打开设置界面的按钮，从而使得通过点击设置按钮来启动暂停面板并可以进行调控音量的操作：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025173553452.png" alt="image-20231025173553452"></p><p>也就是通过设置按钮(Button)容器来启动暂停面板容器(Pause Panel)的开关</p><p>所以要先到UI控制脚本<code>UIManager</code>上进行内容的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174217025.png" alt="image-20231025174217025"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174232573.png" alt="image-20231025174232573"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174256236.png" alt="image-20231025174256236"></p><p>回到unity界面为UI管理脚本绑定相应的内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174543176.png" alt="image-20231025174543176"></p><p>最后设计游戏暂停，只要在UI管理脚本<code>UIManager</code>下让暂停面板弹出的代码部分添加时间相关内容即可：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025174857935.png" alt="image-20231025174857935"></p><p>优化：当开启暂停时，当前音量值多少也会反向传递给滑动条</p><p>首先创建一个相同的需要float类型的事件<code>SyncVolume Event</code>，同时还要再创建一个无参的暂停广播事件<code>Pause Event</code>，然后在UI控制脚本<code>UIManager</code>下修改：</p><ul><li>广播事件</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025184712982.png" alt="image-20231025184712982"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025184737615.png" alt="image-20231025184737615"></p><ul><li>监听事件</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185840246.png" alt="image-20231025185840246"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185945977.png" alt="image-20231025185945977"></p><p>然后回到音量控制脚本<code>AudioManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185428015.png" alt="image-20231025185428015"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025185554274.png" alt="image-20231025185554274"></p><p>更改完成两个脚本后再回到unity界面上分别进行事件的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190213371.png" alt="image-20231025190213371"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190314530.png" alt="image-20231025190314530"></p><p>最后回到界面管理脚本<code>UIManager</code>下完成监听内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190658416.png" alt="image-20231025190658416"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025190713913.png" alt="image-20231025190713913"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025190832856.png" alt="image-20231025190832856"></p><h2 id="打包生成游戏"><a href="#打包生成游戏" class="headerlink" title="打包生成游戏"></a>打包生成游戏</h2><h3 id="初始化场景"><a href="#初始化场景" class="headerlink" title="初始化场景"></a>初始化场景</h3><p>在unity界面上先创建一个空的场景，在空场景下再创建一个空容器，再创建一个初始化脚本<code>InitialLoad</code>并挂载到空容器上，编写脚本内容：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202028018.png" alt="image-20231025202028018"></p><p>然后回到unity界面上边绑定要初始化的场景：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202128179.png" alt="image-20231025202128179"></p><p>随后在File选项下选择Build Setting：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025202406579.png" alt="image-20231025202406579"></p><h3 id="Addressables资源打包"><a href="#Addressables资源打包" class="headerlink" title="Addressables资源打包"></a>Addressables资源打包</h3><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203311335.png" alt="image-20231025203311335"></p><ul><li>手动打包</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203354554.png" alt="image-20231025203354554"></p><ul><li>自动打包</li></ul><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203423332.png" alt="image-20231025203423332"></p><h3 id="最终打包细节设置"><a href="#最终打包细节设置" class="headerlink" title="最终打包细节设置"></a>最终打包细节设置</h3><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203620337.png" alt="image-20231025203620337"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203651456.png" alt="image-20231025203651456"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025203814817.png" alt="image-20231025203814817"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204009005.png" alt="image-20231025204009005"></p><p>经常会遇到的问题是，当我们打包游戏后，在实际游玩过程中会发现贴图有时候会有很小的缝隙，如何解决？</p><p>我们要把我们的图片素材也进行打包即可，首先在图片资源文件夹<code>Art Assets</code>下创建一个<code>Sprite Atlas</code>类型的：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204327276.png" alt="image-20231025204327276"></p><p>作用：可以把我们游戏的图片打包成一个图集，或者把游戏图片素材变成一张图片</p><p>将我们要用到的图片素材都打包过去：</p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025204818581.png" alt="image-20231025204818581"></p><p><img src="/./../images/unity(%E5%8D%81%E5%9B%9B)/image-20231025205245584.png" alt="image-20231025205245584"></p><p>完成后要记得把Addressable内容重新手动打包一次，最后再进行游戏打包</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十三）</title>
      <link href="/2023/10/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/"/>
      <url>/2023/10/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据保存和加载"><a href="#数据保存和加载" class="headerlink" title="数据保存和加载"></a>数据保存和加载</h1><h2 id="实现”新的游戏”逻辑"><a href="#实现”新的游戏”逻辑" class="headerlink" title="实现”新的游戏”逻辑"></a>实现”新的游戏”逻辑</h2><p>首先在场景脚本<code>SceneLoader</code>下进行细节的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151241508.png" alt="image-20231023151241508"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151507145.png" alt="image-20231023151507145"></p><p>同时代码也要进行修改，初始不是在第一个场景，而是在主场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023151803851.png" alt="image-20231023151803851"></p><p>接下来就是实现新游戏启动的逻辑：</p><p>首先在事件文件夹<code>Event</code>下创建一个新的无参事件<code>New Game Event</code>，然后将其绑定在“新的游戏”按钮容器下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152452993.png" alt="image-20231023152452993"></p><p>随后回到场景加载容器下场景加载脚本<code>SceneLoader</code>进行事件的监听并实现相关逻辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152831438.png" alt="image-20231023152831438"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152858595.png" alt="image-20231023152858595"></p><p>再次回到unity界面为其事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023152930155.png" alt="image-20231023152930155"></p><h3 id="加载场景过程中显示UI信息"><a href="#加载场景过程中显示UI信息" class="headerlink" title="加载场景过程中显示UI信息"></a>加载场景过程中显示UI信息</h3><p>先在事件文件夹下创建场景卸载事件<code>ScenUnloaded Event SO</code>，然后在UI界面控制容器的脚本组件下进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154008647.png" alt="image-20231023154008647"></p><p>然后在场景加载脚本<code>SceneLoad</code>下修改代码，使其在场景加载过程中(还是黑屏时)启用广播调整血条显示：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154512824.png" alt="image-20231023154512824"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023154543413.png" alt="image-20231023154543413"></p><h3 id="初始化玩家血量"><a href="#初始化玩家血量" class="headerlink" title="初始化玩家血量"></a>初始化玩家血量</h3><p>当进入新游戏时，要重新初始化玩家的血量(回满)，所以先回到角色容器下的角色属性脚本<code>Character</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023155935138.png" alt="image-20231023155935138"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160007417.png" alt="image-20231023160007417"></p><p>最后回到unity上，为角色人物，怪物等身上绑定有属性脚本的都把该事件进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160117495.png" alt="image-20231023160117495"></p><p>PS：</p><p>我们添加了 New Game 函数在 Character 代码中，仍然要在 Start 函数函数中给血量赋值。</p><p>**<code>character</code>**：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了敌人能在开始获得血量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    currentHealth = maxHealth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化选项"><a href="#初始化选项" class="headerlink" title="初始化选项"></a>初始化选项</h3><p>开始进行初始化前，首先要先了解当unity界面创建UI容器时自动创建的EventSystem容器的作用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161611097.png" alt="image-20231023161611097"></p><p>游戏主界面时，默认选项在开始游戏位置，其次可以通过键盘来直接控制上下的选项，首先先为几个选项按钮都进行设置，使其能够通过键盘来控制上下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023160822255.png" alt="image-20231023160822255"></p><p>所以我们要使得其游戏开始时默认就在第一个按钮位置，这样就能进行上下操作了</p><p>在UI文件夹下创建控制脚本<code>Menu</code>，并将其挂载到按键和文本的父容器上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161116384.png" alt="image-20231023161116384"></p><p>进行代码逻辑的编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161717359.png" alt="image-20231023161717359"></p><p>然后回到unity界面上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023161854539.png" alt="image-20231023161854539"></p><p>最后在代码中编写“退出”后的内容，实现当用户点击退出后，所有资源都进行关闭：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023162105858.png" alt="image-20231023162105858"></p><p>回到unity界面上，在退出按钮中进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023162353380.png" alt="image-20231023162353380"></p><h2 id="存档点以及画面效果"><a href="#存档点以及画面效果" class="headerlink" title="存档点以及画面效果"></a>存档点以及画面效果</h2><p>首先对图片素材进行调整并切割，以其中一个地形场景作为举例：</p><p>将岩石图片以及两张符文图片作为一个存档点来设计，先放置岩石，然后将符文图片作为子物体挂载到岩石图片上，同时为岩石添加碰撞体积组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023200643921.png" alt="image-20231023200643921"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023200919359.png" alt="image-20231023200919359"></p><p>同时设置图片的标签为可互动的标签：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202426382.png" alt="image-20231023202426382"></p><p>然后在脚本文件夹<code>Script</code>下创建加载保存文件夹<code>Save Load</code>，并创建相关的脚本<code>SavePoint</code>，然后挂载到岩石身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023201418282.png" alt="image-20231023201418282"></p><p>对该存档点脚本<code>SavePoint</code>进行代码编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202357676.png" alt="image-20231023202357676"></p><p>回到unity界面并进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023202601074.png" alt="image-20231023202601074"></p><p>其中，<code>Sprite Renderer</code>绑定它的子容器，也即：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023203226362.png" alt="image-20231023203226362"></p><p>最后测试发现其保存后还能继续交互，所以还要对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023203503450.png" alt="image-20231023203503450"></p><h3 id="画面灯光效果以及局部灯光效果"><a href="#画面灯光效果以及局部灯光效果" class="headerlink" title="画面灯光效果以及局部灯光效果"></a>画面灯光效果以及局部灯光效果</h3><p>在洞窟场景可以添加一个容器，为其添加一个灯光组件，通过灯光组件来使得场景画面有灯光的效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204009656.png" alt="image-20231023204009656"></p><p>大致画面效果为：<img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204023628.png" alt="image-20231023204023628"></p><p>然后为存档点的符文位置设置一个局部灯光亮点：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204221713.png" alt="image-20231023204221713"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204430175.png" alt="image-20231023204430175"></p><h3 id="实现后处理"><a href="#实现后处理" class="headerlink" title="实现后处理"></a>实现后处理</h3><p>在unity界面当前场景创建后加载容器<code>Global Volume</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204739565.png" alt="image-20231023204739565"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023204836644.png" alt="image-20231023204836644"></p><p>添加需要的管线内容，调整特效等内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205059146.png" alt="image-20231023205059146"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205138303.png" alt="image-20231023205138303"></p><p>曝光管线则是<code>Color Adjustments</code></p><p>同时要先回到主摄像机容器<code>Main Camera</code>下调整设置，使其生效：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023205304532.png" alt="image-20231023205304532"></p><p>然后回到存档点脚本里边重新调整代码，使其在角色存档后切换图片并使用如上的灯光效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023211911224.png" alt="image-20231023211911224"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023211931766.png" alt="image-20231023211931766"></p><p>然后回到unity界面上为其脚本内容绑定相关的灯光：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212042224.png" alt="image-20231023212042224"></p><p>再次创建一个新的后处理容器<code>Box Volume</code>，将其范围圈定在上边，使得人物在跳跃到上边场景时候能够提高场景亮度：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212745110.png" alt="image-20231023212745110"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023212824977.png" alt="image-20231023212824977"></p><p>PS：要想在unity界面上查看我们调整的画面效果，需要设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213101540.png" alt="image-20231023213101540"></p><p>通过观察可以发现我们刚设置的灯光没有起效，原因是该灯光特效与摄像机是存在距离的</p><p>在摄像机容器上可以发现其是三维坐标，z轴为距离10</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213405624.png" alt="image-20231023213405624"></p><p>而灯光特效本质也是一个立体特效，所以要考虑到距离，所以可以在该位置设置其起效的距离：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213331190.png" alt="image-20231023213331190"></p><h3 id="▲数据结构与坐标保存加载"><a href="#▲数据结构与坐标保存加载" class="headerlink" title="▲数据结构与坐标保存加载"></a>▲数据结构与坐标保存加载</h3><p>首先在事件管理文件夹<code>Event</code>下创建无参事件的数据存储事件<code>LoadGameData Event</code>，然后在存档点脚本<code>SavePoint</code>进行增添内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023213855167.png" alt="image-20231023213855167"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023214153801.png" alt="image-20231023214153801"></p><p>然后回到unity界面上进行事件的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231023214235955.png" alt="image-20231023214235955"></p><p>然后在存档点加载文件夹<code>Load Save</code>下创建一个存储接口<code>ISaveable</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024093517042.png" alt="image-20231024093517042"></p><p>然后接着创建一个数据存储和读取管理脚本<code>DataManager</code>，并在unity界面上创建对应的数据存储和管理容器，将该脚本挂载上去:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024093920049.png" alt="image-20231024093920049"></p><p>然后通过<strong>观察者模式（单例模式）</strong>来实现数据的统一存储与管理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024095231634.png" alt="image-20231024095231634"></p><p>创建存储列表，对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024100950361.png" alt="image-20231024100950361"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024101007886.png" alt="image-20231024101007886"></p><p>然后再修改存储数据接口<code>ISaveable</code>，在新版本c#中可以直接定义方法内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024095412392.png" alt="image-20231024095412392"></p><p>回到unity界面，在存档点加载文件夹下再创建一个保存的数据类<code>Data</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024102505990.png" alt="image-20231024102505990"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024102702476.png" alt="image-20231024102702476"></p><p>而由于传入的数据是键值对，所以要有一个标识来作为string类型以此区分不同对象的不同数据，这里就要用到<strong>全局唯一标识符（GUID）</strong>，回到存档点加载文件夹下创建数据描述定义脚本<code>DataDefinition</code>来生成GUID：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024103948990.png" alt="image-20231024103948990"></p><p><code>OnValidate()</code>它通常用于在编辑器时期执行操作，而不是在运行时。这意味着你可以在编辑器中进行属性的设置和验证，而不必等到运行游戏</p><p>通过挂载到角色或者怪物身上后，另外一个问题是游戏每次重开，该GUID都会发生变化，为了限制其变化，首先回到枚举脚本<code>Enums</code>下添加新的枚举类型：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104310902.png" alt="image-20231024104310902"></p><p>修改数据描述定义脚本<code>DataDefination</code>，然后将其挂载到角色&#x2F;怪物身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104730617.png" alt="image-20231024104730617"></p><p>接着回到存储接口中，添加获得键值的方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024104839014.png" alt="image-20231024104839014"></p><p>最后以将角色脚本信息传递过去来举例进行代码的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024105710389.png" alt="image-20231024105710389"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024105810736.png" alt="image-20231024105810736"></p><p>由于在接口中，注册与卸载方法我们直接写了方法内容，所以在其他类实现接口不会生成这两种方法，所以我们可以<strong>强制声明并让其执行一次</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024110303479.png" alt="image-20231024110303479"></p><p>这样就完成了<strong>对象的数据存储与数据传输</strong>，接下来就是要到数据管理器里获取数据并加载数据，所以回到数据管理脚本<code>DataManager</code>下进行代码的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024131943170.png" alt="image-20231024131943170"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132020760.png" alt="image-20231024132020760"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132108703.png" alt="image-20231024132108703"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024135410779.png" alt="image-20231024135410779"></p><p>回到unity界面下，在事件文件夹下创建新的无参数据加载事件<code>SavaDataEvent</code>，并将其分别绑定在存档点保存广播位置和主数据管理组件的监听位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024111014054.png" alt="image-20231024111014054"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024111043200.png" alt="image-20231024111043200"></p><p>同时为预制体中每个怪物都挂载上数据描述定义脚本:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024132616016.png" alt="image-20231024132616016"></p><p>最后测试加载保存数据是否成功，在数据管理脚本<code>DataManager</code>下修改测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024135923425.png" alt="image-20231024135923425"></p><h3 id="人物数值及场景的保存"><a href="#人物数值及场景的保存" class="headerlink" title="人物数值及场景的保存"></a>人物数值及场景的保存</h3><p>先在数据脚本<code>Data</code>下定义新的字典类型：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024141117380.png" alt="image-20231024141117380"></p><p>然后回到角色属性脚本<code>Character</code>下添加场景新的数据存储内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024142009658.png" alt="image-20231024142009658"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024142324898.png" alt="image-20231024142324898"></p><p>这样就完成了人物数值(生命、能量条)的保存</p><p>接下来要实现场景的保存，先在数据类中添加新的存储类型来存储场景，同时使用<strong>工厂模式</strong>进行内容的执行：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024144950038.png" alt="image-20231024144950038"></p><p>接着在场景加载脚本<code>SceneLoader</code>上进行增添，同时为场景加载容器添加<code>DataDefinition</code>组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024143853333.png" alt="image-20231024143853333"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024143934201.png" alt="image-20231024143934201"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024150827389.png" alt="image-20231024150827389"></p><p>这样就完成了场景数据存储的过程，接下来还要实现场景加载的过程，首先回到数据类添加反序列化内容从而能够传递旧的场景信息：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024150936281.png" alt="image-20231024150936281"></p><p>接着回到场景加载脚本<code>SceneLoader</code>下完成加载方法的功能：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024151039940.png" alt="image-20231024151039940"></p><p>对返回的坐标也要进行更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024151322128.png" alt="image-20231024151322128"></p><p>这样就完成了场景的加载</p><h2 id="游戏结束面板"><a href="#游戏结束面板" class="headerlink" title="游戏结束面板"></a>游戏结束面板</h2><p>在<code>Main Canvas</code>容器下创建<code>Panel</code>面板作为游戏结束面板</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024172718817.png" alt="image-20231024172718817"></p><p>设置需要的参数：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024172847866.png" alt="image-20231024172847866"></p><p>然后在该面板下再创建几个画布并命名调整排位：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174006768.png" alt="image-20231024174006768"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174022082.png" alt="image-20231024174022082"></p><p>然后为画布也添加对应的按钮并设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174335043.png" alt="image-20231024174335043"></p><ul><li><strong>“重新开始”功能</strong></li></ul><p>回到数据管理器脚本<code>DataManager</code>下设置监听事件并实现重新开始的功能：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174608124.png" alt="image-20231024174608124"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174623633.png" alt="image-20231024174623633"></p><p>同时还要为“重新开始”容器上绑定触发的事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024174748123.png" alt="image-20231024174748123"></p><p>随后还要考虑到角色死亡后触发的问题，也就是当人物死亡后要弹出来上边的游戏结束面板，可以在unity界面上直接进行修改：</p><p>在角色容器的角色属性组件下，可以通过死亡方法绑定对应的死亡面板容器并启用开关来达到这种效果</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024175031210.png" alt="image-20231024175031210"></p><p>为了使得人物死亡后探出游戏结束面板默认在重新开始位置，则要对代码进行修改，首先回到UI界面管理脚本<code>UIManager</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024180902857.png" alt="image-20231024180902857"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181026620.png" alt="image-20231024181026620"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181042839.png" alt="image-20231024181042839"></p><p>然后回到unity界面上进行绑定，在事件文件夹下再次创建游戏结束事件<code>GameOverEvent</code>，同时把人物容器的死亡事件绑定也更换为游戏结束事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024181524554.png" alt="image-20231024181524554"></p><p><img src="/./../../../typora-images/image-20231024195150166.png" alt="image-20231024195150166"></p><p>最后测试发现死亡重新开始后，人物动画没有发生变化，所以还要进行修改，在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200248392.png" alt="image-20231024200248392"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200308205.png" alt="image-20231024200308205"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024200322163.png" alt="image-20231024200322163"></p><p>这样就完成了重新开始的功能了</p><ul><li><strong>“离开”功能</strong></li></ul><p>接下来要对离开按钮设计相应的代码实现，首先在事件文件夹下创建离开事件<code>BackToMenu Event</code>并将其作为组件挂载在“离开”按钮容器上边：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024201205888.png" alt="image-20231024201205888"></p><p>随后在场景加载容器上的场景加载脚本内进行代码的设计：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202146087.png" alt="image-20231024202146087"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202207797.png" alt="image-20231024202207797"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202218732.png" alt="image-20231024202218732"></p><p>回到unity界面对修改后的脚本重新绑定对应的事件并测试</p><p>测试后发现点击“离开”后出现的两个问题：</p><ul><li>角色回到主界面是死亡倒地的动画</li><li>游戏结束面板在主界面显示</li></ul><p>为了解决以上问题，首先回到界面管理脚本<code>UIManager</code>上先进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202923937.png" alt="image-20231024202923937"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024202944509.png" alt="image-20231024202944509"></p><p>然后再回到角色控制脚本<code>PlayerController</code>下进行代码的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203130398.png" alt="image-20231024203130398"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203150726.png" alt="image-20231024203150726"></p><p>通过代码修改后再次进行测试，仍然还实现不了，通过debug排查，可以发现是在角色属性脚本<code>Character</code>下仍要进行进一步更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024203810665.png" alt="image-20231024203810665"></p><p>由于之前会一直执行OnDie的方法，导致其一直执行死亡广播(GameOverEvent)，所以导致UI管理脚本<code>UIManager</code>下会连续执行相应的OnGameOverEvent</p><p>通过修改后就成功实现离开后无游戏结束面板显示主页面的bug了，但是新的问题则是人物离开后在主界面仍然可以移动，所以在角色属性脚本<code>Character</code>也要进行相应的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024204630238.png" alt="image-20231024204630238"></p><p>由于在OnEnable()中会一直开启，所以要切换到Awake()函数中只开启一次即可</p><h2 id="游戏持久化"><a href="#游戏持久化" class="headerlink" title="游戏持久化"></a>游戏持久化</h2><p>首先在主页面继续游戏的按钮添加事件并绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231024211648761.png" alt="image-20231024211648761"></p><p>由于自带的json转化无法转化例如三维坐标Vector3，字典类型等数据，所以要采用另外一种json转化包来进行数据序列化地处理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094041553.png" alt="image-20231025094041553"></p><p>通过url方式下载<code>nuget</code>的json功能包</p><p>然后在数据管理脚本<code>DataManager</code>下调用导入的包并进行代码的增添：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094435693.png" alt="image-20231025094435693"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094718197.png" alt="image-20231025094718197"></p><p>如何查看各个脚本之间的执行顺序？Edit → Project Setting → Script Execution Order</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025094839064.png" alt="image-20231025094839064"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025095521471.png" alt="image-20231025095521471"></p><p>其中<code>Application.persistentDataPath</code>是unity官方设定的一个默认目录路径：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025095322343.png" alt="image-20231025095322343"></p><p>如何查看项目名<code>companyname</code>或更改项目名？Edit → Project Setting → Player</p><ul><li><strong>传入数据</strong></li></ul><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025100520413.png" alt="image-20231025100520413"></p><ul><li><strong>读取数据</strong></li></ul><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025101141636.png" alt="image-20231025101141636"></p><p>同时要让其在游戏开始时就读取，以便玩家继续游戏:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025101247687.png" alt="image-20231025101247687"></p><p>由于序列化无法直接序列化Vector3类型，所以要在数据类<code>Data</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025130737452.png" alt="image-20231025130737452"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025130840969.png" alt="image-20231025130840969"></p><p>然后回到角色属性脚本<code>Character</code>下对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131127643.png" alt="image-20231025131127643"></p><p>在场景加载脚本<code>SceneLoader</code>下也进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131330993.png" alt="image-20231025131330993"></p><p>通过测试保存后可以在window的对应路径找到我们保存的数据：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%89)/image-20231025131714610.png" alt="image-20231025131714610"></p><p>最终代码总结：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十二）</title>
      <link href="/2023/09/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/09/25/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十二"><a href="#Unity开发日记-十二" class="headerlink" title="Unity开发日记(十二)"></a>Unity开发日记(十二)</h1><h2 id="场景转换"><a href="#场景转换" class="headerlink" title="场景转换"></a>场景转换</h2><p>首先将<strong>不同场景</strong>和<strong>持久化内容</strong>进行分隔开</p><p>不同场景分别是对应不同的<code>Scence</code>,而持久化内容则是角色、血条、摄像机、BGM等内容</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231008200441838.png" alt="image-20231008200441838"></p><h2 id="人物可互动标识"><a href="#人物可互动标识" class="headerlink" title="人物可互动标识"></a>人物可互动标识</h2><ul><li>宝箱</li></ul><p>将宝箱素材切割后拖拽到场景中并进行相关设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009193745467.png" alt="image-20231009193745467"></p><ul><li>互动按钮</li></ul><p>将按钮素材切割后拖拽到角色下作为子物体组件并进行相关设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009195405750.png" alt="image-20231009195405750"></p><p>为按钮添加动画组件并实现动画效果，</p><p>先在<code>Animation</code>文件下创建存放界面交互动画文件夹<code>UI</code>，然后创建交互按钮的动画控制器并绑定给动画组件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009200220172.png" alt="image-20231009200220172"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009200345092.png" alt="image-20231009200345092"></p><p>为按钮组件之上创建一个父容器，为父容器添加一个碰撞体积作为检测玩家有没有接近从而让按钮出现的效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231009202744163.png" alt="image-20231009202744163"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010110143729.png" alt="image-20231010110143729"></p><p>然后创建场景互动脚本<code>Sign</code>并绑定到父容器上</p><p>同时创建新的标签来作为要启动的互动内容，并为需要互动的容器都选择该标签</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010103257050.png" alt="image-20231010103257050"></p><p>然后在场景互动脚本<code>Sign</code>进行编辑</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010110318206.png" alt="image-20231010110318206"></p><p>完成编辑后回到unity界面把子容器绑定在脚本上，从而实现代码逻辑能够操控子容器的开关：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111455521.png" alt="image-20231010111455521"></p><p>经过测试，当人物向相反方向移动时，图标也会被翻转，所以还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111829566.png" alt="image-20231010111829566"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010111954807.png" alt="image-20231010111954807"></p><p>同时还要设置图标的关闭，当玩家离开交互物体时不再显示图标：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010131744828.png" alt="image-20231010131744828"></p><p>进行动画的绑定，在进行之前，需要设定<strong>当用户是用键盘&#x2F;PS5&#x2F;手柄等不同方式时显示的图标动画也不一样</strong>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010143326705.png" alt="image-20231010143326705"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010134855494.png" alt="image-20231010134855494"></p><p>最后经过测试，发现如果是直接把子容器整个隐藏起来的话，第二次经过互动的物品不会有动画的播放，所以改为子容器启用，但是贴图组件<code>Sprite Renderer</code>关闭，同时回到<code>Sign</code>脚本内进行代码修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150205719.png" alt="image-20231010150205719"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150242510.png" alt="image-20231010150242510"></p><p><strong>错误更正：</strong></p><p>以上<code>Sign</code>内容中不是动画<code>Animation</code>而是动画控制器<code>Animator</code></p><p>如果要采用其他方式进行游戏，如手柄、PS5等等，则还要记得先加上对应的命名空间（这里以PS5举例）：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150611484.png" alt="image-20231010150611484"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010150714239.png" alt="image-20231010150714239"></p><h2 id="场景互动的逻辑实现"><a href="#场景互动的逻辑实现" class="headerlink" title="场景互动的逻辑实现"></a>场景互动的逻辑实现</h2><p>通过接口的方式来实现不同物体实现接口方式不同，从而达到不同物体不同交互效果</p><p>在<code>Utilities</code>工具接口文件夹下创建一个可互动接口<code>IInteractable</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010154317091.png" alt="image-20231010154317091"></p><ul><li>宝箱交互</li></ul><p>首先创建一个新的宝箱脚本<code>Chest</code>并调用<code>IInteractable</code>接口，然后在实现之前要先完成交互的前提条件：</p><ol><li><strong>设计宝箱交互(确认)进行时</strong></li></ol><p>回到unity界面上，在角色控制器上添加新的交互按键：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010154744693.png" alt="image-20231010154744693"></p><p>然后回到场景互动脚本<code>Sign</code>编辑新方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204257021.png" alt="image-20231010204257021"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204337477.png" alt="image-20231010204337477"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231010204435301.png" alt="image-20231010204435301"></p><p>通过获取角色控制器来监听，同时当人物就是在交互物体附近(此时显示有交互图标)按下对应按键就可以调用已经获取的交互物体类的交互接口，从而完成对应交互功能</p><p><strong>2、实现宝箱交互内容</strong></p><p>创建宝箱内容脚本<code>Chest</code>并实现交互接口<code>IIneractable</code>,然后把宝箱内容脚本作为组件挂载到宝箱容器上去</p><p>并填充宝箱内容脚本：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213101764.png" alt="image-20231011213101764"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213111148.png" alt="image-20231011213111148"></p><p>同时回到unity界面上，对该组件需要的两张素材类<code>Sprite</code>进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213325767.png" alt="image-20231011213325767"></p><p>这样就完成了宝箱打开后的图片切换，同时还可以在<code>OpenChest()</code>方法中添加代码让打开后宝箱的容器对应的标签切换为无标签，这样就能让角色经过已经打开过的宝箱时不会弹出交互按钮</p><p><strong>3、为宝箱交互添加对应的BGM</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231011213907787.png" alt="image-20231011213907787"></p><p>然后回到交互脚本<code>Sign</code>下修改代码，让宝箱被打开时顺便启用bgm：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012112633590.png" alt="image-20231012112633590"></p><p>最终场景互动中，人物与互动物体，宝箱互动的脚本实现总结：</p><p>场景互动脚本<code>Sign</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem.DualShock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Sign</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//读取控制按键</span></span><br><span class="line">    <span class="keyword">private</span> PlayerInputControls playerInput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform playerTran;</span><br><span class="line">    <span class="comment">//操控子容器(按钮互动)</span></span><br><span class="line">    <span class="keyword">public</span> GameObject signSpirte;</span><br><span class="line">    <span class="comment">//判断能否点按</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> canPress;</span><br><span class="line">    <span class="comment">//获取要交互的内容</span></span><br><span class="line">    <span class="keyword">private</span> IInteractable targetItem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = signSpirte.GetComponent&lt;Animator&gt;();</span><br><span class="line"></span><br><span class="line">        playerInput = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line">        playerInput.Enable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        InputSystem.onActionChange += OnActionChange;</span><br><span class="line">        playerInput.GamePlay.Confirm.started += OnConfirm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnConfirm</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(canPress)</span><br><span class="line">        &#123;</span><br><span class="line">            targetItem.TriggerAction();</span><br><span class="line">            GetComponent&lt;AudioDefination&gt;()?.PlayAudioClip();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        signSpirte.GetComponent&lt;SpriteRenderer&gt;().enabled = canPress;</span><br><span class="line">        signSpirte.transform.localScale = playerTran.localScale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnActionChange</span>(<span class="params"><span class="built_in">object</span> obj, InputActionChange actionChange</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (actionChange == InputActionChange.ActionStarted)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> d = ((InputAction)obj).activeControl.device;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (d.device)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> Keyboard:</span><br><span class="line">                    anim.Play(<span class="string">&quot;keyboard&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DualShockGamepad:</span><br><span class="line">                    anim.Play(<span class="string">&quot;ps&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(other.CompareTag(<span class="string">&quot;Interactable&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            canPress= <span class="literal">true</span>;</span><br><span class="line">            targetItem = other.GetComponent&lt;IInteractable&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerExit2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        canPress = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具文件夹下可互动接口<code>IInteractable</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">TriggerAction</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宝箱互动实现互动接口<code>Chest</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chest</span> : <span class="title">MonoBehaviour</span>,<span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> SpriteRenderer spriteRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Sprite openSprite;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Sprite closeSprite;</span><br><span class="line">    <span class="comment">//判断是否已经打开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer.sprite = isDone ? openSprite : closeSprite;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Open Chest！&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isDone)</span><br><span class="line">        &#123;</span><br><span class="line">            OpenChest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OpenChest</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        spriteRenderer.sprite = openSprite;</span><br><span class="line">        isDone= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.gameObject.tag = <span class="string">&quot;Untagged&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="传送门互动"><a href="#传送门互动" class="headerlink" title="传送门互动"></a>传送门互动</h2><p>首先创建一个新的交互容器用于实现传送门交互，为其添加需要的碰撞体积组件以及新的传送门脚本内容，修改组件属性：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012164105287.png" alt="image-20231012164105287"></p><p>在代码存储文件夹下创建放置交互内容的文件<code>Transistion</code>并创建传送门脚本<code>TeleportPoint</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012164903516.png" alt="image-20231012164903516"></p><h3 id="场景传送-上"><a href="#场景传送-上" class="headerlink" title="场景传送(上)"></a>场景传送(上)</h3><p>场景传送需要有：</p><ol><li>关闭当前场景</li><li>启动新场景</li><li>记录新场景玩家要在的位置(初始点)</li></ol><p>所以要先创建一个全局操控保存应有信息的容器<code>SceneLoad Manager</code>,同时创建场景加载控制脚本<code>SceneLoader</code>,其中全局操控信息的容器放置在角色身上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231012165352867.png" alt="image-20231012165352867"></p><p>同时将该脚本绑定上去</p><p>然后安装一个场景管理的插件——→ <strong>Addressables</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013210856488.png" alt="image-20231013210856488"></p><p>在unity界面上打开新插件的窗口：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211045305.png" alt="image-20231013211045305"></p><p>然后在新窗口下选择创建Addressables Setting，可以将默认的设置进行改名：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211419764.png" alt="image-20231013211419764"></p><p>再选择不同场景<code>Scene</code>，可以发现多了一个选项可以让我们选择勾选，勾选完成后就会添加在Addressables窗口下的<code>Sences</code>中去：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211631618.png" alt="image-20231013211631618"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013211652859.png" alt="image-20231013211652859"></p><h3 id="创建预制体"><a href="#创建预制体" class="headerlink" title="创建预制体"></a>创建预制体</h3><p>创建可以放置怪物预制体<code>Prefab</code>的文件夹，然后在unity界面上通过直接将怪物容器拖拽到该文件夹下成为一个预制体：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212230991.png" alt="image-20231013212230991"></p><p>回到Addressables界面内创建一个新的Assert，并将预制体都拖拽过去方便资源管理：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212624495.png" alt="image-20231013212624495"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231013212715998.png" alt="image-20231013212715998"></p><h3 id="场景传送-中"><a href="#场景传送-中" class="headerlink" title="场景传送(中)"></a>场景传送(中)</h3><p>在事件脚本文件夹<code>ScriptableObject</code>下创建一个新的传递场景加载参数的事件脚本<code>SceneLoadEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015164738458.png" alt="image-20231015164738458"></p><p>然后再在事件脚本文件夹下创建Addressable场景信息<code>GameSceneSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165340575.png" alt="image-20231015165340575"></p><p>随后回到unity界面中创建存储场景信息资源的文件夹<code>Game Scenes</code>，同时将该资源文件夹与BGM资源文件夹一起作为子文件存放在新文件夹<code>Data SO</code>下：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165620561.png" alt="image-20231015165620561"></p><p>随后创建需要的资源存储容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165731041.png" alt="image-20231015165731041"></p><p>同时绑定资源存储容器需要的引用，选择我们对应的场景资源内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165816542.png" alt="image-20231015165816542"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015165906788.png" alt="image-20231015165906788"></p><p>同样方式将其他场景也加入并绑定，然后回到场景加载事件脚本<code>SceneLoader</code>下进行编写，实现对场景资源的加载：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174214896.png" alt="image-20231015174214896"></p><p><strong><code>LoadSceneAsync</code>方法参数对应的意思：</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015171010189.png" alt="image-20231015171010189"></p><p><code>LoadSceneMode.Additive</code>参数的意思是：将场景添加到当前加载的场景</p><p>然后回到unity界面上将要导入的场景路径(GameSceneSO资源)进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174353091.png" alt="image-20231015174353091"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231015174408738.png" alt="image-20231015174408738"></p><p>同时为了方便调取<strong>主要场景</strong>(游戏开始的最初场景)和<strong>资源场景</strong>，回到枚举脚本<code>Enums</code>下创建新的枚举对象：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122032738.png" alt="image-20231016122032738"></p><p>同时在场景资源加载事件<code>GameSceneSO</code>下创建对应类的引用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122311710.png" alt="image-20231016122311710"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122339454.png" alt="image-20231016122339454"></p><p>回到unity界面上，在传送容器<code>Teleport</code>下的传送脚本<code>Teleport Point</code>内进行修改，创建对应传送类型的引用：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016122815345.png" alt="image-20231016122815345"></p><p>然后在unity界面上为sceneToGo属性绑定要传送到达的场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016123026074.png" alt="image-20231016123026074"></p><p>回到场景加载事件脚本<code>SceneLoadEventSO</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135432940.png" alt="image-20231016135432940"></p><p>在事件文件夹<code>Events</code>下创建该场景加载事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135808162.png" alt="image-20231016135808162"></p><p>在传送脚本<code>Teleport Point</code>下进行内容的添加，加入加载事件脚本类的引用，然后回到界面上绑定该加载事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016135624423.png" alt="image-20231016135624423"></p><p>然后修改代码，将需要的内容发送给事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016140035367.png" alt="image-20231016140035367"></p><p>最后回到场景加载脚本<code>SceneLoader</code>下编写需要的内容，导入场景加载事件脚本类<code>SceneLoadEventSO</code>的引用，同时完成事件的监听(获取场景内容和坐标)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016154448169.png" alt="image-20231016154448169"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160443762.png" alt="image-20231016160443762"></p><p><strong>场景切换事件监听流程：</strong></p><p><strong>SceneLoader → SceneLoaderEventSO→GameSceneSO</strong></p><p>最后实现当前场景卸载和加载新场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160537013.png" alt="image-20231016160537013"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016160547441.png" alt="image-20231016160547441"></p><p>最后通过测试还要进行新一步的修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016163249020.png" alt="image-20231016163249020"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016163316075.png" alt="image-20231016163316075"></p><h3 id="场景传送-下"><a href="#场景传送-下" class="headerlink" title="场景传送(下)"></a>场景传送(下)</h3><p>场景切换要考虑到场景加载的时间，所以切换时还要进一步地判断场景是否切换完成：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164003956.png" alt="image-20231016164003956"></p><p>判断完成后启用加载后的方法OnLoadCompleted()来为角色在新场景的坐标进行赋值：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164245809.png" alt="image-20231016164245809"></p><p>同时要回到unity界面上绑定角色坐标：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016164424490.png" alt="image-20231016164424490"></p><p>细节修改：当进行场景传送时不能一直连续按传送键(交互)，同时传送途中不显示人物，而是人物到达新场景后才显示：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175511464.png" alt="image-20231016175511464"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175531029.png" alt="image-20231016175531029"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175556262.png" alt="image-20231016175556262"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016175622640.png" alt="image-20231016175622640"></p><p>接下来就要设置场景切换后的摄像机</p><p>先回到unity界面中创建一个无参传入的广播事件<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182113347.png" alt="image-20231016182113347"></p><p>然后回到场景加载脚本<code>SceneLoad</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182425589.png" alt="image-20231016182425589"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182440469.png" alt="image-20231016182440469"></p><p>同时要回到unity界面上绑定广播事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210827480.png" alt="image-20231016210827480"></p><p>然后在摄像机控制脚本<code>CameraController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016182955774.png" alt="image-20231016182955774"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016183042106.png" alt="image-20231016183042106"></p><p>回到unity界面上，在跟随摄像容器(Virtual Camera)身上的摄像控制脚本绑定事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016211038710.png" alt="image-20231016211038710"></p><p>最后回到场景加载脚本<code>SceneLoader</code>下修改其它内容，实现人物刚开始进入场景时在出生点位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210431004.png" alt="image-20231016210431004"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210137488.png" alt="image-20231016210137488"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016210201755.png" alt="image-20231016210201755"></p><p>最后也要回到unity界面上设置最初场景的初始值，也就是出生点的位置，同时还要把当前场景设置为空：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231016214120620.png" alt="image-20231016214120620"></p><p>最终场景传送的内容脚本总结</p><p>传送门脚本<code>TeleportPoint</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TeleportPoint</span> : <span class="title">MonoBehaviour</span>, <span class="title">IInteractable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SceneLoadEventSO loadEventSO;</span><br><span class="line">    <span class="comment">//要传送到的场景</span></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO sceneToGo;</span><br><span class="line">    <span class="comment">//传送到场景后新出生点的坐标</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 positionToGo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TriggerAction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;传送！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        loadEventSO.RaiseLoadRequestEvent(sceneToGo, positionToGo, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>场景加载控制事件脚本<code>SceneLoader</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.AddressableAssets;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.ResourceManagement.AsyncOperations;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.ResourceManagement.ResourceProviders;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoader</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isLoading;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 firstPosition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform playerTrans;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> SceneLoadEventSO loadEventSO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO firstLoadScene;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;广播&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> VoidEventSO afterSceneLoadedEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FadeEventSO fadeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameSceneSO currentLoadScene;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GameSceneSO secondLoadScene;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 positionToGo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> fadeScreen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> fadeDuration;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Addressables.LoadSceneAsync(firstLoadScene.sceneReference, LoadSceneMode.Additive);</span></span><br><span class="line">        <span class="comment">//currentLoadScene = firstLoadScene;</span></span><br><span class="line">        <span class="comment">//currentLoadScene.sceneReference.LoadSceneAsync(LoadSceneMode.Additive);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        NewGame();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadEventSO.LoadRequestEvent += OnLoadRequestEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        loadEventSO.LoadRequestEvent -= OnLoadRequestEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">NewGame</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        secondLoadScene = firstLoadScene;</span><br><span class="line">        OnLoadRequestEvent(secondLoadScene, firstPosition, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>     场景资源加载请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;locationToLoad&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;posToGo&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fadeScreen&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadRequestEvent</span>(<span class="params">GameSceneSO locationToLoad, Vector3 posToGo, <span class="built_in">bool</span> fadeScreen</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoading)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        isLoading = <span class="literal">true</span>;</span><br><span class="line">        secondLoadScene = locationToLoad;</span><br><span class="line">        positionToGo = posToGo;</span><br><span class="line">        <span class="keyword">this</span>.fadeScreen= fadeScreen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Debug.Log(secondLoadScene.sceneReference.SubObjectName);</span></span><br><span class="line">        <span class="keyword">if</span> (currentLoadScene != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            StartCoroutine(UnLoadPreviousScene());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LoadNewScene();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卸载当前场景</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">UnLoadPreviousScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fadeScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//TOOD: 实现渐入渐出</span></span><br><span class="line">            fadeEvent.FadeIn(fadeDuration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">fadeDuration</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> currentLoadScene.sceneReference.UnLoadScene();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭人物</span></span><br><span class="line">        playerTrans.gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        LoadNewScene();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载新场景</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LoadNewScene</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> loadingOption = secondLoadScene.sceneReference.LoadSceneAsync(LoadSceneMode.Additive,<span class="literal">true</span>);</span><br><span class="line">        loadingOption.Completed += OnLoadCompleted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnLoadCompleted</span>(<span class="params">AsyncOperationHandle&lt;SceneInstance&gt; obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentLoadScene = secondLoadScene;</span><br><span class="line"></span><br><span class="line">        playerTrans.position = positionToGo;</span><br><span class="line">        <span class="comment">//开启人物</span></span><br><span class="line">        playerTrans.gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fadeScreen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">            fadeEvent.FadeOut(fadeDuration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isLoading = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//场景加载完成后事件</span></span><br><span class="line">        afterSceneLoadedEvent.RaiseEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>传递场景加载参数的广播事件脚本<code>SceneLoadEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/SceneLoadEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SceneLoadEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;GameSceneSO, Vector3, <span class="built_in">bool</span>&gt; LoadRequestEvent;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 场景加载请求</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;locationToLoad&quot;&gt;</span>要加载的场景<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;posToGo&quot;&gt;</span>Player的目的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;fadeScreen&quot;&gt;</span>是否渐入渐出<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseLoadRequestEvent</span>(<span class="params">GameSceneSO locationToLoad,Vector3 posToGo,<span class="built_in">bool</span> fadeScreen</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        LoadRequestEvent?.Invoke(locationToLoad, posToGo, fadeScreen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递Addressable插件内容挂载资源的广播事件脚本<code>GameSceneSO</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.AddressableAssets;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Game Scene/GameSceneSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameSceneSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> SceneType sceneType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AssetReference sceneReference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举脚本<code>Enums</code>修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举类型 —— enum</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> NPCState</span><br><span class="line">&#123;</span><br><span class="line">    Patrol,Chase,Skill</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> SceneType</span><br><span class="line">&#123;</span><br><span class="line">    Location,Menu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无参传入的广播事件脚本<code>VoidEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/VoidEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoidEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摄像机控制脚本<code>CameraController</code>修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Cinemachine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraControll</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> VoidEventSO afterSceneLoadedEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CinemachineConfiner2D confiner2D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CinemachineImpulseSource impulseSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VoidEventSO cameraShakeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        confiner2D = GetComponent&lt;CinemachineConfiner2D&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>场景切换后更改</span></span><br><span class="line">    <span class="comment">//private void Start()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    GetNewCameraBounds();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised += OnCameraShakeEvent;</span><br><span class="line">        afterSceneLoadedEvent.OnEventRaised += OnAfterSceneLoadedEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised -= OnCameraShakeEvent;</span><br><span class="line">        afterSceneLoadedEvent.OnEventRaised -= OnAfterSceneLoadedEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAfterSceneLoadedEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取新摄像边界</span></span><br><span class="line">        GetNewCameraBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCameraShakeEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//震动源(启动摄像机震动)</span></span><br><span class="line">        impulseSource.GenerateImpulse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetNewCameraBounds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = GameObject.FindGameObjectWithTag(<span class="string">&quot;Bounds&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        confiner2D.m_BoundingShape2D = obj.GetComponent&lt;Collider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理地图缓存(切换地图)</span></span><br><span class="line">        confiner2D.InvalidateCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景的渐入渐出效果"><a href="#场景的渐入渐出效果" class="headerlink" title="场景的渐入渐出效果"></a>场景的渐入渐出效果</h3><p>首先在unity界面上创建一个新的<code>Canvas</code>容器，并将其优先级设置为最高：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134106498.png" alt="image-20231017134106498"></p><p>其次在该容器下再创建一个图片容器<code>Image</code>，从而实现图片全覆盖：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134235804.png" alt="image-20231017134235804"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134439251.png" alt="image-20231017134439251"></p><p>我们将通过图片全覆盖后对图片的透明度进行变化从而实现场景的渐入渐出效果</p><p>回到Fada canvas容器下，在界面管理文件夹<code>UI</code>下创建新的场景控制脚本<code>FadaCanvas</code>并将其添加在容器下:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017134804610.png" alt="image-20231017134804610"></p><p>在进行代码对场景进行编辑前，还要先去unity资源商场下载一款插件——<strong>DOTween</strong></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017135716763.png" alt="image-20231017135716763"></p><p>回到unity中进行资源启用</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144508372.png" alt="image-20231017144508372"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144448540.png" alt="image-20231017144448540"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017144420330.png" alt="image-20231017144420330"></p><p>然后回到<code>FadeCanvas</code>脚本下进行添加：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017145206967.png" alt="image-20231017145206967"></p><p>再回到unity界面上，在事件文件夹下创建渐入渐出事件<code>FadeEventSO</code>，从而<strong>实现通过将渐入渐出封装在该事件上，再在场景加载脚本上直接绑定事件，然后广播通知，进而自动在<code>FadeCanvas</code>下实现渐入渐变的效果</strong>：</p><p>渐入渐变事件脚本<code>FadeEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150410377.png" alt="image-20231017150410377"></p><p>然后在场景加载脚本上引用并调用对应的渐入渐出方法(<strong>广播</strong>)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151007285.png" alt="image-20231017151007285"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150658041.png" alt="image-20231017150658041"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017150717141.png" alt="image-20231017150717141"></p><p>再回到<code>FadeCanvas</code>下进行<strong>监听</strong>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151318349.png" alt="image-20231017151318349"></p><p>最后回到unity中，先在事件文件夹下创建该事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151526370.png" alt="image-20231017151526370"></p><p>然后分别为广播和监听都进行绑定，其中<code>FadeCavans</code>还需要绑定前边创建的图片容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151546328.png" alt="image-20231017151546328"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151758823.png" alt="image-20231017151758823"></p><p>同时要为渐入渐出的效果设置对应的时间：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231017151925545.png" alt="image-20231017151925545"></p><p>最终的场景传送脚本代码为：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主场景创建"><a href="#主场景创建" class="headerlink" title="主场景创建"></a>主场景创建</h2><p>动画场景创建按个人喜好来</p><p>快捷键：</p><p><code>V</code>键——移动到左上角后可以让相同素材被切割的几个部分在界面上自动拼合</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023122720008.png" alt="image-20231023122720008"></p><p>在描绘好主场景之后，为其添加<code>Canvas</code>容器并设置全覆盖</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213433336.png" alt="image-20231021213433336"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213454660.png" alt="image-20231021213454660"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231021213559382.png" alt="image-20231021213559382"></p><ul><li>创建开始字幕</li></ul><p>然后在<code>Canvas</code>容器下创建文本容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023104059743.png" alt="image-20231023104059743"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105015699.png" alt="image-20231023105015699"></p><p>在网上下载需要的中文字体（这里以得意黑字体举例），在资源文件夹下再创建一个新的存放字体文件的文件夹<code>Fonts</code>并存放字体资源(.ttf)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105426920.png" alt="image-20231023105426920"></p><p>然后右键字体，创建对应的画布字体资源文件，然后再回到文本容器上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105801942.png" alt="image-20231023105801942"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023105847622.png" alt="image-20231023105847622"></p><p>由于中文的特殊性是逐个汉字进行渲染，所以当文字过多或者超出可能会导致部分渲染失败，可以在以下设置进行调整和更改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023110003779.png" alt="image-20231023110003779"></p><ul><li>创建开始按钮</li></ul><p>在<code>Canvas</code>容器下创建UI界面的开始按钮：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023111136955.png" alt="image-20231023111136955"></p><p>也可以是创建文字容器，最后再手动添加按钮组件即可</p><p>快捷键：</p><p><code>T</code>键 —— 拖动蓝色控制点边框调整大小</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023122402976.png" alt="image-20231023122402976"></p><p>创建多个文字容器并创建一个父容器来控制它们的大小或间距：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023133929965.png" alt="image-20231023133929965"></p><p>为父容器添加<code>Vertical Layout Group</code>从而来精细调控子容器间的间距，大小，排布等等</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023134108321.png" alt="image-20231023134108321"></p><p>然后为子容器各自添加按钮组件并设置颜色：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023134852879.png" alt="image-20231023134852879"></p><p>回到unity界面上设置主场景，让加载脚本绑定初始加载的场景：</p><p>先在场景加载文件夹<code>Game Scenes</code>下创建：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135232791.png" alt="image-20231023135232791"></p><p>然后在<code>Addressables Groups</code>下挂载主场景资源：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135401630.png" alt="image-20231023135401630"></p><p>再回到场景加载文件夹下进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135517470.png" alt="image-20231023135517470"></p><p>最后回到<code>SceneLoad Manager</code>下绑定初始场景为该主场景：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023135627010.png" alt="image-20231023135627010"></p><h3 id="主场景加载无法移动"><a href="#主场景加载无法移动" class="headerlink" title="主场景加载无法移动"></a>主场景加载无法移动</h3><p>正常游戏刚开始的画面都无法移动，同时场景切换时也不让角色移动，所以要进行限制，回到角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142530696.png" alt="image-20231023142530696"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142557854.png" alt="image-20231023142557854"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023142627332.png" alt="image-20231023142627332"></p><p>同时为了使主场景时角色不能控制，所以要在场景加载脚本<code>SceneLoader</code>下添加代码：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023143829077.png" alt="image-20231023143829077"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023144939961.png" alt="image-20231023144939961"></p><p>同时回到unity界面，在角色容器对应的组件绑定相应的事件：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145033925.png" alt="image-20231023145033925"></p><p>这样就实现了主场景下人物无法移动</p><h3 id="主场景不加载人物UI界面"><a href="#主场景不加载人物UI界面" class="headerlink" title="主场景不加载人物UI界面"></a>主场景不加载人物UI界面</h3><p>正常游戏开始不会出现人物血条，人物属性，能量条等信息，所以要对人物UI界面也进行修改，在<code>UI Manager</code>容器下对其组件进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145638941.png" alt="image-20231023145638941"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023145925602.png" alt="image-20231023145925602"></p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023150150042.png" alt="image-20231023150150042"></p><p>最后回到unity界面中，在UI容器上对应的脚本进行事件绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%BA%8C)/image-20231023150334774.png" alt="image-20231023150334774"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分治法</title>
      <link href="/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/09/14/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十一）</title>
      <link href="/2023/09/13/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/"/>
      <url>/2023/09/13/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记-十一"><a href="#Unity开发日记-十一" class="headerlink" title="Unity开发日记(十一)"></a>Unity开发日记(十一)</h1><h2 id="摄像机跟随"><a href="#摄像机跟随" class="headerlink" title="摄像机跟随"></a>摄像机跟随</h2><p>首先下载一个摄像机跟随的工具，在unity界面上选择<code>Window</code>→<code>Package Manager</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913093934893.png" alt="image-20230913093934893"></p><p>创建摄像机并绑定要跟随的对象：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913131801585.png" alt="image-20230913131801585"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913131824148.png" alt="image-20230913131824148"></p><p>同时还可以调整摄像机跟随的点位位置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913173915500.png" alt="image-20230913173915500"></p><p>还可以设置缓冲边框，实现渐进效果</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174032813.png" alt="image-20230913174032813"></p><h3 id="摄像机限制范围"><a href="#摄像机限制范围" class="headerlink" title="摄像机限制范围"></a>摄像机限制范围</h3><p>摄像机的区域要进行限制，以免在游玩过程中摄像机可以看到地图场景外的内容</p><p>首先在摄像机组件下进行设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174513294.png" alt="image-20230913174513294"></p><p>查看添加的内容，我们需要为其绑定摄像机能够移动的范围：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174744591.png" alt="image-20230913174744591"></p><p>所以先回到unity界面上设置一个空的容器并且添加新的2D碰撞体(要设置为 is Trigger)，然后画出我们需要的边界线，最后绑定上去：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174926165.png" alt="image-20230913174926165"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913174953783.png" alt="image-20230913174953783"></p><p>设置自动绑定摄像机限制范围，从而实现当场景切换时相机也跟着切换且不越界</p><p>先创建一个Bounds图层并绑定Bounds容器：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913175627791.png" alt="image-20230913175627791"></p><p>然后在<code>Utilities</code>文件夹下创建摄像机控制脚本<code>CameraController</code>并将其绑定在摄像机容器上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913195147274.png" alt="image-20230913195147274"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913195131169.png" alt="image-20230913195131169"></p><h3 id="摄像机震动-攻击抖动"><a href="#摄像机震动-攻击抖动" class="headerlink" title="摄像机震动(攻击抖动)"></a>摄像机震动(攻击抖动)</h3><p>目的：实现人物被攻击时，摄像机会震动，从而达到一个比较好的动作游戏的表达效果</p><p>首先在摄像机的组件下添加新的<code>Extensions</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913200203463.png" alt="image-20230913200203463"></p><p>同时进行设置</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201251081.png" alt="image-20230913201251081"></p><p>而镜头的震动还需要有一个震动源，所以要创建一个容器并绑定一个震动源脚本(内置)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201548970.png" alt="image-20230913201548970"></p><p>调试一个合适的震动效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913201646885.png" alt="image-20230913201646885"></p><p>然后回到摄像机脚本<code>CameraController</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913202414071.png" alt="image-20230913202414071"></p><p>回到unity界面上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913202441684.png" alt="image-20230913202441684"></p><p>为了实现怪物受击，人物受击都能有相应的效果，我们可以通过事件处理器(EventSO)来实现（分为广播方和监听方）</p><ul><li>广播</li></ul><p>先在<code>ScriptableObject</code>下创建一个新的不需要参数传入的事件订阅类<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203001513.png" alt="image-20230913203001513"></p><p>再次切回到unity界面中，在资源存储文件夹<code>Event</code>下创建对应的<code>VoidEventSO</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203112169.png" alt="image-20230913203112169"></p><p>回到事件订阅类<code>VoidEventSO</code>中进行代码逻辑的完善：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913203606488.png" alt="image-20230913203606488"></p><p>然后为角色和怪物的受伤和死亡事件也都绑定该广播：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204014978.png" alt="image-20230913204014978"></p><ul><li>监听方</li></ul><p>回到摄像机控制脚本<code>CameraControl</code>下进行逻辑的编写：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204804642.png" alt="image-20230913204804642"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913204827111.png" alt="image-20230913204827111"></p><p>最后回到unity界面为监听内容绑定对应的震动脚本和事件资源：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230913205140944.png" alt="image-20230913205140944"></p><h2 id="音源设置和音效播放"><a href="#音源设置和音效播放" class="headerlink" title="音源设置和音效播放"></a>音源设置和音效播放</h2><p>在这里主要采用了unity社区中的免费音效<code>Free Casual Music Pack</code>以及<code>FREE Casual Game SFX Pack</code></p><p>下载完成资源后回到unity界面上，通过<code>Window</code>→<code>Package Manager</code>进入里边进行导入资源(Import)：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103156490.png" alt="image-20230914103156490"></p><p>在<code>Assets</code>主文件夹下再创建一个放置这些音乐文件的文件包<code>Audio</code></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103422559.png" alt="image-20230914103422559"></p><p>然后在界面中创建一个新的容器作为音乐播放器<code>Audio Manager</code>，并为其绑定核心的广播组件<code>Audio Source</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914103907754.png" alt="image-20230914103907754"></p><p><strong>该组件相当于用于绑定对应的音频片段并广播出去，而要想听到音频则需要有对应的监听(Audio Listener)，回到相机上可以发现当初创建的时候就默认带有一个<code>Audio Listener</code>组件，所以相当于让摄像机来监听音频从而实现我们能够在游玩过程听到不同的音乐，也可以根据距离的不同收到不同的音乐这种效果</strong></p><p>让广播组件绑定要播放的背景音乐并测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914104304214.png" alt="image-20230914104304214"></p><p>同时要把设置中<code>Loop</code>也打勾，从而让bgm可以循环播放</p><p>为音乐播放器<code>Audio Manager</code>再添加一个<code>Audio Source</code>组件作为绑定音效的组件，然后进行设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914111204123.png" alt="image-20230914111204123"></p><h3 id="音效播放"><a href="#音效播放" class="headerlink" title="音效播放"></a>音效播放</h3><p>回到<code>Script</code>文件下创建放置音效相关脚本的<code>Audio</code>文件夹，创建我们需要用到的音效控制脚本<code>AudioManager</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914105951743.png" alt="image-20230914105951743"></p><p>然后回到unity界面上为音频控制器添加控制脚本并分别绑定对应的两个组件:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914111333768.png" alt="image-20230914111333768"></p><p>接下来就是要创建传递音频文件的事件(<strong>广播和监听</strong>)，通过攻击的时候广播出去通知音频播放器这时要播放相对应的音效</p><ul><li>广播</li></ul><p>先在事件文件夹<code>ScriptableObject</code>下创建需要的玩家音频广播事件<code>PlayAudioEventSO</code>并编辑：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914171955372.png" alt="image-20230914171955372"></p><p>然后回到unity界面上创建对应的<code>Event</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914203118417.png" alt="image-20230914203118417"></p><p>再复制一个并都将其改名：<img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914203139056.png" alt="image-20230914203139056"></p><p>再回到<code>Script</code>文件下创建新的音频自定义脚本<code>AudioDefination</code>：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204028669.png" alt="image-20230914204028669"></p><p>然后挂载到三段攻击上并进行对应数值的绑定：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204240340.png" alt="image-20230914204240340"></p><ul><li>监听(接收)</li></ul><p>回到<code>Audio Manager</code>下的音频监听脚本<code>AudioManager</code>中进行修改:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914204951311.png" alt="image-20230914204951311"></p><p>再次回到unity界面上进行绑定然后测试：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230914205026950.png" alt="image-20230914205026950"></p><p>然后继续在音频监听脚本<code>AudioManager</code>下添加bgm的设置内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915223521545.png" alt="image-20230915223521545"></p><p>回到unity上创建一个新的容器命名为BGM，然后为其添加音频广播脚本<code>Audio Defination</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915223808211.png" alt="image-20230915223808211"></p><h3 id="音乐混音"><a href="#音乐混音" class="headerlink" title="*音乐混音"></a>*音乐混音</h3><p>首先要先打开混音的界面：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224107006.png" alt="image-20230915224107006"></p><p>然后在<code>Setting</code>文件夹下也创建放置混音内容的<code>Audio Mixers</code>文件夹，同时在文件夹下创建第一个混音内容<code>MainMixer</code>:</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224323024.png" alt="image-20230915224323024"></p><p>在混音调音台中创建新的音轨放置不同的音乐：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224510796.png" alt="image-20230915224510796"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224646357.png" alt="image-20230915224646357"></p><p>然后在音频广播的位置选择音乐播放要在哪个轨道上：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915224918064.png" alt="image-20230915224918064"></p><p>这样就可以在混音界面上进行调整了，同时可以通过主轨道的声音进一步影响后边两个音轨的声音</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20230915225228908.png" alt="image-20230915225228908"></p><p>内容总结：</p><p>摄像机控制脚本<code>CameraController</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Cinemachine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CameraControll</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CinemachineConfiner2D confiner2D;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CinemachineImpulseSource impulseSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> VoidEventSO cameraShakeEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        confiner2D = GetComponent&lt;CinemachineConfiner2D&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span>场景切换后更改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetNewCameraBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised += OnCameraShakeEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        cameraShakeEvent.OnEventRaised -= OnCameraShakeEvent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnCameraShakeEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//震动源(启动摄像机震动)</span></span><br><span class="line">        impulseSource.GenerateImpulse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">GetNewCameraBounds</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = GameObject.FindGameObjectWithTag(<span class="string">&quot;Bounds&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        confiner2D.m_BoundingShape2D = obj.GetComponent&lt;Collider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理地图缓存(切换地图)</span></span><br><span class="line">        confiner2D.InvalidateCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>摄像机事件处理器广播<code>VoidEventSO</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName =<span class="string">&quot;Event/VoidEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VoidEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音效控制脚本<code>AudioManager</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Audio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO FXEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO BGMEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioSource BGMSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioSource FXSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXEvent.OnEventRaised += OnFXEvent;</span><br><span class="line">        BGMEvent.OnEventRaised += OnBGMEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXEvent.OnEventRaised -= OnFXEvent;</span><br><span class="line">        BGMEvent.OnEventRaised -= OnBGMEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnBGMEvent</span>(<span class="params">AudioClip clip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        BGMSource.clip = clip;</span><br><span class="line">        BGMSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnFXEvent</span>(<span class="params">AudioClip clip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        FXSource.clip = clip;</span><br><span class="line">        FXSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音频广播事件<code>PlayAudioEventSO</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Event/PlayAudioEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayAudioEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;AudioClip&gt; OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params">AudioClip audioClip</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke(audioClip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>音频自定义脚本<code>AudioDefination</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AudioDefination</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayAudioEventSO playAudioEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AudioClip audioClip;</span><br><span class="line">    <span class="comment">//判断是否是音效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> playOnEnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (playOnEnable)</span><br><span class="line">            PlayAudioClip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayAudioClip</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        playAudioEvent.OnEventRaised(audioClip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水和荆棘的逻辑实现"><a href="#水和荆棘的逻辑实现" class="headerlink" title="水和荆棘的逻辑实现"></a>水和荆棘的逻辑实现</h2><p>首先先设计我们需要的场景</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007145827523.png" alt="image-20231007145827523"></p><p>同时勾选设置：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007165732022.png" alt="image-20231007165732022"></p><p>然后为水池添加一个新的标签(Tags)，为了便于后续实现当人物落到水池则直接死亡</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007165929656.png" alt="image-20231007165929656"></p><p>在人物属性脚本<code>Character</code>下设置新的进入Trigger状态后执行的死亡方法：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007170837380.png" alt="image-20231007170837380"></p><p>在画面中设置荆棘</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007205935279.png" alt="image-20231007205935279"></p><p>同时为了要让整个荆棘当做一个整体来作为一个碰撞体积，需要添加碰撞组件并调整<code>Tilemap Collider 2D</code>组件内容：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211305001.png" alt="image-20231007211305001"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211344528.png" alt="image-20231007211344528"></p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007212722990.png" alt="image-20231007212722990"></p><p>通过直接为荆棘添加攻击组件来实现荆棘的逻辑效果：</p><p><img src="/./../images/unity(%E5%8D%81%E4%B8%80)/image-20231007211700323.png" alt="image-20231007211700323"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2023/09/12/%E9%80%92%E5%BD%92/"/>
      <url>/2023/09/12/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（十）</title>
      <link href="/2023/09/06/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/"/>
      <url>/2023/09/06/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="unity开发日记（十）"><a href="#unity开发日记（十）" class="headerlink" title="unity开发日记（十）"></a>unity开发日记（十）</h1><h2 id="滑墙及蹬墙跳的实现"><a href="#滑墙及蹬墙跳的实现" class="headerlink" title="滑墙及蹬墙跳的实现"></a>滑墙及蹬墙跳的实现</h2><h3 id="滑墙"><a href="#滑墙" class="headerlink" title="滑墙"></a>滑墙</h3><ul><li>动画部分</li></ul><p>先处理蹬墙跳的动画素材，然后创建一个新的动画进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911084804301.png" alt="image-20230911084804301"></p><p>然后创建需要的判断条件<code>onWall</code>并在动画控制器上进行连接：</p><p><strong>跳跃(前提)→蹬墙跳</strong></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911085041195.png" alt="image-20230911085041195"></p><p><strong>蹬墙跳→落地</strong></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911085148934.png" alt="image-20230911085148934"></p><ul><li>代码部分</li></ul><p>回到物理检测脚本<code>PhysicsCheck</code>上进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090100598.png" alt="image-20230911090100598"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090200097.png" alt="image-20230911090200097"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090325424.png" alt="image-20230911090325424"></p><p>然后到角色动画控制器脚本<code>PlayerAnimation</code>上进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090736730.png" alt="image-20230911090736730"></p><p>随后回到unity界面上进行测试，会发现一个问题：人物在滑墙的时候会一直不断地在滑墙动画和跳跃动画反复切换</p><p>所以要再回到动画控制器上给跳跃动画添加一个新的约束条件：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911090918890.png" alt="image-20230911090918890"></p><p>进行测试后会发现另外一个新的问题：当角色按住方向键再按跳跃键时不会有动画出现</p><p>所以要再回到物理检测脚本<code>PhysicsCheck</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092102517.png" alt="image-20230911092102517"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092118842.png" alt="image-20230911092118842"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092207254.png" alt="image-20230911092207254"></p><p>同时为了限制滑墙下降的速度变慢，要回到角色控制器<code>PlayerController</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911092702304.png" alt="image-20230911092702304"></p><p>细节修改：</p><p>回到unity界面上，切换scence界面查看会发现当人物进行滑墙跳的时候，由于碰撞体没有被改变，所以</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093121486.png" alt="image-20230911093121486"></p><p>人物还没完全滑下去的时候就先变成落地状态，回到物理检测脚本<code>PhysicsCheck</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093446461.png" alt="image-20230911093446461"></p><p>然后回到unity界面上为y轴的偏移量和检测半径也进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911093606077.png" alt="image-20230911093606077"></p><h3 id="蹬墙跳"><a href="#蹬墙跳" class="headerlink" title="蹬墙跳"></a>蹬墙跳</h3><p>在角色控制器<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911094926713.png" alt="image-20230911094926713"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095006072.png" alt="image-20230911095006072"></p><p>回到unity进行测试，会发现一个问题：角色蹬墙跳后立刻又会贴墙，原因是：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095216404.png" alt="image-20230911095216404"></p><p>导致人物蹬墙跳的时候又被按了回去，所以还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095527324.png" alt="image-20230911095527324"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095550610.png" alt="image-20230911095550610"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095606598.png" alt="image-20230911095606598"></p><p>这样做可以成功实现蹬墙跳，但是落地后就不能动了，因为我们只设置了<code>wallJump</code>为true，还没有设置它实现后改为false，但这个部分还有一个需求：当蹬墙跳到最高点开始下落的时候，人物还能控制左右方向，所以要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230911095950075.png" alt="image-20230911095950075"></p><p>这样就完全实现了蹬墙跳</p><h2 id="滑铲的动画与逻辑实现"><a href="#滑铲的动画与逻辑实现" class="headerlink" title="滑铲的动画与逻辑实现"></a>滑铲的动画与逻辑实现</h2><h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>先实现动画，滑铲动画主要有两个阶段：滑铲准备阶段 → 滑铲阶段</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912134944157.png" alt="image-20230912134944157"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912135640663.png" alt="image-20230912135640663"></p><p>然后在动画控制器中创建新的图层并创建空容器：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912140425790.png" alt="image-20230912140425790"></p><p>创建判断条件值<code>isSlide</code>，同时进行动画之间的连接：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912141048864.png" alt="image-20230912141048864"></p><p>同时也要把滑铲的第一个阶段动画的循环取消了：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912152037613.png" alt="image-20230912152037613"></p><p>回到角色控制监听器<code>PlayerInputControl</code>上进行新按键的设置和绑定：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912142319098.png" alt="image-20230912142319098"></p><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><p>回到角色控制脚本<code>PlayerController</code>下进行编辑：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151037898.png" alt="image-20230912151037898"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151053410.png" alt="image-20230912151053410"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151123539.png" alt="image-20230912151123539"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151156351.png" alt="image-20230912151156351"></p><p>携程部分：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151828822.png" alt="image-20230912151828822"></p><p><strong><code>Rigidbody2D.MovePosition</code>是 Unity 中用于移动 2D 刚体的方法之一</strong>。它的主要作用是将刚体移动到指定的位置，同时自动处理碰撞和物理引擎的交互</p><p>然后回到角色动画控制脚本，添加滑铲动画的设置：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912151858445.png" alt="image-20230912151858445"></p><p>经过测试发现还有新的问题</p><ul><li>掉入悬崖时滑动动画没有退出</li><li>滑铲时遇到怪物还是会受到伤害</li></ul><p>修改：</p><p>第一个问题只要把携程退出的语句改了即可：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153704765.png" alt="image-20230912153704765"></p><p>第二个问题则需要添加新的代码逻辑，在这里可以使用让角色所在的图层切换为怪物图层从而实现不会受伤害的效果：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153932452.png" alt="image-20230912153932452"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912153945828.png" alt="image-20230912153945828"></p><p>再次进行测试，发现还有细节要进行修改：</p><ul><li>跳跃过程中可以滑铲</li><li>碰到墙壁后不能往反方向滑铲</li></ul><p>所以还要对代码进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912195742826.png" alt="image-20230912195742826"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912195818821.png" alt="image-20230912195818821"></p><p>同时为了能让跳跃可以打断滑铲动作，还要进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912200314819.png" alt="image-20230912200314819"></p><h4 id="通过能量条使用滑铲"><a href="#通过能量条使用滑铲" class="headerlink" title="通过能量条使用滑铲"></a>通过能量条使用滑铲</h4><p>先在角色属性脚本<code>Character</code>上添加新的代码：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202005330.png" alt="image-20230912202005330"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203828639.png" alt="image-20230912203828639"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202028240.png" alt="image-20230912202028240"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912202042203.png" alt="image-20230912202042203"></p><p>然后再到角色状态栏脚本<code>PlayerStatBar</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203505094.png" alt="image-20230912203505094"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203533848.png" alt="image-20230912203533848"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203551005.png" alt="image-20230912203551005"></p><p>然后再到UI界面脚本<code>UIManager</code>上进行修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912203639132.png" alt="image-20230912203639132"></p><p>最后回到角色控制脚本<code>PlayerController</code>上进行绑定：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912204158362.png" alt="image-20230912204158362"></p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912204230911.png" alt="image-20230912204230911"></p><p>滑铲的能量条具体的流程为：</p><p><code>PlayerController</code>的Slide方法 → <code>Character</code>的OnSlide方法 → <code>UIManager</code>的OnHealthEvent方法 → <code>PlayerStatBar</code>的OnPowerChange方法</p><p>最后测试发现当滑铲能量条结束后还可以继续滑铲，所以要再进行细节修改：</p><p><img src="/./../images/unity(%E5%8D%81)/image-20230912210322258.png" alt="image-20230912210322258"></p><p>最终代码总结</p><p>物理检测脚本<code>PhysicsCheck</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//判断是手动还是自动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> manual;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是挂载在角色身上而不是怪物身上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isPlayer;</span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 leftOffset;</span><br><span class="line">    <span class="keyword">public</span> Vector2 rightOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> onWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchLeftWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchRightWall;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        rb= GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        <span class="comment">//自动</span></span><br><span class="line">        <span class="keyword">if</span>(!manual)</span><br><span class="line">        &#123;</span><br><span class="line">            rightOffset = <span class="keyword">new</span> Vector2((coll.bounds.size.x + coll.offset.x) / <span class="number">2</span>, coll.bounds.size.y / <span class="number">2</span>);</span><br><span class="line">            leftOffset = <span class="keyword">new</span> Vector2(-rightOffset.x, rightOffset.y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isPlayer)</span><br><span class="line">        &#123;</span><br><span class="line">            playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        <span class="keyword">if</span> (onWall)</span><br><span class="line">            isGround = Physics2D.OverlapCircle((Vector2)transform.position + <span class="keyword">new</span> Vector2(bottomOffset.x * transform.localScale.x, bottomOffset.y), checkReduis, groundLayer);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            isGround = Physics2D.OverlapCircle((Vector2)transform.position + <span class="keyword">new</span> Vector2(bottomOffset.x * transform.localScale.x, <span class="number">0</span>), checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//墙体判断</span></span><br><span class="line">        touchLeftWall = Physics2D.OverlapCircle((Vector2)transform.position + leftOffset, checkReduis, groundLayer);</span><br><span class="line">        touchRightWall = Physics2D.OverlapCircle((Vector2)transform.position + rightOffset, checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在墙壁上</span></span><br><span class="line">        <span class="keyword">if</span> (isPlayer)</span><br><span class="line">            onWall = (touchLeftWall &amp;&amp; playerController.inputDirection.x &lt; <span class="number">0f</span> || touchRightWall &amp;&amp; playerController.inputDirection.x &gt; <span class="number">0f</span>) &amp;&amp; rb.velocity.y&lt;<span class="number">0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + leftOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + rightOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色控制脚本<code>PlayerController</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Character character;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PlayerAnimation playerAnimation;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跑步速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//行走速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳跃的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反弹力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//蹬墙跳的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> wallJumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> slideDistance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> slideSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑铲消耗的能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> slidePowerCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//碰撞体的两个变量(大小和位移)</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;物理材质&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> PhysicsMaterial2D normal;</span><br><span class="line">    <span class="keyword">public</span> PhysicsMaterial2D wall;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//是否下蹲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isAttack;</span><br><span class="line">    <span class="comment">//是否蹬墙跳</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wallJump;</span><br><span class="line">    <span class="comment">//是否滑铲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isSlide;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        playerAnimation = GetComponent&lt;PlayerAnimation&gt;();</span><br><span class="line"></span><br><span class="line">        character = GetComponent&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳跃</span></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line">        <span class="comment">//攻击</span></span><br><span class="line">        inputControl.GamePlay.Attack.started += PlayerAttack;</span><br><span class="line">        <span class="comment">//滑铲</span></span><br><span class="line">        inputControl.GamePlay.Slide.started += Slide;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">        CheckState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isAttack)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isCrouch &amp;&amp; !wallJump)</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色跳跃对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打断滑铲携程</span></span><br><span class="line">            isSlide = <span class="literal">false</span>;</span><br><span class="line">            StopAllCoroutines();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (physicsCheck.onWall)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(-inputDirection.x,<span class="number">2.2f</span>)*wallJumpForce, ForceMode2D.Impulse);</span><br><span class="line">            wallJump = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//角色攻击对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayerAttack</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!physicsCheck.isGround)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        playerAnimation.PlayAttack();</span><br><span class="line">        isAttack= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Slide</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isSlide &amp;&amp; physicsCheck.isGround &amp;&amp; character.currentPower&gt;=slidePowerCost)</span><br><span class="line">        &#123;</span><br><span class="line">            isSlide=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//滑铲的目标点</span></span><br><span class="line">            <span class="keyword">var</span> targetPos = <span class="keyword">new</span> Vector3(transform.position.x + slideDistance * transform.localScale.x, transform.position.y);</span><br><span class="line">            gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Enemy&quot;</span>);</span><br><span class="line">            <span class="comment">//启动携程</span></span><br><span class="line">            StartCoroutine(TriggerSlide(targetPos));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//滑铲消耗能量</span></span><br><span class="line">        character.OnSlide(slidePowerCost);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">TriggerSlide</span>(<span class="params">Vector3 target</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!physicsCheck.isGround)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.touchLeftWall &amp;&amp; transform.localScale.x &lt; <span class="number">0f</span>|| physicsCheck.touchRightWall &amp;&amp; transform.localScale.x &gt; <span class="number">0f</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isSlide = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不断移动</span></span><br><span class="line">            rb.MovePosition(<span class="keyword">new</span> Vector2(transform.position.x + transform.localScale.x * slideSpeed, transform.position.y));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">while</span> (MathF.Abs(target.x - transform.position.x) &gt; <span class="number">0.1f</span>);</span><br><span class="line"></span><br><span class="line">        isSlide = <span class="literal">false</span>;</span><br><span class="line">        gameObject.layer = LayerMask.NameToLayer(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> UnityEvent</span></span><br><span class="line">    <span class="comment">//角色受伤对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GerHurt</span>(<span class="params">Transform attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2((transform.position.x - attacker.position.x), <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色死亡对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerDead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">        inputControl.GamePlay.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CheckState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll.sharedMaterial = physicsCheck.isGround ? normal : wall;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (physicsCheck.onWall)</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(rb.velocity.x, rb.velocity.y / <span class="number">2f</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(rb.velocity.x, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(wallJump &amp;&amp; rb.velocity.y&lt;<span class="number">0f</span>)</span><br><span class="line">            wallJump = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>属性脚本<code>Character</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    <span class="comment">//最大能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxPower;</span><br><span class="line">    <span class="comment">//当前能量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentPower;</span><br><span class="line">    <span class="comment">//能量恢复速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> powerRecoverSpeed;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//掉血事件(传递给人物状态栏)</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Character&gt; OnHealthChange;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">        <span class="comment">//初始化能量</span></span><br><span class="line">        currentPower= maxPower;</span><br><span class="line">        <span class="comment">//初始化血条(广播到血条状态栏脚本上)</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//能量恢复</span></span><br><span class="line">        <span class="keyword">if</span>(currentPower &lt; maxPower)</span><br><span class="line">        &#123;</span><br><span class="line">            currentPower += Time.deltaTime * powerRecoverSpeed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//血条变化广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnSlide</span>(<span class="params"><span class="built_in">int</span> cost</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入character&quot; + cost);</span></span><br><span class="line">        <span class="comment">//能量消耗</span></span><br><span class="line">        currentPower -= cost;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入character&quot; + currentPower);</span></span><br><span class="line">        <span class="comment">//能量恢复广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UI控制脚本<code>UIManager</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerStatBar playerStatBar;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> CharacterEventSO healthEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised += OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised -= OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> persentage = character.currentHealth / character.maxHealth;</span><br><span class="line">        playerStatBar.OnHealthChange(persentage);</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入UIManager&quot;);</span></span><br><span class="line">        playerStatBar.OnPowerChange(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>角色状态栏脚本<code>PlayerStatBar</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerStatBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Character currentCharacter;</span><br><span class="line">    <span class="comment">//血条(绿色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthImage;</span><br><span class="line">    <span class="comment">//血条渐变(红色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthDelayImage;</span><br><span class="line">    <span class="comment">//能量条(黄色)</span></span><br><span class="line">    <span class="keyword">public</span> Image powerImage;</span><br><span class="line">    <span class="comment">//能量是否正在恢复</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isRecovering;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(healthDelayImage.fillAmount &gt; healthImage.fillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            healthDelayImage.fillAmount -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isRecovering)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">float</span> persentage = currentCharacter.currentPower / currentCharacter.maxPower;</span><br><span class="line">            powerImage.fillAmount = persentage;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;进入能量条&quot;+persentage);</span></span><br><span class="line">            <span class="keyword">if</span> (persentage &gt;= <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                isRecovering= <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收Health的变更百分比</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;persentage&quot;&gt;</span>百分比：Current/Max<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params"><span class="built_in">float</span> persentage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthImage.fillAmount= persentage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPowerChange</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;进入PlayerStatBar&quot;);</span></span><br><span class="line">        isRecovering = <span class="literal">true</span>;</span><br><span class="line">        currentCharacter= character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（九）</title>
      <link href="/2023/09/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/"/>
      <url>/2023/09/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（九）"><a href="#Unity开发日记（九）" class="headerlink" title="Unity开发日记（九）"></a>Unity开发日记（九）</h1><h2 id="创建人物状态栏"><a href="#创建人物状态栏" class="headerlink" title="创建人物状态栏"></a>创建人物状态栏</h2><p>先到unity asset store下安装一个工具：<a href="https://assetstore.unity.com/packages/tools/utilities/colourful-hierarchy-category-gameobject-205934">https://assetstore.unity.com/packages/tools/utilities/colourful-hierarchy-category-gameobject-205934</a></p><p>回到unity中进行安装：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230901140357378.png" alt="image-20230901140357378"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230901140430004.png" alt="image-20230901140430004"></p><p>找到模组文件夹进行配置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904085740719.png" alt="image-20230904085740719"></p><p>根据个人喜好进行配置，然后回到unity界面上查看效果</p><p>接下来就是创建人物状态栏</p><p>首先要创建UI内容：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904090349034.png" alt="image-20230904090349034"></p><p>完成创建后可以发现会自动给我们多创建了一个<code>EventSystem</code>，我们先查看到<code>EventSystem</code>并进行配置的更改：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904090539144.png" alt="image-20230904090539144"></p><p>查看<code>Caven</code>画布：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091026593.png" alt="image-20230904091026593"></p><p>可以看出画布是独立于游戏画面的，这样可以避免不同设备ui界面不同</p><p>然后配置UI布局，选择根据我们的游戏场景来进行配置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091319040.png" alt="image-20230904091319040"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091541653.png" alt="image-20230904091541653"></p><p>在画布下创建图片，同时设置<code>锚点</code></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091809036.png" alt="image-20230904091809036"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904091934563.png" alt="image-20230904091934563"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092354864.png" alt="image-20230904092354864"></p><p>通过<code>Alt +shift</code>键将图片定位到锚点处</p><p>锚点的作用：</p><p>通过<code>W</code>键来移动图片</p><h3 id="编辑人物状态栏"><a href="#编辑人物状态栏" class="headerlink" title="编辑人物状态栏"></a>编辑人物状态栏</h3><h4 id="血条和能量条"><a href="#血条和能量条" class="headerlink" title="血条和能量条"></a>血条和能量条</h4><p>首先对UI界面的画面素材进行切割：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092801447.png" alt="image-20230904092801447"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904092827772.png" alt="image-20230904092827772"></p><p>然后手动进行切割的调整并保存，将切割完成的动画放置并进行调整：</p><p>当设置好图片后可以点击<code>Set Native Size</code>进行自动适应我们画布大小的调整，然后我们再进行手动的调整</p><ul><li>血条框架(Health Frame)</li></ul><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094215713.png" alt="image-20230904094215713"></p><ul><li>血条(Health Fill Green)</li></ul><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094441611.png" alt="image-20230904094441611"></p><p>血条要设置一个渐变效果：从右往左逐渐减少，所以要设置新的配置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094706811.png" alt="image-20230904094706811"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904094738429.png" alt="image-20230904094738429"></p><ul><li>血条渐变(Health Fill Red)</li></ul><p>复制粘贴Health Fill Green，然后将图片素材换成红色血条的图片素材即可</p><p>将以上内容归为画布下一个模块，创建父类容器，同时调整大小：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095336189.png" alt="image-20230904095336189"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095327038.png" alt="image-20230904095327038"></p><p>父类容器锚点定位在左上角，同时按<code>Alt</code>键连同容器也是在锚点位置，设定好框架后方便对下边的子容器进行移动和调整</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904095457420.png" alt="image-20230904095457420"></p><p>同样方法创建能量条</p><h4 id="人物头像"><a href="#人物头像" class="headerlink" title="人物头像"></a>人物头像</h4><p>首先创建人物头像框架<code>Player Face</code></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904100538300.png" alt="image-20230904100538300"></p><p>再创建一个包含了两种能量条和头像的父类容器，方便进行调整：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904100836152.png" alt="image-20230904100836152"></p><p>然后再创建人物头像，由于没有头像素材，所以可以用其他方式进行切割：</p><p>1、定义一个新的图片空素材<code>Cut</code>方便接下来的切割，作为中间层</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101139914.png" alt="image-20230904101139914"></p><p>2、定义一个头像的图片放在<code>Cut</code>下，并调整大小且移动位置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101354444.png" alt="image-20230904101354444"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101409943.png" alt="image-20230904101409943"></p><p>3、回到中间层<code>Cut</code>为其添加一个<code>Mask</code>组件并进行设置</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101518378.png" alt="image-20230904101518378"></p><p>这样就完成了基本的人物状态栏的设置：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904101812421.png" alt="image-20230904101812421"></p><h2 id="血量更新逻辑的实现-广播者和监听者"><a href="#血量更新逻辑的实现-广播者和监听者" class="headerlink" title="血量更新逻辑的实现(广播者和监听者)"></a>血量更新逻辑的实现(广播者和监听者)</h2><p>先创建放置UI脚本内容的文件夹，同时编辑第一个UI脚本<code>PlayerStatBar</code>：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904135400171.png" alt="image-20230904135400171"></p><p>为人物状态栏添加该UI脚本，同时绑定图片：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904135609516.png" alt="image-20230904135609516"></p><p>回到脚本中添加获取让血条移动渐变的方法：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230904140751449.png" alt="image-20230904140751449"></p><h3 id="广播者"><a href="#广播者" class="headerlink" title="广播者"></a>广播者</h3><p>回到unity中创建资源文件<code>ScriptableObject</code>,并创建需要的脚本<code>CharacterEventSO</code>作为<strong>广播者</strong>:</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905173335931.png" alt="image-20230905173335931"></p><p>然后创建一个事件文件夹<code>Event</code>，并在下边创建一个我们刚创好的资源脚本：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905175250103.png" alt="image-20230905175250103"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905175552911.png" alt="image-20230905175552911"></p><p>接下来就是要实现<strong>当玩家血量掉血时，将玩家的<code>Character</code>基础属性脚本的内容传递到资源文件夹<code>Event</code>下存储玩家资源的<code>CharacterEventSO</code>，最后在人物状态栏下的状态栏脚本<code>Player Stat Bar</code>脚本中启用</strong></p><p>1、首先更改角色属性脚本<code>Character</code>:</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180145106.png" alt="image-20230905180145106"></p><p>2、其次回到unity界面中绑定对应的类和属性将内容广播出去</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180738311.png" alt="image-20230905180738311"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905180753145.png" alt="image-20230905180753145"></p><h3 id="监听者"><a href="#监听者" class="headerlink" title="监听者"></a>监听者</h3><p>在unity界面下创建一个作为UI监听器的容器<code>UIManager</code>,同时在UI文件夹下创建监听器脚本<code>UIManager</code>，挂载到容器上：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905181807956.png" alt="image-20230905181807956"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905181839585.png" alt="image-20230905181839585"></p><p>编辑监听器脚本内容并进行绑定：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905182018735.png" alt="image-20230905182018735"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905182258304.png" alt="image-20230905182258304"></p><p>然后添加启动和取消时的事件监听内容，从而实现<strong>对广播内容的接收</strong>：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905183832835.png" alt="image-20230905183832835"></p><p>回到unity界面中为监听器绑定角色状态栏：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905183915221.png" alt="image-20230905183915221"></p><p>同时回到角色属性脚本<code>Character</code>中进行修改：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905184314844.png" alt="image-20230905184314844"></p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905184332252.png" alt="image-20230905184332252"></p><p>这样就完成了人物状态栏中绿色血条的减少，接下来要让红色血条也跟着出现渐变，在角色状态栏脚本内容<code>Player Stat Bar</code>进行添加：</p><p><img src="/./../images/unity(%E4%B9%9D)/image-20230905203732849.png" alt="image-20230905203732849"></p><p>最终效果就可以实现了</p><p>总结以上内容的代码：</p><p>人物状态栏脚本<code>PlayerStatBar</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerStatBar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//血条(绿色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthImage;</span><br><span class="line">    <span class="comment">//血条渐变(红色)</span></span><br><span class="line">    <span class="keyword">public</span> Image healthDelayImage;</span><br><span class="line">    <span class="comment">//能量条(黄色)</span></span><br><span class="line">    <span class="keyword">public</span> Image powerImage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(healthDelayImage.fillAmount &gt; healthImage.fillAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            healthDelayImage.fillAmount -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接收Health的变更百分比</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;persentage&quot;&gt;</span>百分比：Current/Max<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnHealthChange</span>(<span class="params"><span class="built_in">float</span> persentage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthImage.fillAmount= persentage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>存储广播内容的资源文件夹<code>ScriptableObject</code>下角色属性资源脚本<code>CharacterEventSO</code>(广播者):</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CreateAssetMenu(menuName = <span class="string">&quot;Event/CharacterEventSO&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CharacterEventSO</span> : <span class="title">ScriptableObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> UnityAction&lt;Character&gt; OnEventRaised;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RaiseEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnEventRaised?.Invoke(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UI监听器内容脚本<code>UIManager</code>(监听者)：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerStatBar playerStatBar;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;事件监听&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> CharacterEventSO healthEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised += OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        healthEvent.OnEventRaised -= OnHealthEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnHealthEvent</span>(<span class="params">Character character</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> persentage = character.currentHealth / character.maxHealth;</span><br><span class="line">        playerStatBar.OnHealthChange(persentage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色属性脚本<code>Character</code>修改:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//掉血事件(传递给人物状态栏)</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Character&gt; OnHealthChange;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">        <span class="comment">//初始化血条(广播到血条状态栏脚本上)</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//血条变化广播</span></span><br><span class="line">        OnHealthChange?.Invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/28/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/"/>
      <url>/2023/08/28/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（八）"><a href="#Unity开发日记（八）" class="headerlink" title="Unity开发日记（八）"></a>Unity开发日记（八）</h1><h2 id="怪物——蜗牛"><a href="#怪物——蜗牛" class="headerlink" title="怪物——蜗牛"></a>怪物——蜗牛</h2><h3 id="蜗牛的基本移动逻辑和动画"><a href="#蜗牛的基本移动逻辑和动画" class="headerlink" title="蜗牛的基本移动逻辑和动画"></a>蜗牛的基本移动逻辑和动画</h3><p>进行蜗牛动画的基本处理，对素材进行切割，对不同动画进行简易的命名处理，方便后续操作的管理：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828104225859.png" alt="image-20230828104225859"></p><p>蜗牛的动画主要有几个实现要求：</p><ul><li>蜗牛的移动</li><li>蜗牛的缩壳</li><li>蜗牛的探头</li><li>蜗牛的受伤</li><li>蜗牛的死亡</li></ul><p><img src="/./../images/unity(%E5%85%AB)/image-20230828105345681.png" alt="image-20230828105345681"></p><p>进行基础的图层调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828105453721.png" alt="image-20230828105453721"></p><p>添加对应的碰撞体积，一个在脚上与地面进行检测，一个是自身碰撞体，方便与玩家进行交互：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828114423205.png" alt="image-20230828114423205"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828115106618.png" alt="image-20230828115106618"></p><p>同时蜗牛也要添加其他相对应的脚本文件，在此之前，先回到怪物的基类进行调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110010810.png" alt="image-20230828110010810"></p><p><strong>目的：当蜗牛创建新的脚本并且继承怪物基类时，会为蜗牛自动添加这三个必要的组件</strong></p><p>在脚本文件夹<code>Script</code>下怪物文件夹<code>Enemy</code>创建蜗牛的脚本<code>Snail</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110229557.png" alt="image-20230828110229557"></p><p>然后回到unity中为蜗牛添加该脚本，与此同时也会自动被添加了三个必须的组件：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110338410.png" alt="image-20230828110338410"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110352502.png" alt="image-20230828110352502"></p><p>同时还要为蜗牛添加对应的属性脚本<code>Character</code>以及攻击脚本<code>Attack</code>,也要为事件编辑器绑定对应的脚本以及方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110716009.png" alt="image-20230828110716009"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828110758313.png" alt="image-20230828110758313"></p><p>随后再调整蜗牛的一些基础数值：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111032920.png" alt="image-20230828111032920"></p><p>同时蜗牛的地面检测脚本也要进行调整：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828115349122.png" alt="image-20230828115349122"></p><h4 id="编写蜗牛的状态机与动画"><a href="#编写蜗牛的状态机与动画" class="headerlink" title="编写蜗牛的状态机与动画"></a>编写蜗牛的状态机与动画</h4><ul><li>蜗牛的巡逻状态：</li></ul><p>在怪物文件夹下先创建蜗牛巡逻状态的脚本<code>SnailPatrolState</code></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111534734.png" alt="image-20230828111534734"></p><p>回到unity中编辑实现蜗牛移动的动画：</p><p>在动画文件夹下创建对应的蜗牛存放的文件夹，同时创建蜗牛需要的动画控制器</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111818728.png" alt="image-20230828111818728"></p><p>绑定</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828111732146.png" alt="image-20230828111732146"></p><p>开始对动画的编辑，首先是实现蜗牛的待机：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112248723.png" alt="image-20230828112248723"></p><p>随后是蜗牛的移动，要注意的是，蜗牛的移动动画类似于两个阶段：蓄力(准备)和移动，所以要创建两个动画来拼接：</p><p>首先是蜗牛向后蓄力(准备)的动画</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112527110.png" alt="image-20230828112527110"></p><p>然后是蜗牛向前移动的动画</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112652534.png" alt="image-20230828112652534"></p><p>这样就先完成了基础的动画编辑，接下来就是在动画控制器中添加判断的值以及连接不同动画</p><p>回到动画编辑器中，先添加判断值（walk，dead，状态hurt）：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828112936206.png" alt="image-20230828112936206"></p><p>然后开始进行连线，首先是蜗牛移动两个阶段动画的连接，这意味着第一个准备阶段动画要完全播放完才会播放第二个移动阶段的动画，而第二次移动也是要第二个移动阶段的动画播放完毕后才会回到第一个阶段的动画，循环往复：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113331223.png" alt="image-20230828113331223"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113502566.png" alt="image-20230828113502566"></p><p>随后再连接待机动画与移动动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113724741.png" alt="image-20230828113724741"></p><p>同理返回的也一样，其他设置保持一致</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828113758782.png" alt="image-20230828113758782"></p><p>细节修改：当蜗牛撞墙时就不要继续保持移动的动画了，所以还要再加一个连接线</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828114005331.png" alt="image-20230828114005331"></p><p>最后回到蜗牛的巡逻状态脚本<code>SnailPatrolState</code>中进行编辑：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828121049119.png" alt="image-20230828121049119"></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到chase状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Skill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在蜗牛的逻辑脚本<code>Snail</code>中进行状态的初始化：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828121401561.png" alt="image-20230828121401561"></p><p>蜗牛的移动还要再进行细致的修改，要让蜗牛在第一阶段的准备移动时不会真正移动，而是到了第二阶段才会实现真正的移动，所以回到怪物基类中进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144155465.png" alt="image-20230828144155465"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144331662.png" alt="image-20230828144331662"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828144402960.png" alt="image-20230828144402960"></p><p><code>IsName()</code>对应的是目前所处的动画是哪个，里边填入对应的一阶段准备的动画名</p><h3 id="蜗牛的特殊技能状态的实现"><a href="#蜗牛的特殊技能状态的实现" class="headerlink" title="蜗牛的特殊技能状态的实现"></a>蜗牛的特殊技能状态的实现</h3><p>蜗牛的特殊技能体现在 ———— 躲藏</p><p>先实现蜗牛的躲藏动画，蜗牛的躲藏分为三个阶段：<strong>缩壳阶段 → 壳中阶段 → 探头阶段</strong></p><p>缩壳阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828170953511.png" alt="image-20230828170953511"></p><p>壳中阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828171334256.png" alt="image-20230828171334256"></p><p>探头阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828171604149.png" alt="image-20230828171604149"></p><p>接下来要设置需要的判断值，同时将动画进行连接，其中要先设置一个看到玩家后就进入的状态值<code>Skill</code>与标记是否是躲藏的值<code>hide</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172321029.png" alt="image-20230828172321029"></p><p>同时设置连接的设置</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172351034.png" alt="image-20230828172351034"></p><p>然后再将第一个阶段动画和第二个阶段动画连接起来：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172601475.png" alt="image-20230828172601475"></p><p>再是将第二个阶段动画和第三个阶段动画连接起来：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172703855.png" alt="image-20230828172703855"></p><p>最后是探头阶段到退出的连线：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828172829246.png" alt="image-20230828172829246"></p><p>再添加一个受伤动画，即实现如果是先被玩家攻击而受伤，这时也会进入缩壳状态：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173146832.png" alt="image-20230828173146832"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173350903.png" alt="image-20230828173350903"></p><p>受伤后进入准备缩壳阶段：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828173726191.png" alt="image-20230828173726191"></p><h4 id="编写蜗牛特殊技能状态机"><a href="#编写蜗牛特殊技能状态机" class="headerlink" title="编写蜗牛特殊技能状态机"></a>编写蜗牛特殊技能状态机</h4><p>先创建对应的蜗牛特殊技能状态脚本<code>SnailSkillState</code>并进行编辑：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828201956978.png" alt="image-20230828201956978"></p><p>同时回到蜗牛的逻辑脚本<code>Snail</code>下进行初始化，初始化的前提是怪物基类<code>Enemy</code>也有蜗牛缩壳阶段的变量，所以：</p><p><code>Enemy</code>下要添加新的缩壳阶段变量，同时要在switch语句中增添切换的条件</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202215349.png" alt="image-20230828202215349"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202407612.png" alt="image-20230828202407612"></p><p><code>Snail</code>初始化</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828202252436.png" alt="image-20230828202252436"></p><p>测试后发现还有其他问题，即蜗牛缩壳后仍然会继续移动且会重复缩壳的动画，如何修改：</p><p>先把蜗牛的几个阶段的动画的循环关闭</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828211853492.png" alt="image-20230828211853492"></p><p>然后在蜗牛缩壳脚本<code>SnailSkillState</code>中进行修改，把丢失目标时间进行赋值，以防止一直为0从而导致来回切换动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828212417426.png" alt="image-20230828212417426"></p><p>最后进行细节修改，当蜗牛没看到角色而进入探头动画的时候会自动移动一段距离，为了防止出现这样，要对怪物基类<code>Enemy</code>中的Move()方法再进行修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">           rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>同时还要让<strong>蜗牛进入缩壳的时候，玩家攻击它并不会造成伤害，反而会被攻击到</strong></p><p>在蜗牛缩壳脚本下进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213110363.png" alt="image-20230828213110363"></p><p>经过测试发现无敌状态并没有被切换，原因是因为在属性脚本<code>Character</code>中</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213441623.png" alt="image-20230828213441623"></p><p>会一直不断的通过计时器的减少从而更新无敌状态，所以我们要为蜗牛缩壳时也同时让无敌时间计时器被赋值，从而满足无敌状态的持续：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828213816664.png" alt="image-20230828213816664"></p><p>同时为了让蜗牛进入前就能先变成无敌状态，可以在进入的时候就赋值：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230828214125767.png" alt="image-20230828214125767"></p><p>PS：由于在属性脚本<code>Character</code>中将计数器属性invulnerableCounter设置为私有属性所以无法被调用，只要改为公共属性即可</p><p>最后测试时，当人物在蜗牛探出头后的背后发动攻击没有效果，所以还要再进行一小段的修改：</p><p>这是因为蜗牛的检测可以检测到攻击的图层（Player），只要把攻击的图层切换为default即可</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829151958056.png" alt="image-20230829151958056"></p><p>最后阶段性总结，蜗牛的脚本内容：</p><p>蜗牛的逻辑脚本<code>Snail</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Snail</span> : <span class="title">Enemy</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        patrolState = <span class="keyword">new</span> SnailPatrolState();</span><br><span class="line">        skillState = <span class="keyword">new</span> SnailSkillState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蜗牛的巡逻状态脚本<code>SnailPatrolState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到缩壳(Skill)状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Skill);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蜗牛的缩壳阶段脚本<code>SnailSkillState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SnailSkillState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Skill&quot;);</span></span><br><span class="line">        <span class="comment">//进入缩壳直接把速度写为0即可</span></span><br><span class="line">        currentEnemy.currentSpeed = <span class="number">0</span>;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;hide&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        currentEnemy.anim.SetTrigger(<span class="string">&quot;skill&quot;</span>);</span><br><span class="line"></span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        <span class="comment">//蜗牛进入缩壳阶段时切换为无敌状态</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerable= <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//同时为无敌计时器赋值为丢失目标前的计时(进入时就先启动一次)</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerableCounter = currentEnemy.lostTimeCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line">        <span class="comment">//同时为无敌计时器赋值为丢失目标前的计时</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerableCounter = currentEnemy.lostTimeCounter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;end&quot;);</span></span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;hide&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//退出缩壳阶段则退出无敌状态</span></span><br><span class="line">        currentEnemy.GetComponent&lt;Character&gt;().invulnerable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物基类<code>Enemy</code>：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明该组件的使用或者被调用都必须要有这三个组件，如果没有则自动创建！</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Rigidbody2D),typeof(Animator),typeof(PhysicsCheck))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line">    <span class="comment">//蜗牛——缩壳状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState skillState;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜗牛的蓄力准备阶段和蜗牛的探头阶段都不会有移动</span></span><br><span class="line">        <span class="keyword">if</span>(!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            NPCState.Skill=&gt; skillState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怪物————蜜蜂"><a href="#怪物————蜜蜂" class="headerlink" title="怪物————蜜蜂"></a>怪物————蜜蜂</h2><h3 id="蜜蜂的基本移动逻辑和动画"><a href="#蜜蜂的基本移动逻辑和动画" class="headerlink" title="蜜蜂的基本移动逻辑和动画"></a>蜜蜂的基本移动逻辑和动画</h3><h4 id="蜜蜂的动画创建"><a href="#蜜蜂的动画创建" class="headerlink" title="蜜蜂的动画创建"></a>蜜蜂的动画创建</h4><p>先对蜜蜂的动画素材进行切割，需要注意切割的方式：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829200824506.png" alt="image-20230829200824506"></p><p>将第一帧动画作为模型放置上去</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201103430.png" alt="image-20230829201103430"></p><p>同时也修改蜜蜂的图层设置，可以跟其他两种怪物一样设置为Middle层下第1层</p><p>接下来创建蜜蜂的逻辑脚本<code>Bee</code>，同时挂载到蜜蜂模型下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201412534.png" alt="image-20230829201412534"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201435265.png" alt="image-20230829201435265"></p><p>然后为蜜蜂模型添加碰撞体，这里需要注意的是：蜜蜂设定上为可以穿越地图障碍，所以只需要一个自己自身的胶囊碰撞体即可：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201751890.png" alt="image-20230829201751890"></p><p>然后创建蜜蜂的动画文件夹，创建蜜蜂的动画控制器，并为蜜蜂的动画组件进行绑定：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829201934290.png" alt="image-20230829201934290"></p><p>创建蜜蜂需要的各个动画，主要有几个阶段：</p><ul><li>蜜蜂正常飞行</li><li>蜜蜂追击飞行</li><li>蜜蜂攻击</li><li>蜜蜂受伤</li><li>蜜蜂死亡</li></ul><p>蜜蜂的正常飞行动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829202746426.png" alt="image-20230829202746426"></p><p>蜜蜂的追击动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204158279.png" alt="image-20230829204158279"></p><p>蜜蜂的受伤动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204319820.png" alt="image-20230829204319820"></p><p>蜜蜂的攻击动画：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204422208.png" alt="image-20230829204422208"></p><p>同时调整一下动画，将受伤和攻击动画的循环播放都取消了：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829204501786.png" alt="image-20230829204501786"></p><h4 id="▲蜜蜂的基本移动逻辑"><a href="#▲蜜蜂的基本移动逻辑" class="headerlink" title="▲蜜蜂的基本移动逻辑"></a>▲蜜蜂的基本移动逻辑</h4><p>蜜蜂的移动逻辑为： 为<strong>蜜蜂固定在一个点位，然后在该点位的一定空间范围内不固定地进行飞行，当蜜蜂在该范围内检测到玩家，则切换为追击状态</strong></p><p>如果用<strong>图形化</strong>来标识，则在unity的UI上的#Scene窗口可以看到有一个基于圆点的不动的圈，蜜蜂在该圈里实现随机移动，又有另外一个圈一直基于蜜蜂为圆心而移动</p><p>先创建蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829210748273.png" alt="image-20230829210748273"></p><p>同时回到unity页面上修改蜜蜂的基础内容：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829210909767.png" alt="image-20230829210909767"></p><h5 id="蜜蜂检测重写"><a href="#蜜蜂检测重写" class="headerlink" title="蜜蜂检测重写"></a>蜜蜂检测重写</h5><p>而蜜蜂的检测器要进行重做，蜜蜂的检测是要围绕蜜蜂在巡逻过程中周遭范围内进行的检测，在蜜蜂的逻辑脚本<code>Bee</code>中进行方法的重写：</p><p>对<strong>玩家的检测</strong>方法重写：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829211818319.png" alt="image-20230829211818319"></p><p><strong>检测范围</strong>方法重写：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230829213113358.png" alt="image-20230829213113358"></p><h5 id="蜜蜂移动逻辑"><a href="#蜜蜂移动逻辑" class="headerlink" title="蜜蜂移动逻辑"></a>蜜蜂移动逻辑</h5><p>要求：在圆圈范围内随机生成点位，让蜜蜂移动到该点位，循环该步骤</p><p>首先在怪物基类<code>Enemy</code>下定义蜜蜂需要用到的属性和准备要重写的方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830125727568.png" alt="image-20230830125727568"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830130343089.png" alt="image-20230830130343089"></p><p>随后要在蜜蜂的逻辑脚本<code>Bee</code>中进行初始化处理和重写方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830132249761.png" alt="image-20230830132249761"></p><p>同时设置图形可视化，把移动范围和检测范围都显示在unity界面上</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830132618262.png" alt="image-20230830132618262"></p><p>接下来就是要设置蜜蜂移动的方法，以上只是完成了蜜蜂在范围内移动且具有检测玩家的功能而已，实际让蜜蜂能够动起来还要另外编写方法：</p><p>在蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code>下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830181326138.png" alt="image-20230830181326138"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830181807016.png" alt="image-20230830181807016"></p><p>同时也要更改蜜蜂的移动方法，重写怪物基类<code>Enemy</code>下的Move()方法：</p><p>先在继承了基类的蜜蜂逻辑脚本<code>Bee</code>下覆盖原先的Move()方法</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830182204119.png" alt="image-20230830182204119"></p><p>然后在蜜蜂巡逻脚本<code>BeePatrolState</code>下编写物理逻辑方法：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830194306310.png" alt="image-20230830194306310"></p><p>这样就完成了蜜蜂的移动</p><p>还要把蜜蜂的重力组件进行更改，由于蜜蜂是在天上飞的，所以重力要修改为0，否则蜜蜂会直接落地：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830194603865.png" alt="image-20230830194603865"></p><p>最后，蜜蜂的巡逻范围可以修改为基于初始点，在蜜蜂逻辑脚本<code>Bee</code>下：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230830195211194.png" alt="image-20230830195211194"></p><h3 id="蜜蜂的追击和攻击的实现"><a href="#蜜蜂的追击和攻击的实现" class="headerlink" title="蜜蜂的追击和攻击的实现"></a>蜜蜂的追击和攻击的实现</h3><p>蜜蜂的追击要注意的是，蜜蜂是悬在半空中，也就是追击到敌人的时候不会黏在一起，而是有一定的距离，蜜蜂的攻击也是在这个距离下就可以释放的</p><p>首先为蜜蜂添加其他基础组件<code>Attack</code>，<code>Character</code>，同时为攻击组件设定攻击距离：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105018455.png" alt="image-20230831105018455"></p><p>创建蜜蜂的追击逻辑脚本<code>BeeChaseState</code>:</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105519017.png" alt="image-20230831105519017"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831105706293.png" alt="image-20230831105706293"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110110133.png" alt="image-20230831110110133"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110156255.png" alt="image-20230831110156255"></p><p>同时还要回到蜜蜂的逻辑脚本<code>Bee</code>初始化启用<code>BeeChaseState</code>脚本</p><p>进行测试，测试发现了蜜蜂会一直翻转的问题，所以还要对蜜蜂的追击逻辑脚本进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831110706256.png" alt="image-20230831110706256"></p><h4 id="创建蜜蜂不同动画的连接"><a href="#创建蜜蜂不同动画的连接" class="headerlink" title="创建蜜蜂不同动画的连接"></a>创建蜜蜂不同动画的连接</h4><p>首先创建蜜蜂该有的连接判断值，然后进行不同动画的连线：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135300682.png" alt="image-20230831135300682"></p><p><strong>蜜蜂巡逻动画 → 蜜蜂追击动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111243487.png" alt="image-20230831111243487"></p><p><strong>蜜蜂追击动画→蜜蜂巡逻动画</strong>如上，条件改为false即可</p><p><strong>Any State → 蜜蜂受伤动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111439160.png" alt="image-20230831111439160"></p><p>蜜蜂受伤动画执行一次后就退出(<strong>蜜蜂受伤动画 → Exit</strong>)：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831111542144.png" alt="image-20230831111542144"></p><p><strong>Any State → 蜜蜂攻击动画</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135354548.png" alt="image-20230831135354548"></p><p><strong>蜜蜂攻击动画→退出</strong>：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831135438215.png" alt="image-20230831135438215"></p><p>随后在蜜蜂追击逻辑<code>BeeChaseState</code>下添加：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831134827253.png" alt="image-20230831134827253"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831134840875.png" alt="image-20230831134840875"></p><p>同时攻击的方式和方法也要再进行修改和添加，否则蜜蜂在追击到敌人并且停止而开始攻击后，如果玩家跑了，这时蜜蜂不会继续追，所以：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831140627820.png" alt="image-20230831140627820"></p><p>然后实现蜜蜂的针刺伤害，也就是当玩家被蜜蜂追击的时候，玩家受到的伤害有两种：</p><ul><li>接触伤害</li><li>针刺伤害</li></ul><p>其中，针刺伤害我们要为其加入，先在蜜蜂模型下创建一个新的模型，起名为Attack Point，然后在攻击动画中进行设置：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831195545857.png" alt="image-20230831195545857"></p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831195731078.png" alt="image-20230831195731078"></p><p>先为Attack Point添加碰撞体组件并调整参数：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831200348247.png" alt="image-20230831200348247"></p><p>最后再为该模型添加攻击逻辑<code>Attack</code>并设置伤害</p><p>经过测试，发现当玩家攻击蜜蜂时，蜜蜂没有被击退，所以还要回到蜜蜂追击逻辑<code>BeeChaseState</code>下进行修改：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831200948736.png" alt="image-20230831200948736"></p><p>同时回到界面中为事件触发器绑定对应的脚本和方法</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831203219833.png" alt="image-20230831203219833"></p><p>添加死亡动画并挂载到动画控制器上：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831205122780.png" alt="image-20230831205122780"></p><p>最后一帧销毁怪物：</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831205200782.png" alt="image-20230831205200782"></p><p>挂载到动画控制器上并连接，创建连接条件Bool类型的死亡属性dead</p><p><img src="/./../images/unity(%E5%85%AB)/image-20230831204929355.png" alt="image-20230831204929355"></p><p>最后阶段性总结，蜜蜂的脚本内容：</p><p>怪物基类<code>Enemy</code>的修改:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明该组件的使用或者被调用都必须要有这三个组件，如果没有则自动创建！</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(Rigidbody2D),typeof(Animator),typeof(PhysicsCheck))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line">    <span class="comment">//蜜蜂初始点位</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 spawnPoint;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line">    <span class="comment">//蜗牛——缩壳状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState skillState;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">        spawnPoint = transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能  初始(巡逻)状态PatrolState</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜗牛的蓄力准备阶段和蜗牛的探头阶段都不会有移动</span></span><br><span class="line">        <span class="keyword">if</span> (!anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailPreMove&quot;</span>) &amp;&amp; !anim.GetCurrentAnimatorStateInfo(<span class="number">0</span>).IsName(<span class="string">&quot;snailRecover&quot;</span>))</span><br><span class="line">            Debug.Log(<span class="string">&quot;baseMove&quot;</span>);</span><br><span class="line">            rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            NPCState.Skill=&gt; skillState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对蜜蜂：获取点位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> Vector3 <span class="title">GetNewPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> transform.position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的基本逻辑脚本<code>Bee</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Bee</span> : <span class="title">Enemy</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;移动范围&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> patrolRadius;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">base</span>.Awake();</span><br><span class="line">        patrolState = <span class="keyword">new</span> BeePatrolState();</span><br><span class="line">        chaseState = <span class="keyword">new</span> BeeChaseState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = Physics2D.OverlapCircle(transform.position, checkDistance, attackLayer);</span><br><span class="line">        <span class="keyword">if</span> (obj)</span><br><span class="line">        &#123;</span><br><span class="line">            attacker = obj.transform;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//蜜蜂检测敌人的范围可视化</span></span><br><span class="line">        Gizmos.DrawWireSphere(transform.position,checkDistance);</span><br><span class="line">        Gizmos.color = Color.green;</span><br><span class="line">        <span class="comment">//蜜蜂可巡逻轨迹的范围可视化</span></span><br><span class="line">        Gizmos.DrawWireSphere(spawnPoint, patrolRadius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Vector3 <span class="title">GetNewPoint</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> targetX = Random.Range(-patrolRadius, patrolRadius);</span><br><span class="line">        <span class="keyword">var</span> targetY = Random.Range(-patrolRadius, patrolRadius);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> spawnPoint + <span class="keyword">new</span> Vector3(targetX, targetY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的巡逻逻辑脚本<code>BeePatrolState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeePatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//目标位置(对自己)</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 target;</span><br><span class="line">    <span class="comment">//移动方向</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDir;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">        <span class="comment">//初始目标位置最开始为spawnPoint，所以调用父类方法获得</span></span><br><span class="line">        target = enemy.GetNewPoint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.FoundPlayer())</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Chase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断蜜蜂是否到达随机目标点</span></span><br><span class="line">        <span class="keyword">if</span>(Mathf.Abs(target.x - currentEnemy.transform.position.x)&lt;<span class="number">0.1f</span> &amp;&amp; Mathf.Abs(target.y - currentEnemy.transform.position.y) &lt; <span class="number">0.1f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果到达则先等待一小会</span></span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//重新生成目标点，此时就要调用子类方法随机获得</span></span><br><span class="line">            target = currentEnemy.GetNewPoint();</span><br><span class="line">        &#125;</span><br><span class="line">        moveDir = (target - currentEnemy.transform.position).normalized;</span><br><span class="line">        <span class="comment">//改变面朝方向</span></span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &gt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(moveDir.x&lt;<span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(!currentEnemy.isHurt &amp;&amp; !currentEnemy.isDead &amp;&amp; !currentEnemy.wait)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;BeeMove&quot;);</span></span><br><span class="line">            currentEnemy.rb.velocity = currentEnemy.currentSpeed * moveDir * Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.rb.velocity = Vector2.zero;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>蜜蜂的追击逻辑脚本<code>BeeChaseState</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeeChaseState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Attack attack;</span><br><span class="line">    <span class="comment">//目标位置(对敌人/玩家)</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 target;</span><br><span class="line">    <span class="comment">//移动方向</span></span><br><span class="line">    <span class="keyword">private</span> Vector3 moveDir;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> isAttack;</span><br><span class="line">    <span class="comment">//攻击频率计时器(防止蜜蜂持续攻击)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> attackRateCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.chaseSpeed;</span><br><span class="line">        attack = enemy.GetComponent&lt;Attack&gt;();</span><br><span class="line"></span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;chase&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当丢失目标后切换为巡逻状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line">        <span class="comment">//获取目标位置</span></span><br><span class="line">        target = <span class="keyword">new</span> Vector3(currentEnemy.attacker.position.x, currentEnemy.attacker.position.y + <span class="number">1.5f</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断攻击距离(进入攻击距离)</span></span><br><span class="line">        <span class="keyword">if</span>(Mathf.Abs(target.x - currentEnemy.transform.position.x)&lt;= attack.attackRange &amp;&amp; Mathf.Abs(target.y - currentEnemy.transform.position.y) &lt;= attack.attackRange)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//攻击</span></span><br><span class="line">            isAttack = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//攻击时要先停下</span></span><br><span class="line">            <span class="keyword">if</span>(!currentEnemy.isHurt)</span><br><span class="line">                currentEnemy.rb.velocity = Vector2.zero;</span><br><span class="line">            <span class="comment">//计时器</span></span><br><span class="line">            attackRateCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(attackRateCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                currentEnemy.anim.SetTrigger(<span class="string">&quot;attack&quot;</span>);</span><br><span class="line">                attackRateCounter = attack.attackRate;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//超出攻击范围</span></span><br><span class="line">        &#123;</span><br><span class="line">            isAttack= <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        moveDir = (target - currentEnemy.transform.position).normalized;</span><br><span class="line">        <span class="comment">//改变面朝方向</span></span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &gt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (moveDir.x &lt; <span class="number">0</span>)</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.isHurt &amp;&amp; !currentEnemy.isDead &amp;&amp; !isAttack)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;BeeMove&quot;);</span></span><br><span class="line">            currentEnemy.rb.velocity = currentEnemy.currentSpeed * moveDir * Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;chase&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（七）</title>
      <link href="/2023/08/08/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/"/>
      <url>/2023/08/08/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（七）"><a href="#Unity开发日记（七）" class="headerlink" title="Unity开发日记（七）"></a>Unity开发日记（七）</h1><h2 id="有限状态机与抽象类多态"><a href="#有限状态机与抽象类多态" class="headerlink" title="有限状态机与抽象类多态"></a>有限状态机与抽象类多态</h2><p>创建一个抽象基类<code>BaseState</code>作为状态机</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230808144136907.png" alt="image-20230808144136907"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230808145057814.png" alt="image-20230808145057814"></p><p>再创建一个编写野猪状态的类来实现抽象基类<code>BoarPatrolState</code>:</p><p>默认状态下会一直处于<code>巡逻状态</code>：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809154359926.png" alt="image-20230809154359926"></p><p>同时回到怪物基类<code>Enemy</code>进行修改：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809152337443.png" alt="image-20230809152337443"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809152859524.png" alt="image-20230809152859524"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809153034801.png" alt="image-20230809153034801"></p><p>最后还要回到野猪对应的脚本上进行初始化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230809154005998.png" alt="image-20230809154005998"></p><h2 id="追击状态的转换"><a href="#追击状态的转换" class="headerlink" title="追击状态的转换"></a>追击状态的转换</h2><h3 id="修改物体碰撞检测-使用BoxCast"><a href="#修改物体碰撞检测-使用BoxCast" class="headerlink" title="修改物体碰撞检测(使用BoxCast)"></a>修改物体碰撞检测(使用BoxCast)</h3><p><code>BoxCast</code>描述：</p><p><strong>沿射线投射盒体并返回有关命中对象的详细信息</strong></p><p>追击状态的实现首先要先让怪物对象发现玩家对象，这时候就要用到碰撞检测，回到怪物基类<code>Enemy</code>下进行代码的修改，通过<code>BoxCast</code>方法来进行物体检测：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810154249687.png" alt="image-20230810154249687"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810154422182.png" alt="image-20230810154422182"></p><p>其中BoxCast中的各个参数作用和意义如图：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810153953460.png" alt="image-20230810153953460"></p><p>其次要编写<strong>状态切换方法</strong>（即 巡逻状态 → 发现敌人 →切换追击状态），首先回到unity界面上，在<code>Scripts</code>文件包下再创建一个工具包<code>Utilities</code>,在下边再创建一个新的脚本<code>Enums</code>：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230810155301579.png" alt="image-20230810155301579"></p><p>在<code>Enemy</code>下编写切换状态的方法：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NPCState.Patrol =&gt; patrolState,: 这是第一个匹配模式。它表示当 state 等于 NPCState.Patrol 时，将会返回 patrolState，这可能是一个预先定义的状态对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">NPCState.Chase =&gt; chaseState,: 这是第二个匹配模式。它表示当 state 等于 NPCState.Chase 时，将会返回 chaseState，同样可能是一个预先定义的状态对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">_ =&gt; null: 这是一个默认的匹配模式，它使用 _ 作为通配符，表示对于除了前面两个模式之外的所有情况，都返回 null。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同时回到怪物的状态实现类<code>BoarPatrolState</code>下实现对应的状态切换：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827140525725.png" alt="image-20230827140525725"></p><p>这样就完成了基础的状态切换</p><p>接下来就是要编写状态切换的脚本：</p><p>首先在怪物脚本文件夹<code>Enemy</code>下创建新的状态切换脚本<code>BoarChaseState</code></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827141752397.png" alt="image-20230827141752397"></p><p>继承基础状态类并实现该抽象类，同时在怪物类<code>Boar</code>下进行初始化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143714979.png" alt="image-20230827143714979"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827142038512.png" alt="image-20230827142038512"></p><p>附带：</p><p>为了方便观察BoxCast基于什么点来发射碰撞箱进行检测，还可以回到怪物基类<code>Enemy</code>下进行修改从而实现unity界面上的可视化：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143633392.png" alt="image-20230827143633392"></p><p>为了进行检测，在选择状态中的开始阶段进行日志打印，在当前状态中的结束状态进行日志打印：</p><p>进入选择状态的开始阶段(<strong>进入选择&#x2F;追击阶段</strong>) ——</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143804494.png" alt="image-20230827143804494"></p><p>进入当前状态的结束阶段(<strong>退出当前阶段</strong>) ——</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827143824272.png" alt="image-20230827143824272"></p><p>然后回到unity中进行测试，测试前也要先调整好参数（<strong>基于怪物身上哪个点进行碰撞体的发射并检测</strong>，<strong>检测范围要多大</strong>）：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827144718035.png" alt="image-20230827144718035"></p><p>该场景下怪物是要检测玩家的图层从而切换形态，所以：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827144449860.png" alt="image-20230827144449860"></p><p>优化检测点：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">  &#123;</span><br><span class="line">      Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="切换追击状态"><a href="#切换追击状态" class="headerlink" title="切换追击状态"></a>切换追击状态</h3><p>当野猪遇到人变成追击状态时，要进行以下更改：</p><ul><li>野猪追击速度提高</li><li>当野猪撞到墙不会停顿而是返回来继续冲撞追击玩家</li></ul><p>回到野猪的选择状态脚本<code>BoarChaseState</code>中进行编辑：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827150148396.png" alt="image-20230827150148396"></p><p>随后还要进行修改，当野猪进入追击状态一段时间，丢失了玩家目标后，要重新切换回正常的巡逻状态：</p><p>首先在怪物基类<code>Enemy</code>下添加新的计时器并完成对应的计时</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151125191.png" alt="image-20230827151125191"></p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151143239.png" alt="image-20230827151143239"></p><p>然后在怪物追击状态<code>BoarChaseState</code>脚本下进行修改，实现当怪物丢失视野目标重新变成巡逻状态：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151551069.png" alt="image-20230827151551069"></p><p>同时也要为巡逻状态脚本<code>BoarPatrolState</code>进行修改，让此时怪物速度重新回到正常的速度：</p><p><img src="/./../images/unity(%E4%B8%83)/image-20230827151758407.png" alt="image-20230827151758407"></p><p>最终完成的脚本内容：</p><p>怪物基类脚本<code>Enemy</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    [<span class="meta">HideInInspector</span>]<span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 centerOffset;</span><br><span class="line">    <span class="comment">//盒子长度</span></span><br><span class="line">    <span class="keyword">public</span> Vector2 checkSize;</span><br><span class="line">    <span class="comment">//检测的距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkDistance;</span><br><span class="line">    <span class="comment">//检测的图层</span></span><br><span class="line">    <span class="keyword">public</span> LayerMask attackLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> lostTimeCounter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState patrolState;</span><br><span class="line">    <span class="comment">//当前状态</span></span><br><span class="line">    <span class="keyword">private</span> BaseState currentState;</span><br><span class="line">    <span class="comment">//选择状态</span></span><br><span class="line">    <span class="keyword">protected</span> BaseState chaseState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState = patrolState;</span><br><span class="line">        <span class="comment">//状态一进入就开启所有该被开启的功能</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逻辑状态</span></span><br><span class="line">        currentState.LogicUpdate();</span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp;&amp; !isDead &amp;&amp; !wait)</span><br><span class="line">            Move();</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentState.OnExit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!FoundPlayer()&amp;&amp;lostTimeCounter&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lostTimeCounter -= Time.deltaTime;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">FoundPlayer</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Physics2D.BoxCast(transform.position + (Vector3)centerOffset, checkSize, <span class="number">0</span>, faceDir, checkDistance, attackLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SwitchState</span>(<span class="params">NPCState state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> newState = state <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            NPCState.Patrol =&gt; patrolState,</span><br><span class="line">            NPCState.Chase =&gt; chaseState,</span><br><span class="line">            _ =&gt; <span class="literal">null</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出当前状态</span></span><br><span class="line">        currentState.OnExit();</span><br><span class="line">        <span class="comment">//切换为新的状态</span></span><br><span class="line">        currentState = newState;</span><br><span class="line">        <span class="comment">//使用当前状态</span></span><br><span class="line">        currentState.OnEnter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> 事件执行方法</span></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line">        rb.velocity= <span class="keyword">new</span> Vector2(<span class="number">0</span>, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere(transform.position + (Vector3)centerOffset+<span class="keyword">new</span> Vector3(checkDistance*-transform.localScale.x,<span class="number">0</span>), <span class="number">0.2f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>状态抽象类<code>BaseState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> Enemy currentEnemy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span>;</span><br><span class="line">    <span class="comment">//逻辑判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span>;</span><br><span class="line">    <span class="comment">//物理判断</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物当前状态(巡逻)类<code>BoarPatrolState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoarPatrolState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.normalSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span> 发现player切换到chase状态</span></span><br><span class="line">        <span class="keyword">if</span>(currentEnemy.FoundPlayer()) </span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Chase);        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//撞墙判定(巡逻状态)</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.wait = <span class="literal">true</span>;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;walk&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">        Debug.Log(<span class="string">&quot;Exit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>怪物选择状态(追击)类<code>BoarChaseState</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BoarChaseState</span> : <span class="title">BaseState</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>(<span class="params">Enemy enemy</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy = enemy;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Chase&quot;);</span></span><br><span class="line">        currentEnemy.currentSpeed = currentEnemy.chaseSpeed;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">LogicUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当丢失目标后切换为巡逻状态</span></span><br><span class="line">        <span class="keyword">if</span> (currentEnemy.lostTimeCounter &lt;= <span class="number">0</span>)</span><br><span class="line">            currentEnemy.SwitchState(NPCState.Patrol);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当进入追击状态时无视撞墙等待</span></span><br><span class="line">        <span class="keyword">if</span> (!currentEnemy.physicsCheck.isGround || (currentEnemy.physicsCheck.touchLeftWall &amp;&amp; currentEnemy.faceDir.x &lt; <span class="number">0</span>) || (currentEnemy.physicsCheck.touchRightWall &amp;&amp; currentEnemy.faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            currentEnemy.transform.localScale = <span class="keyword">new</span> Vector3(currentEnemy.faceDir.x, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PhysicsUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExit</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        currentEnemy.lostTimeCounter = currentEnemy.lostTime;</span><br><span class="line">        currentEnemy.anim.SetBool(<span class="string">&quot;run&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（六）</title>
      <link href="/2023/08/02/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/"/>
      <url>/2023/08/02/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（六）"><a href="#Unity开发日记（六）" class="headerlink" title="Unity开发日记（六）"></a>Unity开发日记（六）</h1><h2 id="怪物基本的移动逻辑和动画"><a href="#怪物基本的移动逻辑和动画" class="headerlink" title="怪物基本的移动逻辑和动画"></a>怪物基本的移动逻辑和动画</h2><h3 id="移动逻辑"><a href="#移动逻辑" class="headerlink" title="移动逻辑"></a>移动逻辑</h3><p>先在<code>Scripts</code>文件下创建存储怪物脚本的Enemy，随后创建一个基类Enemy作为敌人都会继承的父类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802141848929.png" alt="image-20230802141848929"></p><p>然后创建野猪对应的脚本<code>Boar</code>，其中Boar类要继承Enemy这个父类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802142709916.png" alt="image-20230802142709916"></p><p>然后让野猪绑定对应的脚本：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802142317769.png" alt="image-20230802142317769"></p><p>为野猪添加动画组件（Animator）：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802144518105.png" alt="image-20230802144518105"></p><p>编辑怪物的基本类<code>Enemy</code>：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802144456327.png" alt="image-20230802144456327"></p><h3 id="动画编辑"><a href="#动画编辑" class="headerlink" title="动画编辑"></a>动画编辑</h3><p>先在<code>Animation</code>文件下创建存放怪物动画的文件包Enemies，然后创建存放野猪动画的包Boar：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145350099.png" alt="image-20230802145350099"></p><p>创建动画控制器<code>Animator</code>:</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145502644.png" alt="image-20230802145502644"></p><p>野猪的动画组件也要绑定该控制器：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145550405.png" alt="image-20230802145550405"></p><p>回到动画控制器创建野猪需要的动画，首先创建待机时的动画：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802145830073.png" alt="image-20230802145830073"></p><p>然后再对怪物正常走路的动画素材进行处理，然后再创建野猪走路的动画：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150221111.png" alt="image-20230802150221111"></p><p>下边的<code>Compression</code>设置为None</p><p>对素材进行切割：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150314243.png" alt="image-20230802150314243"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802150449775.png" alt="image-20230802150449775"></p><p>同理将追击的素材也进行处理，然后也创建对应的动画</p><p>在动画控制器中创建条件转换值，同时创建连线让不同动画进行切换：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151518671.png" alt="image-20230802151518671"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151452100.png" alt="image-20230802151452100"></p><p>具体动画条件转换为：</p><p><strong>Idle → Walk ： walk为true</strong></p><p><strong>Idle → Run：run为true</strong></p><p><strong>Walk → Run：run为true</strong></p><p>反过来则前两个都为false，但是<strong>Run → Walk的条件为：run为false，walk为true</strong></p><p>这样就完成了动画的切换</p><p>接下来要对动画在脚本中进行绑定，首先要让子类<code>Boar</code>重写父类的方法：</p><p>父类<code>Enemy</code>修改</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802152202397.png" alt="image-20230802152202397"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802151902990.png" alt="image-20230802151902990"></p><p>子类<code>Boar</code>重写方法</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230802152327604.png" alt="image-20230802152327604"></p><h2 id="撞墙判定和等候计时"><a href="#撞墙判定和等候计时" class="headerlink" title="撞墙判定和等候计时"></a>撞墙判定和等候计时</h2><p>先为野猪添加物理校测脚本（Physics Check），目的是为了进行撞墙的判定</p><p>调整参数：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805140908991.png" alt="image-20230805140908991"></p><p>然后回到脚本中修改代码，编写对墙壁的检测（左右墙壁）：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141547527.png" alt="image-20230805141547527"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141623992.png" alt="image-20230805141623992"></p><p>修改完成后回到unity界面跳转左右偏移量的参数：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230805141834662.png" alt="image-20230805141834662"></p><p>为了优化操作，不用让我们自己来实现对偏移量的修改进一步修改碰撞体碰撞的接触面，我们可以让它自动修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806115343419.png" alt="image-20230806115343419"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806115530003.png" alt="image-20230806115530003"></p><p>这样再进行测试碰撞即可</p><p>细节修改：</p><p>图层部分要修改检测的边框，不然可能导致野猪碰撞后穿模，使得没法正确判定野猪已经撞墙</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806152955241.png" alt="image-20230806152955241"></p><p>最后要实现怪物碰墙后转身，可以对怪物基类<code>Enemy</code>进行修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806153501853.png" alt="image-20230806153501853"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806153533743.png" alt="image-20230806153533743"></p><h3 id="等候计时"><a href="#等候计时" class="headerlink" title="等候计时"></a>等候计时</h3><p>为了让怪物撞击墙壁后留有等待时间再进行调头，这时候还需要多设计一个等候计时</p><p>回到怪物的基类<code>Enemy</code>脚本内进行修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154346430.png" alt="image-20230806154346430"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154931084.png" alt="image-20230806154931084"></p><p>修改前边的调头逻辑，改成设置为等待状态</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806154911693.png" alt="image-20230806154911693"></p><p>最后会遇到新的问题：</p><ul><li>野猪第一段开始时没有初始化时间，当前等待时间没有初始化</li><li>野猪第二次撞墙后转身会导致第二个碰撞点撞到墙壁从而再次进行等待计时</li></ul><p>细节修改：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230806155443641.png" alt="image-20230806155443641"></p><h2 id="怪物受伤和死亡"><a href="#怪物受伤和死亡" class="headerlink" title="怪物受伤和死亡"></a>怪物受伤和死亡</h2><h3 id="受伤和死亡动画"><a href="#受伤和死亡动画" class="headerlink" title="受伤和死亡动画"></a>受伤和死亡动画</h3><p>将受伤和死亡动画的素材都先进行处理并切割，以底部为中心：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807143656043.png" alt="image-20230807143656043"></p><p>回到动画控制器，创建新动画并将动画素材拖拽进去：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807143844780.png" alt="image-20230807143844780"></p><p>同理可以直接复制受伤的动画作为死亡动画即可</p><p>动画细节实现：</p><p>让动画播放呈现渐变效果，也就是不会一直闪烁，而是让模型逐渐透明至消失</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807144859800.png" alt="image-20230807144859800"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807145002881.png" alt="image-20230807145002881"></p><p>回到动画控制器将动画连接起来，同时创建切换动画的条件：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150229732.png" alt="image-20230807150229732"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150312501.png" alt="image-20230807150312501"></p><p>受伤和动画的连线设置还要注意一点：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807162544340.png" alt="image-20230807162544340"></p><p>最后也要把受伤和死亡动画都取消循环播放：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807150357936.png" alt="image-20230807150357936"></p><h3 id="受伤和死亡逻辑"><a href="#受伤和死亡逻辑" class="headerlink" title="受伤和死亡逻辑"></a>受伤和死亡逻辑</h3><p>定义完成动画后回到怪物的基类<code>Enemy</code>下定义受伤和死亡的逻辑：</p><ul><li>受伤</li></ul><p><img src="/./../images/unity(%E5%85%AD)/image-20230807153238300.png" alt="image-20230807153238300"></p><p>受伤要满足几个该有的细节内容：</p><p>1、受伤后如果玩家在怪物反方向，则怪物转身</p><p>2、受伤后怪物也要有一定的被击退效果</p><p>3、受伤时怪物不移动</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807153413858.png" alt="image-20230807153413858"></p><p><img src="/./../../../typora-images/image-20230807153445129.png" alt="image-20230807153445129"></p><p>细节修改：</p><p>受击后野猪从正常状态到受伤状态再到退出受伤状态，希望能够在受击方法中按顺序来，这时候可以通过<strong>携程</strong>的方式来实现</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807155557596.png" alt="image-20230807155557596"></p><p>完成基类内容的逻辑编写后，要为野猪对象受伤后的组件中的<strong>事件方法</strong>绑定目标组件或目标类：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807151834606.png" alt="image-20230807151834606"></p><p>选择要让该组件执行的方法或内容：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807151919318.png" alt="image-20230807151919318"></p><ul><li>死亡</li></ul><p>最后野猪死亡后要对野猪进行销毁</p><p>先在代码中创建死亡状态的变量，然后编写死亡的逻辑：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160325259.png" alt="image-20230807160325259"></p><p>随后要在动画控制器中选择死亡的动画，在死亡动画的最后一帧添加一个方法：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160517619.png" alt="image-20230807160517619"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160602675.png" alt="image-20230807160602675"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160618960.png" alt="image-20230807160618960"></p><p>同时回到unity界面中在野猪的基本属性脚本<code>Character</code>事件方法进行绑定：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807160955391.png" alt="image-20230807160955391"></p><p>这样就能实现野猪死亡后顺便将该对象也取消了，但是还有一个新的问题，野猪播放死亡动画的时候仍有碰撞体积，这样会导致死亡的瞬间如果碰到角色仍会让角色掉血，所以要再进行完善：</p><p>可以通过修改图层来忽略图层间的碰撞，从而达到我们要的效果</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163036546.png" alt="image-20230807163036546"></p><p>以死亡的时候让野猪切换为<code>Ignore Raycast</code>为例，如何让这个图层忽略其他图层？可以在Uniity中的设置来进行自定义忽略：</p><p>Edit → Project Setting → Physics 2D</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163406720.png" alt="image-20230807163406720"></p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163428653.png" alt="image-20230807163428653"></p><p>然后回到怪物基类中修改代码，让怪物死亡的时候就切换成<code>Ignore Raycast</code>图层，从而忽略掉角色层：</p><p><img src="/./../images/unity(%E5%85%AD)/image-20230807163617624.png" alt="image-20230807163617624"></p><p>最终代码：</p><p>怪物基类<code>Emeny</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">protected</span> Animator anim;</span><br><span class="line"></span><br><span class="line">    PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//正常速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> normalSpeed;</span><br><span class="line">    <span class="comment">//追击速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> chaseSpeed;</span><br><span class="line">    <span class="comment">//当前速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 faceDir;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform attacker;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;计时器&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//等待时间(自定义)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTime;</span><br><span class="line">    <span class="comment">//当前等待时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> waitTimeCounter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> wait;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        currentSpeed = normalSpeed;</span><br><span class="line"></span><br><span class="line">        waitTimeCounter = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        faceDir = <span class="keyword">new</span> Vector3(-transform.localScale.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((physicsCheck.touchLeftWall &amp;&amp; faceDir.x &lt; <span class="number">0</span>) || (physicsCheck.touchRightWall &amp;&amp; faceDir.x &gt; <span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            wait = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TimeCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt &amp; !isDead)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(currentSpeed * faceDir.x * Time.deltaTime, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 计时器</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TimeCounter</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait)</span><br><span class="line">        &#123;</span><br><span class="line">            waitTimeCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span>(waitTimeCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                wait = <span class="literal">false</span>;</span><br><span class="line">                waitTimeCounter = waitTime;</span><br><span class="line">                transform.localScale = <span class="keyword">new</span> Vector3(faceDir.x,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnTakeDamage</span>(<span class="params">Transform attackTrans</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        attacker = attackTrans;</span><br><span class="line">        <span class="comment">//转身</span></span><br><span class="line">        <span class="keyword">if</span> (attackTrans.position.x - transform.position.x &gt; <span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(attackTrans.position.x - transform.position.x &lt;<span class="number">0</span>)</span><br><span class="line">            transform.localScale = <span class="keyword">new</span> Vector3(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//受伤被击退</span></span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">        <span class="comment">//受击的方向</span></span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2(transform.position.x - attackTrans.position.x, <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动携程</span></span><br><span class="line">        StartCoroutine(OnHurt(dir));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//受伤携程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">OnHurt</span>(<span class="params">Vector2 dir</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.45f</span></span>)</span>;</span><br><span class="line">        isHurt= <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnDie</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.layer = <span class="number">2</span>;</span><br><span class="line">        anim.SetBool(<span class="string">&quot;dead&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁物体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DestoryAfterAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(<span class="keyword">this</span>.gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>物理检测类<code>PhysicsCheck</code>:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;检测参数&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//判断是手动还是自动</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> manual;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 leftOffset;</span><br><span class="line">    <span class="keyword">public</span> Vector2 rightOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchLeftWall;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> touchRightWall;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自动</span></span><br><span class="line">        <span class="keyword">if</span>(!manual)</span><br><span class="line">        &#123;</span><br><span class="line">            rightOffset = <span class="keyword">new</span> Vector2((coll.bounds.size.x + coll.offset.x) / <span class="number">2</span>, coll.bounds.size.y / <span class="number">2</span>);</span><br><span class="line">            leftOffset = <span class="keyword">new</span> Vector2(-rightOffset.x, rightOffset.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        isGround = Physics2D.OverlapCircle((Vector2)transform.position+bottomOffset, checkReduis, groundLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//墙体判断</span></span><br><span class="line">        touchLeftWall = Physics2D.OverlapCircle((Vector2)transform.position + leftOffset, checkReduis, groundLayer);</span><br><span class="line">        touchRightWall = Physics2D.OverlapCircle((Vector2)transform.position + rightOffset, checkReduis, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + leftOffset, checkReduis);</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + rightOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（五）</title>
      <link href="/2023/07/31/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/07/31/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（五）"><a href="#Unity开发日记（五）" class="headerlink" title="Unity开发日记（五）"></a>Unity开发日记（五）</h1><h2 id="三段攻击动画的实现"><a href="#三段攻击动画的实现" class="headerlink" title="三段攻击动画的实现"></a>三段攻击动画的实现</h2><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105524128.png" alt="image-20230731105524128"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105808903.png" alt="image-20230731105808903"></p><p>切割素材，然后创建三个动画(Animation)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731105631349.png" alt="image-20230731105631349"></p><p>以此类推将对应的素材添加到对应的动画上边，完成三段攻击动画的素材绑定</p><p>在动画控制器(Animator)中创建一个新的分层(<strong>Attack Layer</strong>)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110121968.png" alt="image-20230731110121968"></p><p>然后创建一个空的<code>Empty</code>,将三段攻击也拖进来：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110316560.png" alt="image-20230731110316560"></p><p>随后创建连线以及进入攻击状态的判断值<code>isAttack</code>，以及攻击状态的值<code>attack</code>：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731110902743.png" alt="image-20230731110902743"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111000465.png" alt="image-20230731111000465"></p><p>将其他几个攻击动画也连接到一起，条件也一样，但是设置要进行修改：</p><p><strong>第一段攻击 → 第二段攻击情况：</strong></p><ul><li>再次攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111655487.png" alt="image-20230731111655487"></p><ul><li>不再攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731111842566.png" alt="image-20230731111842566"></p><p>攻击情况下进入二段攻击，只播放90%的一段动画，不再攻击情况下退出动画</p><p><strong>第二段攻击 → 第三段攻击情况：</strong></p><ul><li>再次攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112054448.png" alt="image-20230731112054448"></p><ul><li>不再攻击情况下</li></ul><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112127452.png" alt="image-20230731112127452"></p><p>同样在进行再次攻击时播放90%动画，而不再攻击就直接退出</p><p>最后是第三段攻击播放完成后就退出了，直接绑定<code>Exit</code>即可</p><h3 id="添加攻击监听以及实现攻击动画绑定"><a href="#添加攻击监听以及实现攻击动画绑定" class="headerlink" title="添加攻击监听以及实现攻击动画绑定"></a>添加攻击监听以及实现攻击动画绑定</h3><p>在<code>Input System</code>输入系统中添加新的<code>Action</code>来监听攻击按键：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112434242.png" alt="image-20230731112434242"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731112552057.png" alt="image-20230731112552057"></p><p>在<code>PlayerAnimation</code>动画控制脚本中编辑设置动画状态的方法：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731113320731.png" alt="image-20230731113320731"></p><p>在<code>PlayerController</code>角色控制脚本中编辑攻击逻辑：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731114943442.png" alt="image-20230731114943442"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731125723472.png" alt="image-20230731125723472"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731134204302.png" alt="image-20230731134204302"></p><p>这样就完成了三段攻击动画的绑定，但是还有一个问题，由于攻击状态的持续性，可能会导致三段攻击后还会在多一段攻击，如何解决：</p><p>给三段动画都挂载上<code>Behaviour</code>，创建新的Behaviour，实现对攻击状态的取消</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731135057308.png" alt="image-20230731135057308"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230731135201526.png" alt="image-20230731135201526"></p><h2 id="实装攻击判定"><a href="#实装攻击判定" class="headerlink" title="实装攻击判定"></a>实装攻击判定</h2><p>三段攻击动画在同一帧中触发攻击方法</p><h3 id="攻击判定"><a href="#攻击判定" class="headerlink" title="攻击判定"></a>攻击判定</h3><p>首先创建三段攻击的容器，目的是为了方便我们在脚本中调用攻击方法：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802104639753.png" alt="image-20230802104639753"></p><p>为下边三个攻击容器分别添加新的碰撞组件：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802104802996.png" alt="image-20230802104802996"></p><p>勾选为Trigger状态</p><p>在攻击动画有剑影的部分选择该碰撞体的形状：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105059803.png" alt="image-20230802105059803"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105222268.png" alt="image-20230802105222268"></p><p><strong>如何让动画在播放的时候到达那一帧才启动攻击对应的碰撞体</strong>？</p><p>可以通过关闭&#x2F;开启容器来实现</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105504624.png" alt="image-20230802105504624"></p><p>在动画编辑器中添加(以第一段攻击为例)：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105751059.png" alt="image-20230802105751059"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802105930488.png" alt="image-20230802105930488"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802110009983.png" alt="image-20230802110009983"></p><p>其他时间帧都为取消勾选的状态</p><p>接下来要定义不同段攻击的攻击伤害，需要为三个攻击容器添加对应的<code>Attack</code>脚本的组件：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802110229313.png" alt="image-20230802110229313"></p><p>直接修改Damage值即可定义攻击伤害</p><p>同理为二段攻击动画，三段攻击动画都以上边的流程进行(<strong>碰撞体添加→碰撞体绑定→关键帧启用容器→添加攻击脚本→修改攻击数值</strong>)</p><p>这样就完成了三段攻击的动画判定，但是攻击脚本还有新的问题，当通过<code>Attack</code>执行攻击时，会因为本身人物碰撞体和攻击碰撞体接触而使人物自己也掉血，所以要进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802111640353.png" alt="image-20230802111640353"></p><p>只勾选Enemy即可</p><p>进行测试时，由于野猪有两个碰撞体积，我们要以其中一个作为最高碰撞优先级来进行被攻击的运算，这时就可以修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802112128332.png" alt="image-20230802112128332"></p><p>同时给野猪也添加上对应的受伤无敌</p><p>最后衍生出来还有其他问题：</p><ul><li>角色可以边走路边攻击（同时进行）</li><li>野猪不动，角色不动连续攻击无效</li></ul><h3 id="细节修改"><a href="#细节修改" class="headerlink" title="细节修改"></a>细节修改</h3><p>一、玩家攻击时无法移动</p><p>在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802112959296.png" alt="image-20230802112959296"></p><p>修改完成后进行测试，发现虽然不能边走路边攻击了，但是还是有一段位移，原因：光滑材质导致人物没有摩擦力，所以会有位移</p><p>进行修改：</p><p>创建新的光滑材质</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113304966.png" alt="image-20230802113304966"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113323178.png" alt="image-20230802113323178"></p><p>绑定创建的光滑材质</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113340558.png" alt="image-20230802113340558"></p><p>这样修改完成后优化了人物攻击后按住方向键还有一定的位移，但并没有完全实现人物定住，这种方式可以根据个人需求来使用</p><p>如果要真正实现人物定住，可以在动画控制器的<code>Behaviour</code>中直接修改，使动画播放的瞬间就默认为攻击状态：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802113803330.png" alt="image-20230802113803330"></p><p>二、修改材质，人物跳跃时切换材质</p><p>目的：跳跃时切换Wall光滑材质，落地时切换Normal光滑材质</p><p>在角色控制脚本<code>PlayerController</code>下进行修改：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115634815.png" alt="image-20230802115634815"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115645999.png" alt="image-20230802115645999"></p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115701840.png" alt="image-20230802115701840"></p><p>回到unity界面进行绑定：</p><p><img src="/./../images/unity(%E4%BA%94)/image-20230802115826153.png" alt="image-20230802115826153"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（四）</title>
      <link href="/2023/07/26/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/07/26/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（四）"><a href="#Unity开发日记（四）" class="headerlink" title="Unity开发日记（四）"></a>Unity开发日记（四）</h1><h2 id="人物属性及伤害计算"><a href="#人物属性及伤害计算" class="headerlink" title="人物属性及伤害计算"></a>人物属性及伤害计算</h2><p>选择怪物素材</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160152682-1690358691607-4.png" alt="image-20230726160152682"></p><p>对怪物素材处理后进行切割：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160419010-1690358715948-7.png" alt="image-20230726160419010"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160230023.png" alt="image-20230726160230023"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726160703067.png" alt="image-20230726160703067"></p><p>将野猪素材拖拽到<code>Hierarchy</code>界面上成为一个对象：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161201886.png" alt="image-20230726161201886"></p><p>然后为野猪对象添加组件以及进行其他设置的修改：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161230195.png" alt="image-20230726161230195"></p><ul><li>2D物体组件：</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161336789.png" alt="image-20230726161336789"></p><ul><li>2D碰撞体组件：</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726161631112.png" alt="image-20230726161631112"></p><p>设置好碰撞体体积后出现的问题有：当人物经过或碰到野猪对象会推着他走，相当于撞上了实体，而实际游戏需要是要穿过模型的，也就是两个模型之间可以穿过而不是发生碰撞</p><p>如何解决？</p><h3 id="解决不同模型碰撞问题-穿过模型"><a href="#解决不同模型碰撞问题-穿过模型" class="headerlink" title="解决不同模型碰撞问题(穿过模型)"></a>解决不同模型碰撞问题(穿过模型)</h3><p>首先先要创建两个不同的图层</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162049124.png" alt="image-20230726162049124"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162116398.png" alt="image-20230726162116398"></p><p>为不同角色绑定不同的<code>Layer</code>:</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162211864.png" alt="image-20230726162211864"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162230148.png" alt="image-20230726162230148"></p><p>接下来在野猪对象的2D碰撞体积组件(<strong>Box Collider 2D</strong>)上增加剔除不同图层的内容：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726162422628.png" alt="image-20230726162422628"></p><p>这样就完成了不同模型之间的剔除，可以相互穿过的效果</p><h3 id="通过触发器实现伤害效果"><a href="#通过触发器实现伤害效果" class="headerlink" title="通过触发器实现伤害效果"></a>通过触发器实现伤害效果</h3><p>虽然实现了模型之间可以相互穿过的效果，但是在游戏中，要让角色如果穿过怪物的话会被造成伤害，所以要使用触发器来实现我们要的效果</p><p>首先再给野猪对象添加一个胶囊类型的碰撞体组件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726163239368.png" alt="image-20230726163239368"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726163325643.png" alt="image-20230726163325643"></p><p>触发器脚本内容（测试）：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726211547249.png" alt="image-20230726211547249"></p><h3 id="创建人物属性-生命、无敌帧等"><a href="#创建人物属性-生命、无敌帧等" class="headerlink" title="创建人物属性(生命、无敌帧等)"></a>创建人物属性(生命、无敌帧等)</h3><h4 id="对象基本属性"><a href="#对象基本属性" class="headerlink" title="对象基本属性"></a>对象基本属性</h4><p>在<code>Scripts</code>下创建一个General文件，用于存储涉及人物计算内容的脚本：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726212005510.png" alt="image-20230726212005510"></p><p>可以将物理监测脚本拖到里边，创建新的用于创建人物属性的脚本<code>Character</code></p><p>然后将代码作为组件挂载到角色和怪物身上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726212159946.png" alt="image-20230726212159946"></p><p>定义人物属性内容表格：</p><table><thead><tr><th>人物属性</th><th>值类型</th></tr></thead><tbody><tr><td>最大血量</td><td>maxHealth</td></tr><tr><td>当前血量</td><td>currentHealth</td></tr><tr><td></td><td></td></tr></tbody></table><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103242277.png" alt="image-20230727103242277"></p><h4 id="对象攻击伤害"><a href="#对象攻击伤害" class="headerlink" title="对象攻击伤害"></a>对象攻击伤害</h4><p>在<code>General</code>文件下再创建一个人物攻击属性的脚本<code>Attack</code></p><p>然后将代码作为组件挂载到角色和怪物身上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230726215325495.png" alt="image-20230726215325495"></p><p>定义人物属性内容表格：</p><table><thead><tr><th>攻击属性</th><th>值类型</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>在<code>Character</code>脚本下定义一个受到攻击减少血量的方法：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103447232.png" alt="image-20230727103447232"></p><p>在<code>Attack</code>脚本下定义用于调用受到伤害进行减少的方法，由于是当角色和怪物进行<strong>接触</strong>时受到伤害，所以直接用<code>OnTriggerStay2D</code>这个已经封装好的方法即可：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727103320281.png" alt="image-20230727103320281"></p><p>编辑受到伤害的逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727105056504.png" alt="image-20230727105056504"></p><h5 id="设置无敌帧"><a href="#设置无敌帧" class="headerlink" title="设置无敌帧"></a>设置无敌帧</h5><p>由于没有设置无敌时间，所以当人物经过怪物时相当于一次性受到很多次伤害，所以我们要通过设置无敌帧来保证人物不会在碰到怪物的一瞬间丢失大量血量：</p><p>首先定义我们需要的无敌属性数值内容表格</p><table><thead><tr><th>无敌属性</th><th>值类型</th></tr></thead><tbody><tr><td>无敌时间</td><td>invulnerableDucation</td></tr><tr><td>计时器</td><td>invulnerableCounter</td></tr><tr><td>状态</td><td>invulnerable</td></tr></tbody></table><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727170630799.png" alt="image-20230727170630799"></p><p>定义逻辑：</p><p>1、定义状态更改(即受到一次伤害后就切换此时状态为无敌)</p><p>目的：保证受到伤害在一定时间内不会连续</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171024371.png" alt="image-20230727171024371"></p><p>2、在攻击造成后即刻调用状态更改方法，同时赋值给计时器</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171217165.png" alt="image-20230727171217165"></p><p>3、对计时器进行计时，使其在无敌时间后再次切回正常状态</p><p>该逻辑要在生命周期内进行，让计时器每一帧都进行计算</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171300825.png" alt="image-20230727171300825"></p><p><code>Time.deltaTime</code>概述：完成上一帧所用的时间</p><p>最后进行细节修正：</p><p><code>Attack</code>下</p><p><img src="/./../../../typora-images/image-20230727171750740.png" alt="image-20230727171750740"></p><p><code>Character</code>下</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230727171917366.png" alt="image-20230727171917366"></p><h2 id="受伤和死亡的逻辑和动画"><a href="#受伤和死亡的逻辑和动画" class="headerlink" title="受伤和死亡的逻辑和动画"></a>受伤和死亡的逻辑和动画</h2><p>死亡动画应该临界于其他所有动画之上！</p><h3 id="受伤和死亡动画"><a href="#受伤和死亡动画" class="headerlink" title="受伤和死亡动画"></a>受伤和死亡动画</h3><ul><li>受伤动画</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143528831.png" alt="image-20230728143528831"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143634190.png" alt="image-20230728143634190"></p><ul><li>死亡动画</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728143815226.png" alt="image-20230728143815226"></p><h3 id="受伤部分"><a href="#受伤部分" class="headerlink" title="受伤部分"></a>受伤部分</h3><h4 id="实现闪烁效果"><a href="#实现闪烁效果" class="headerlink" title="实现闪烁效果"></a>实现闪烁效果</h4><p>新建图画图层：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728175851676.png" alt="image-20230728175851676"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230728175920867.png" alt="image-20230728175920867"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730113458522.png" alt="image-20230730113458522"></p><p>新建动画：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729114327234.png" alt="image-20230729114327234"></p><p><strong>通过<code>Add Property</code>可以修改不同组件的参数，从而实现在一个时间轴上不同组件参数发生变化从而达到不同效果</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729115020970.png" alt="image-20230729115020970"></p><p>可以通过角色的<code>Sprite Renderer</code>(材质)更改颜色来实现闪烁效果：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729115630045.png" alt="image-20230729115630045"></p><p>回到动画界面点击Add Property添加我们需要更改的组件，同时选择我们要更改的组件里边的值：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120058423.png" alt="image-20230729120058423"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120317586.png" alt="image-20230729120317586"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230729120345687.png" alt="image-20230729120345687"></p><p>将动画添加到叠加图层(Hurt Layer)并创建切换的条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105020022.png" alt="image-20230730105020022"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105136134.png" alt="image-20230730105136134"></p><p>Setting跟前边的动画一样设置为无勾选状态，其他数值都为0即可</p><p>再设置一个返回连线，当动画播放完毕后返回原始动画：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105330911.png" alt="image-20230730105330911"></p><h5 id="▲事件方法-UnityEvent-使用方法"><a href="#▲事件方法-UnityEvent-使用方法" class="headerlink" title="▲事件方法(UnityEvent 使用方法)"></a>▲事件方法(UnityEvent 使用方法)</h5><p>在<code>PlayerAnimation</code>动画控制脚本中定义动画切换的方法，只有角色被怪物打到(受到伤害时)才会让<code>hurt</code>值被勾选，从而进行<strong>闪烁效果的播放</strong>：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730105831235.png" alt="image-20230730105831235"></p><p><code>Character</code>角色属性脚本受伤部分定义逻辑：</p><ul><li>导入事件包，通过事件类来快速编辑条件</li></ul><p><strong>目的：可以在unity的UI界面上很快添加我们需要的条件</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730110437329.png" alt="image-20230730110437329"></p><p>当在脚本中创建完成后返回unity即可看到：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730110842721.png" alt="image-20230730110842721"></p><ul><li>将我们需要的条件添加进去(将条件注册进事件中)</li></ul><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111137659.png" alt="image-20230730111137659"></p><p>这是要更改的对象，也就是<strong>条件触发的对象(Player)<strong>，然后选择Function，也就是我们要</strong>触发的组件的方法</strong></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111342721.png" alt="image-20230730111342721"></p><ul><li>启动事件</li></ul><p>直接调用Invoke方法即可</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730111857591.png" alt="image-20230730111857591"></p><h4 id="受伤后有反弹效果"><a href="#受伤后有反弹效果" class="headerlink" title="受伤后有反弹效果"></a>受伤后有反弹效果</h4><p>在<code>PlayerController</code>编写反弹逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730115708885.png" alt="image-20230730115708885"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730115849249.png" alt="image-20230730115849249"></p><p>细节修改：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730120013477.png" alt="image-20230730120013477"></p><p>实现当受伤时不能移动</p><p>在事件中注册条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730131525691.png" alt="image-20230730131525691"></p><p>这样就完成了反弹效果，但是还会有新的问题——即人物反弹距离后会一直倒退且此时无法移动，如何解决：</p><h5 id="动画过程执行代码-Animator-Behavior-代码的使用方法"><a href="#动画过程执行代码-Animator-Behavior-代码的使用方法" class="headerlink" title="动画过程执行代码(Animator Behavior 代码的使用方法)"></a>动画过程执行代码(Animator Behavior 代码的使用方法)</h5><p><strong>在动画执行过程中进行代码的变化，通过</strong><code>Animator Behavior</code>来进行实现</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133104530.png" alt="image-20230730133104530"></p><p>创建一个新的Behaviour</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133155292.png" alt="image-20230730133155292"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133316667.png" alt="image-20230730133316667"></p><p>在脚本中编辑新逻辑：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730133914793.png" alt="image-20230730133914793"></p><p>这样就完成了反弹效果的最终实现</p><h3 id="死亡部分"><a href="#死亡部分" class="headerlink" title="死亡部分"></a>死亡部分</h3><p>在动画控制器中的叠加图层添加动画，同时创建一个新的判断值<code>isDead</code></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730140558570.png" alt="image-20230730140558570"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730140723952.png" alt="image-20230730140723952"></p><p>创建连线并添加条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141006077.png" alt="image-20230730141006077"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141022745.png" alt="image-20230730141022745"></p><p>连接退出的条件：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141124749.png" alt="image-20230730141124749"></p><p>在<code>Character</code>角色属性脚本中添加死亡逻辑：</p><p>先创建对应的死亡事件，这样可以在unityUI界面上直接添加条件</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141558463.png" alt="image-20230730141558463"></p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730141614824.png" alt="image-20230730141614824"></p><h4 id="死亡后不能操作"><a href="#死亡后不能操作" class="headerlink" title="死亡后不能操作"></a>死亡后不能操作</h4><p>在<code>PlayerController</code>角色控制脚本中添加新的死亡逻辑，实现死亡后不允许操作的逻辑：</p><p>创建isDead布尔类型变量，创建死亡对应的方法来关闭玩家操作内容</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142014143.png" alt="image-20230730142014143"></p><p>在<code>PlayerAnimation</code>动画控制脚本中添加对应的获取死亡条件(isDead)值的方法：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142215642.png" alt="image-20230730142215642"></p><p>最后将要进行的组件的方法作为条件注册到事件上：</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730142651164.png" alt="image-20230730142651164"></p><p>这样就完成了死亡事件的绑定与动画的播放，但还有一个问题——即人物死亡动画会一直播放，该如何解决：</p><p>在动画控制器中<strong>取消循环播放的勾选</strong>即可</p><p><img src="/./../images/unity(%E5%9B%9B)/image-20230730143102875.png" alt="image-20230730143102875"></p><p>这样就完成了整个死亡过程的功能实现</p><p>最终的脚本代码：</p><p>角色控制脚本<code>PlayerController</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//跑步速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//行走速度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跳跃的力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否下蹲</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line">    <span class="comment">//碰撞体的两个变量(大小和位移)</span></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isHurt;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isDead;</span><br><span class="line">    <span class="comment">//反弹力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hurtForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isHurt)</span><br><span class="line">            Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="comment">//private void OnTriggerStay2D(Collider2D other)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    Debug.Log(other.name);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色受伤对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GerHurt</span>(<span class="params">Transform attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        isHurt = <span class="literal">true</span>;</span><br><span class="line">        rb.velocity = Vector2.zero;</span><br><span class="line">        Vector2 dir = <span class="keyword">new</span> Vector2((transform.position.x - attacker.position.x), <span class="number">0</span>).normalized;</span><br><span class="line"></span><br><span class="line">        rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//角色死亡对应的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayerDead</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        isDead = <span class="literal">true</span>;</span><br><span class="line">        inputControl.GamePlay.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色(对象)属性脚本<code>Character</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.Events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Character</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本属性&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> maxHealth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> currentHealth;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;受伤无敌&quot;</span>)</span>]</span><br><span class="line">    <span class="comment">//无敌时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> invulnerableDucation;</span><br><span class="line">    <span class="comment">//计时器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> invulnerableCounter;</span><br><span class="line">    <span class="comment">//状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> invulnerable;</span><br><span class="line">    <span class="comment">//受伤事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent&lt;Transform&gt; OnTakeDamage;</span><br><span class="line">    <span class="comment">//死亡事件</span></span><br><span class="line">    <span class="keyword">public</span> UnityEvent OnDie;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//初始化血量(开头血量为满血)</span></span><br><span class="line">        currentHealth = maxHealth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新计时器</span></span><br><span class="line">            invulnerableCounter -= Time.deltaTime;</span><br><span class="line">            <span class="keyword">if</span> (invulnerableCounter &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//更新状态</span></span><br><span class="line">                invulnerable = <span class="literal">false</span>;   </span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被攻击方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params">Attack attacker</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (invulnerable)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//Debug.Log(attacker.damage);</span></span><br><span class="line">        <span class="keyword">if</span>(currentHealth - attacker.damage &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth -= attacker.damage;</span><br><span class="line">            TriggerInvulnerable();</span><br><span class="line">            <span class="comment">//触发受伤</span></span><br><span class="line">            OnTakeDamage?.Invoke(attacker.transform);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            currentHealth = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//触发死亡动画</span></span><br><span class="line">            OnDie?.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriggerInvulnerable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!invulnerable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更新状态</span></span><br><span class="line">            invulnerable = <span class="literal">true</span>;</span><br><span class="line">            invulnerableCounter = invulnerableDucation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色(对象)攻击属性脚本<code>Attack</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Attack</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> damage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> attackRange;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> attackRate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnTriggerStay2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        other.GetComponent&lt;Character&gt;()?.TakeDamage(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>角色动画控制方法<code>PlayerAnimation</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAnimation</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册的是动画控制器——Animator</span></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理所有动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityX&quot;</span>, Mathf.Abs(rb.velocity.x));</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityY&quot;</span>,rb.velocity.y);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isGround&quot;</span>, physicsCheck.isGround);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isCrouch&quot;</span>, playerController.isCrouch);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isDead&quot;</span>, playerController.isDead);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PlayHurt</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetTrigger(<span class="string">&quot;hurt&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（三）</title>
      <link href="/2023/07/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/07/23/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（三）"><a href="#Unity开发日记（三）" class="headerlink" title="Unity开发日记（三）"></a>Unity开发日记（三）</h1><h2 id="物理环境监测"><a href="#物理环境监测" class="headerlink" title="物理环境监测"></a>物理环境监测</h2><p>为角色新建物理监测脚本：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724144429242.png" alt="image-20230724144429242"></p><p>将脚本作为组件添加到Player上边</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724144544646.png" alt="image-20230724144544646"></p><p>开始编写脚本内容来实现物理环境监测</p><p>1、采用<code>Physics2D.OverlapCirle</code>函数来实现对地面的检测（即角色是否站在地面上）</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150614684.png" alt="image-20230724150614684"></p><p>其他参数作用(参考unity帮助文档)：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150329357.png" alt="image-20230724150329357"></p><p>角色坐标位置原点：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724150734119.png" alt="image-20230724150734119"></p><p>如果角色是在地面上，也就是此时的OverlapCircle函数返回为<code>true</code>，赋值给isGround：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151028928.png" alt="image-20230724151028928"></p><p><strong><code>groundLayer</code>字段的作用：</strong></p><p>如果同地面上（不同图层）有不同的内容，诸如草坪，花朵，蘑菇等等物品，此时同处于地面，但实际我们要检测的是地面，这时候就要通过指定图层（地面所在图层）来保证准确度</p><p>2、为地面图层添加指定的<code>Layer</code></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151544307.png" alt="image-20230724151544307"></p><p>随后返回Player，为Player绑定字段（<strong>checkRedius，GroundLayer</strong>）需要的内容：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724151737704.png" alt="image-20230724151737704"></p><p>最后进行测试，运行后看角色落地时<code>Is Ground</code>会不会自动打勾(true)</p><p>3、两个脚本进行交互，修改代码使得只有在地面上人物才能跳跃</p><p>在<code>Player Controller</code>脚本获得<code>Physics Check</code>组件并实现代码的修改：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724152639393.png" alt="image-20230724152639393"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724152708180.png" alt="image-20230724152708180"></p><h3 id="提高物理环境检测度"><a href="#提高物理环境检测度" class="headerlink" title="提高物理环境检测度"></a>提高物理环境检测度</h3><p>希望通过设置一个可以移动的球形来提高检测的精确度</p><p>在<code>PhysicsCheck</code>脚本中编写一个数组作为脚底位移差值（类型为Vector2，也就是坐标）：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724153317363.png" alt="image-20230724153317363"></p><p>如何把位置绘制出来？</p><p>可以通过<code>OnDrawGizmosSelected()</code>来编写对应的内容，从而实现在我们的人物检测点上绘制出可以偏移的圆：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724154852398.png" alt="image-20230724154852398"></p><p>Gizmos → <img src="/./../../../typora-images/image-20230724154924999.png" alt="image-20230724154924999"></p><p>最终呈现效果为：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155117790.png" alt="image-20230724155117790"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155225067.png" alt="image-20230724155225067"></p><h3 id="为人物物理设置光滑材质"><a href="#为人物物理设置光滑材质" class="headerlink" title="为人物物理设置光滑材质"></a>为人物物理设置光滑材质</h3><p>目的：让人物不会黏在墙上</p><p>在Setting文件夹下边创建Physics Material文件夹，然后创建一个新的物理材质</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155853805.png" alt="image-20230724155853805"></p><p>将材质的摩擦力设置为0，然后为其添加到角色的<code>Capsule Collider 2D</code>上：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724155953343.png" alt="image-20230724155953343"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230724160045644.png" alt="image-20230724160045644"></p><h2 id="人物动画"><a href="#人物动画" class="headerlink" title="人物动画"></a>人物动画</h2><h3 id="创建动画控制器-Animator"><a href="#创建动画控制器-Animator" class="headerlink" title="创建动画控制器(Animator)"></a>创建动画控制器(Animator)</h3><p>定位我们需要的动画素材，对动画素材进行切割(前边已经完成好)</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725144257817.png" alt="image-20230725144257817"></p><p>为角色添加<code>Animator</code>组件（<strong>动画控制器</strong>）</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725144627362.png" alt="image-20230725144627362"></p><p>可以看出还需要添加控制器，所以下一步是创建动画控制器：</p><p>在Assets文件夹下创建Animations文件夹，用于存放接下来需要的各个角色对象的动画控制器，然后创建对应需要的角色文件夹</p><p>在文件夹下再创建<code>Animator Controller</code></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145027557.png" alt="image-20230725145027557"></p><p>然后将该动画控制器添加到<code>Animator</code>组件中的Controller进行绑定：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145125736.png" alt="image-20230725145125736"></p><p>如何查看角色的动画控制器？</p><p>选中角色后，在Window界面上点击Animator进入动画控制器界面</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145342160.png" alt="image-20230725145342160"></p><p>界面效果如图：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145401878.png" alt="image-20230725145401878"></p><h3 id="创建动画-Animation"><a href="#创建动画-Animation" class="headerlink" title="创建动画(Animation)"></a>创建动画(Animation)</h3><p>点击角色，然后在Window选项中选择Animation，创建单个动画</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145801677.png" alt="image-20230725145801677"></p><p>随后会打开对应的页面</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725145822866.png" alt="image-20230725145822866"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150003535.png" alt="image-20230725150003535"></p><p>选中我们要播放的动画，将其拖拽到Animation界面上：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150204019.png" alt="image-20230725150204019"></p><p>可以在Animation界面的播放按钮预览当前动画效果</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150430260.png" alt="image-20230725150430260"></p><p><code>Samples</code>越高播放越快</p><p>以上就完成了角色待机动画的创建，接下来还要进行其他动作动画（跳跃，攻击等）的创建，快捷创建Animations：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725150953853.png" alt="image-20230725150953853"></p><p>创建跑步的Animation，将对应的动画片段丢到Animation界面中即可：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725151344859.png" alt="image-20230725151344859"></p><h3 id="动画控制器控制动画"><a href="#动画控制器控制动画" class="headerlink" title="动画控制器控制动画"></a>动画控制器控制动画</h3><p>动画(Animation)创建完毕后会在<strong>Animatior</strong>界面上出现对应的容器，在界面中每个块也叫做<strong>状态</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153029470.png" alt="image-20230725153029470"></p><p>不同状态之间建立连接：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153113643.png" alt="image-20230725153113643"></p><p>创建连接线连接到另外一个状态上</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153140621.png" alt="image-20230725153140621"></p><h4 id="为动画切换设置条件"><a href="#为动画切换设置条件" class="headerlink" title="为动画切换设置条件"></a>为动画切换设置条件</h4><p>选中连接线，可以在右边界面看到条件框：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153444747.png" alt="image-20230725153444747"></p><p>**PS:**虽然右边有条件框，但实际上动画切换条件的创建是在左边的<code>Parameters</code>选项下边进行创建</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725153843140.png" alt="image-20230725153843140"></p><p>在Parameters下创建对应的条件内容后，回到右边的<code>Conditions</code>框架内添加我们刚创建的条件内容：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154055498.png" alt="image-20230725154055498"></p><p>然后还要对Setting里边的内容进行更改：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154245042.png" alt="image-20230725154245042"></p><p>由于是2D游戏，我们不需要设置以上内容，所以全部关闭及设置0</p><p>然后补齐条件，将其设置为小于0.1时就相当于切换跑步动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725160331146.png" alt="image-20230725160331146"></p><p>此时还没有完成动画切换条件的设置，因为虽然条件设置了只有<code>&lt; 0.1</code>时会让动画控制器切换动画，但是我们还缺少给<code>velocityX</code>赋值的内容，所以接下来就是要在脚本内容中设置如何获得我们需要的数值</p><h3 id="创建管理控制动画的脚本"><a href="#创建管理控制动画的脚本" class="headerlink" title="创建管理控制动画的脚本"></a>创建管理控制动画的脚本</h3><p>在<code>Script</code>下Player文件夹下创建新的控制动画的脚本<code>PlayerAnimation</code>并将其添加到角色的组件中去：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725154759439.png" alt="image-20230725154759439"></p><p>编辑脚本内容：</p><p><strong>通过采用Animator类中的SetFloat方法来设置我们需要的切换动画条件的值</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725155550588.png" alt="image-20230725155550588"></p><p><code>SetFloat</code>方法内参数的含义：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725155120625.png" alt="image-20230725155120625"></p><p>需要注意的是：</p><p>此时第二个参数<code>rb.velocity.x</code>虽然获取到了x轴的数值，但是由于我们在切换动画的条件内设置的是<code>&gt; velocity.x</code>，这会导致当我们启动的时候，角色向左跑(<strong>velocity.x&lt;0，为负数**)不会有跑步动画，但是向右跑(**velocity.x&gt;0，为正数</strong>)会有跑步动画</p><p>所以要进行修改：<code>Mathf.Abs</code>取绝对值</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725160121359.png" alt="image-20230725160121359"></p><h3 id="人物行走设定"><a href="#人物行走设定" class="headerlink" title="人物行走设定"></a>人物行走设定</h3><p>目的：当我们按下<code>Shift</code>键时强制切换为<strong>行走状态</strong></p><p>在输入系统<code>Input System</code>下的人物控制器创建新的<code>Action</code>:</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728144847625.png" alt="image-20230728144847625"></p><p>添加监听的按键：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728145053304.png" alt="image-20230728145053304"></p><p>在<code>PlayerController</code>脚本中编写实现走路的逻辑： 即<strong>速度减少一半相当于走路</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728145920650.png" alt="image-20230728145920650"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728151410721.png" alt="image-20230728151410721"></p><p>这样完成后还有其它问题：</p><ul><li>切换走路后再切回来，速度没有变化(speed&#x2F;2)</li><li>切换走路后没有变成走路动画</li></ul><p>细节修改：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">   &#123;</span><br><span class="line">      ........</span><br><span class="line">          </span><br><span class="line">       <span class="meta">#<span class="keyword">region</span> 切换行走状态</span></span><br><span class="line">       runSpeed = speed;</span><br><span class="line">       </span><br><span class="line">       inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">           &#123;</span><br><span class="line">               speed = walkSpeed;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line"></span><br><span class="line">       inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">           &#123;</span><br><span class="line">               speed = runSpeed;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用<code>region - endregion</code>方便管理代码块</p><p>添加正常走路动画并为其设置相应的动画转换连接线和切换条件</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725164245728.png" alt="image-20230725164245728"></p><h2 id="跳跃动画"><a href="#跳跃动画" class="headerlink" title="跳跃动画"></a>跳跃动画</h2><p>跳跃动画主要分为：<strong>起跳阶段和落地阶段</strong></p><p>先按人物基础动画制作流程将跳跃的四个阶段和落地的一个阶段对应的五个Animation创建出来：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205145663.png" alt="image-20230725205145663"></p><p>由于这五个动画本质上都是实现跳跃，只是跳跃时期的不同阶段而已，所以可以采用<strong>混合树</strong>的方法将其整合到一起：</p><p>1、先创建混合树</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205422475.png" alt="image-20230725205422475"></p><p>双击进入混合树的编辑页面：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205549185.png" alt="image-20230725205549185"></p><p>2、在Motion列表中添加需要的一系列动画(Animation)</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725205803524.png" alt="image-20230725205803524"></p><p>将四个动画全部添加上去</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230725210026603.png" alt="image-20230725210026603"></p><p>同时在动画控制器左边的框内要新创建一个Float值<code>velocityY</code>，最终可以看到</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726112724341.png" alt="image-20230726112724341"></p><p>3、设置混合树切换不同动画的数值结点(Threshold)</p><p>而如何设置不同动画对应的值：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726112227200.png" alt="image-20230726112227200"></p><p>同时要回到<code>PlayerAnimation</code>脚本中添加实时获取<code>velocityY</code>值的代码：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726113149472.png" alt="image-20230726113149472"></p><h3 id="动画控制器绑定跳跃动画"><a href="#动画控制器绑定跳跃动画" class="headerlink" title="动画控制器绑定跳跃动画"></a>动画控制器绑定跳跃动画</h3><h4 id="起跳阶段绑定"><a href="#起跳阶段绑定" class="headerlink" title="起跳阶段绑定"></a>起跳阶段绑定</h4><p>创建完成跳跃动画(<strong>起跳阶段</strong>)的混合树后，接下来就是要在动画控制器中绑定这个跳跃状态了，而我们要实现可以使用跳跃来打断其他动画的效果，就要利用初始的<code>Any State</code>连接我们的跳跃状态：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114132624.png" alt="image-20230726114132624"></p><p>同时在左边也创建一个新的判断值（isGround）：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114206154.png" alt="image-20230726114206154"></p><p>然后绑定该判断值以及修改其它设置：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114342644.png" alt="image-20230726114342644"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114406211.png" alt="image-20230726114406211"></p><p>同时也要在<code>PlayerAnimation</code>脚本中编写获取该值的代码：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726120633315.png" alt="image-20230726120633315"></p><p>这样就设置好了跳跃起跳这一阶段的动画，随后还要把跳跃落地阶段的动画添加进来，然后和跳跃起跳阶段的动画连接起来，实现整个跳跃的完整流程</p><h4 id="落地阶段绑定"><a href="#落地阶段绑定" class="headerlink" title="落地阶段绑定"></a>落地阶段绑定</h4><p>连接落地动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114801332.png" alt="image-20230726114801332"></p><p>设置切换的条件以及修改设置</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726114849101.png" alt="image-20230726114849101"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726120833927.png" alt="image-20230726120833927"></p><p>最后将整个跳跃动画完成之后再进入初始的动画：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726115125515.png" alt="image-20230726115125515"></p><p>这样就能<strong>实现跳跃动作可以先打断其他动画的效果了</strong></p><h4 id="细节打断落地"><a href="#细节打断落地" class="headerlink" title="细节打断落地"></a>细节打断落地</h4><p>当在台阶下落地立马跑步的时候，把落地动画给打断</p><p>在落地阶段动画中连接<code>Exit</code>状态，并添加判断条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230726121818956.png" alt="image-20230726121818956"></p><h2 id="下蹲动画与逻辑"><a href="#下蹲动画与逻辑" class="headerlink" title="下蹲动画与逻辑"></a>下蹲动画与逻辑</h2><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>下蹲动画分为两个阶段：<strong>开始下蹲</strong> 和 <strong>持续蹲姿</strong></p><p>流程为：当我们按下下蹲键时，先进行开始下蹲动画然后再进行持续蹲姿，如果我们没有送掉下蹲键那就一直保持蹲姿状态，一旦松掉按键就会恢复</p><ul><li>开始下蹲</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154049341.png" alt="image-20230728154049341"></p><ul><li>持续蹲姿</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154147725.png" alt="image-20230728154147725"></p><p>动画创建完成后接下来就是要进行绑定和条件切换</p><p>首先创建要用到的条件值<code>isCrouch</code>:</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154750038.png" alt="image-20230728154750038"></p><h4 id="使用次级动画选择器-Sub-State-进行内部切换"><a href="#使用次级动画选择器-Sub-State-进行内部切换" class="headerlink" title="使用次级动画选择器(Sub-State)进行内部切换"></a>使用次级动画选择器(Sub-State)进行内部切换</h4><p><img src="/./../images/unity(%E4%B8%89)/image-20230728154940350.png" alt="image-20230728154940350"></p><p>创建连接线并设置条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162050645.png" alt="image-20230728162050645"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155102007.png" alt="image-20230728155102007"></p><p><strong>进入次级动画选择器进行动画切换的设置：</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155430276.png" alt="image-20230728155430276"></p><p>设置两个动画之间的连线并调整条件设置：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155537099.png" alt="image-20230728155537099"></p><p>设置动画退出的连线并设置条件：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728155728936.png" alt="image-20230728155728936"></p><h3 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h3><p>在<code>PlayerController</code>控制脚本下进行下蹲逻辑的编辑：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160320535.png" alt="image-20230728160320535"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160403803.png" alt="image-20230728160403803"></p><p>将动画切换的条件也在<code>PlayerAnimation</code>脚本下进行添加：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728160829537.png" alt="image-20230728160829537"></p><p>通过切换模式可以实现在不同界面上观看启动后的游戏画面：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162556187.png" alt="image-20230728162556187"></p><p>方便在运行时测试并观察碰撞体效果：</p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164018449.png" alt="image-20230728164018449"></p><h3 id="碰撞体在下蹲时也修改"><a href="#碰撞体在下蹲时也修改" class="headerlink" title="碰撞体在下蹲时也修改"></a>碰撞体在下蹲时也修改</h3><p>碰撞体的重要变量有：</p><ul><li>偏移位置Offset(X,Y)</li><li>长度Size(X,Y)</li></ul><p><img src="/./../images/unity(%E4%B8%89)/image-20230728162810773.png" alt="image-20230728162810773"></p><p>由于两个变量都是(X,Y)，所以写入代码时定义的变量为<strong>Vector2</strong></p><p>在<code>PlayerController</code>脚本内编辑碰撞体变化的逻辑：</p><p><strong>碰撞体的大小和位移的修改要在unity界面自己根据实际需求进行调整最后确定</strong></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164054457.png" alt="image-20230728164054457"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164151581.png" alt="image-20230728164151581"></p><p><img src="/./../images/unity(%E4%B8%89)/image-20230728164232838.png" alt="image-20230728164232838"></p><p>最后可以在完善移动的细节：即当人物蹲下时不能进行移动</p><p>最终脚本修改完成后的代码：</p><p>人物控制脚本<code>PlayerController</code>代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CapsuleCollider2D coll;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> runSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> walkSpeed =&gt; runSpeed / <span class="number">2.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isCrouch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector2 originalOffset;</span><br><span class="line">    <span class="keyword">private</span> Vector2 originalSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        physicsCheck = GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line"></span><br><span class="line">        coll= GetComponent&lt;CapsuleCollider2D&gt;();</span><br><span class="line">        originalOffset = coll.offset;</span><br><span class="line">        originalSize = coll.size;</span><br><span class="line"></span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> 强制走路</span></span><br><span class="line">        runSpeed = speed;</span><br><span class="line">        inputControl.GamePlay.WalkButtom.performed += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = walkSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.WalkButtom.canceled += ctx =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (physicsCheck.isGround)</span><br><span class="line">            &#123;</span><br><span class="line">                speed = runSpeed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下蹲</span></span><br><span class="line">        isCrouch = inputDirection.y &lt; <span class="number">-0.5f</span> &amp;&amp; physicsCheck.isGround;</span><br><span class="line">        <span class="keyword">if</span> (isCrouch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//修改碰撞体位移和大小</span></span><br><span class="line">            coll.offset = <span class="keyword">new</span> Vector2(<span class="number">-0.05f</span>, <span class="number">0.85f</span>);</span><br><span class="line">            coll.size = <span class="keyword">new</span> Vector2(<span class="number">0.7f</span>, <span class="number">1.7f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//还原碰撞体的参数</span></span><br><span class="line">            coll.offset = originalOffset;</span><br><span class="line">            coll.size = originalSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="comment">//private void OnTriggerStay2D(Collider2D other)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    Debug.Log(other.name);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(physicsCheck.isGround)</span><br><span class="line">            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>环境监测脚本<code>Physics Check</code>代码:</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PhysicsCheck</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> Vector2 bottomOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> checkReduis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;状态&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> isGround;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Check();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Check</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检测地面</span></span><br><span class="line">        isGround = Physics2D.OverlapCircle((Vector2)transform.position+bottomOffset, checkReduis, groundLayer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmosSelected</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.DrawWireSphere((Vector2)transform.position + bottomOffset, checkReduis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制动画的脚本<code>Player Animation</code>代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerAnimation</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册的是动画控制器——Animator</span></span><br><span class="line">    <span class="keyword">private</span> Animator anim;</span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line">    <span class="keyword">private</span> PhysicsCheck physicsCheck;</span><br><span class="line">    <span class="keyword">private</span> PlayerController playerController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        physicsCheck= GetComponent&lt;PhysicsCheck&gt;();</span><br><span class="line">        playerController= GetComponent&lt;PlayerController&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetAnimation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//管理所有动画</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAnimation</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityX&quot;</span>, Mathf.Abs(rb.velocity.x));</span><br><span class="line">        anim.SetFloat(<span class="string">&quot;velocityY&quot;</span>,rb.velocity.y);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isGround&quot;</span>, physicsCheck.isGround);</span><br><span class="line">        anim.SetBool(<span class="string">&quot;isCrouch&quot;</span>, playerController.isCrouch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（五）</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表（Hash Table），也称为散列表，是一种常用的数据结构，用于快速存储和查找键值对</p><p><img src="/./../../../typora-images/image-20230604202549205.png" alt="image-20230604202549205"></p><p>哈希表包含以下几个重要的部分：</p><ol><li>数组（Array）：数组是哈希表的基本数据结构，用于存储数据。<strong>数组中的每个元素称为桶（Bucket）或槽（Slot）</strong>，每个桶可以存储一个或多个键值对。</li><li>哈希函数（Hash Function）：哈希函数将键（Key）映射为哈希值（Hash Value），并用于确定键在数组中的存储位置。哈希函数的设计应该尽量减少冲突，即不同的键映射到相同的哈希值的概率较低。</li><li>冲突处理机制（Collision Resolution）：由于哈希函数的映射空间有限，不同的键可能会映射到相同的哈希值，导致冲突。冲突处理机制用于解决冲突，常见的方法包括链地址法和开放地址法。<ul><li>链地址法（Chaining）：每个桶存储一个链表或其他数据结构，相同哈希值的键值对存储在同一个桶中。当发生冲突时，新的键值对会添加到该桶的链表中。</li><li>开放地址法（Open Addressing）：发生冲突时，会通过一定的规则找到下一个可用的桶，将新的键值对存储在该桶中。常见的开放地址法包括线性探测、二次探测和双重哈希等。</li></ul></li><li>哈希表的存储过程：存储过程根据键的哈希值找到对应的桶，然后将键值对存储在桶中。如果发生冲突，根据冲突处理机制的规则，将新的键值对添加到桶的链表中或者找到下一个可用的桶。</li><li>哈希表的查找过程：查找过程根据键的哈希值找到对应的桶，然后在桶中查找目标键的值。如果桶中不存在目标键值对，则表示查找失败。如果存在冲突，根据冲突处理机制的规则，通过链表或其他方式遍历桶中的键值对，找到目标键的值。</li></ol><p>PS：<strong>哈希函数和数组：哈希函数根据键计算出哈希值，然后根据哈希值确定键在数组中的存储位置。</strong></p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数（Hash Function）是一种将<strong>输入数据映射为固定长度哈希值</strong>（Hash Value）的函数。它的作用是将任意大小的输入数据转换为固定大小的输出，通常是一个整数或固定长度的字节数组。</p><p>哈希函数具有以下特性：</p><ol><li><strong>一致性</strong>：相同的输入始终产生相同的输出。即使输入数据发生微小的改变，输出结果也会有较大的差异。</li><li><strong>高效性</strong>：哈希函数的计算速度应该很快，能够在常数时间内完成计算。</li><li><strong>均匀性</strong>：哈希函数应该将输入数据均匀地映射到哈希值空间中，尽量减少哈希冲突的概率。</li></ol><h2 id="哈希表的存储方式"><a href="#哈希表的存储方式" class="headerlink" title="哈希表的存储方式"></a>哈希表的存储方式</h2><p>过程：</p><ol><li>计算哈希值：使用哈希函数对键进行计算，得到一个哈希值。哈希函数将键映射到哈希表的索引位置。</li><li>定位桶：根据哈希值定位到哈希表的对应桶（Bucket），即确定要存储键值对的位置。</li><li>冲突处理：如果发生哈希冲突，即多个键映射到同一个桶的情况，需要进行冲突处理。常见的冲突处理机制包括链地址法、开放地址法或公共溢出区域法，根据具体的冲突处理机制来存储键值对。</li><li>存储键值对：将键值对存储在确定的桶中。具体的存储方式取决于采用的冲突处理机制。对于链地址法，将键值对添加到桶的链表或其他数据结构中。对于开放地址法，将键值对存储在可用的桶中，或者按照一定的规则探测下一个可用的桶。对于公共溢出区域法，将键值对存储在共享的溢出区域中，并在桶中存储溢出区域的索引。</li><li>完成存储：存储过程完成后，键值对就被成功存储在哈希表中，可以通过哈希表的索引和冲突处理机制来进行快速的查找和访问。</li></ol><h2 id="哈希表的实现方式"><a href="#哈希表的实现方式" class="headerlink" title="哈希表的实现方式"></a>哈希表的实现方式</h2><ul><li>数组＋链表</li><li>数组＋二叉树</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记（二）</title>
      <link href="/2023/06/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/06/01/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（二）"><a href="#Unity开发日记（二）" class="headerlink" title="Unity开发日记（二）"></a>Unity开发日记（二）</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="设置人物"><a href="#设置人物" class="headerlink" title="设置人物"></a>设置人物</h3><p>为人物添加重力组件</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605111521201.png" alt="image-20230605111521201"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605111704469.png" alt="image-20230605111704469"></p><p>人物添加了重物组件，但是由于还没有加入碰撞组件，所以启动时人物会一直往下落</p><p>为人物添加碰撞组件：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112043971.png" alt="image-20230605112043971"></p><p>此时回到Sense界面可以看到人物的碰撞框架</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112258723.png" alt="image-20230605112258723"></p><p>这时可以通过选择框架来调整他的碰撞体积大小：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112328974.png" alt="image-20230605112328974"></p><p>通过框架的上下左右<strong>四个点</strong>来自定义调整大小，也可以通过快捷键<code>Alt</code>来进行对称调整</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112549109.png" alt="image-20230605112549109"></p><p>也可以通过框架大小数值调整直接进行：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605112803391.png" alt="image-20230605112803391"></p><p>为角色下边的平台也设置上碰撞体积：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605132831942.png" alt="image-20230605132831942"></p><p>此时每个瓦片都有一个体积碰撞</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605132957771.png" alt="image-20230605132957771"></p><p>通过添加另外一个新组件，可以实现将所有瓦片都视为一个体积碰撞</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133047191.png" alt="image-20230605133047191"></p><p>此时就可以在我们设置的平台碰撞体积上进行合并</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133201147.png" alt="image-20230605133201147"></p><p>最终所有瓦片的体积碰撞也被我们合并了起来：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133224377.png" alt="image-20230605133224377"></p><p>由于对瓦片增加了相应的碰撞体积组件，在对其添加后会自动为场景也设置上对应的<code>Rigdbody 2D</code>组件，这会导致当我们运行的时候场景也会受到重力影响一直往下掉落，所以还要对该组件进行另外设置：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605133639482.png" alt="image-20230605133639482"></p><p>这样就能够实现角色不会永久下落，而是站立在场景上，但另外一个问题是当角色的初始角度过高或者角色此时有一定旋转角度，这时候运行就会使得角色落地后倒在场景位置上，所以还要对角色的旋转角度固定住：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605134021135.png" alt="image-20230605134021135"></p><p>PS：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230605134932789.png" alt="image-20230605134932789"></p><h3 id="创建配置输入系统"><a href="#创建配置输入系统" class="headerlink" title="创建配置输入系统"></a>创建配置输入系统</h3><p>Assets目录下创建存放相关代码的Scripts包，包下再创建存放人物代码的Player文件夹</p><p>在Player文件夹下创建C#脚本</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608131329662.png" alt="image-20230608131329662"></p><p>为角色添加刚创建的脚本：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608132240279.png" alt="image-20230608132240279"></p><h4 id="修改输入系统"><a href="#修改输入系统" class="headerlink" title="修改输入系统"></a>修改输入系统</h4><p>Edit → Project Setting → Player → OtherSetting</p><p>在OtherSetting界面上修改：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608140209592.png" alt="image-20230608140209592"></p><p>应用成功后进行下一步修改，回到主页面</p><p>Window选项 → Package Manager</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230608141540290.png" alt="image-20230608141540290"></p><p>安装input system</p><p>开始创建输入系统</p><ul><li><strong>手动创建方式：</strong></li></ul><p>在Setting文件夹下创建Input System文件包，在Input System文件包下创建输入系统：</p><p>点击左上角＋号添加</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230610100557802.png" alt="image-20230610100557802"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230610100701487.png" alt="image-20230610100701487"></p><p>点击进入控制面板，创建Action Map，同时创建我们需要的Action</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165032497.png" alt="image-20230701165032497"></p><p>例如创建对键盘键位的读取，选择Action类型为<code>Value</code>值，控制的类型为坐标系<code>Vector 2</code></p><p>同时可以对Action下各个内容进行绑定</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165227129.png" alt="image-20230701165227129"></p><p>这样就完成了对键盘按键的监测</p><p>此外，此时再次添加了一个对手柄的监测：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165448116.png" alt="image-20230701165448116"></p><p>在这时候要添加控制的配置表来定义什么时候用什么监测</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165636012.png" alt="image-20230701165636012"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701165855881.png" alt="image-20230701165855881"></p><p>添加完后可以为每个Action选择对应的配置：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230701170037503.png" alt="image-20230701170037503"></p><ul><li><strong>自动创建方式：</strong></li></ul><p>选择角色，在添加组件中选择player input</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707165749383.png" alt="image-20230707165749383"></p><p>随后在右侧<code>Create Action</code>创建Action，选择我们即将要创建的文件夹，修改名字并创建完成后，它就会自动帮我们生成需要的Action</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707170057614.png" alt="image-20230707170057614"></p><p>如果要改成用代码来操控的话，需要先生成对应的C#代码：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707170757832.png" alt="image-20230707170757832"></p><p>在选择角色后右侧显示的框架内进入PlayerController代码中，在PlayerController导入刚创建好的操作脚本，同时定义脚本启用的情况：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172051050.png" alt="image-20230707172051050"></p><p>问题：什么情况下是启用？什么情况下是关闭？</p><p>当<img src="/./../images/unity(%E4%BA%8C)/image-20230707172142841.png" alt="image-20230707172142841"></p><p>开启或关闭时就相当于程序中调用开启和关闭</p><p>获取MoveAction中的操控值：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172701984.png" alt="image-20230707172701984"></p><p>MoveAction对应的值为Vector 2，所以在C#上也要定义对应的类型来获取：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172627352.png" alt="image-20230707172627352"></p><p>保存后可以看到界面上多了我们新设置的操控值：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707172820364.png" alt="image-20230707172820364"></p><p>接下来要设置一个更新方法，来获取每一帧我们移动的操作：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707173302355.png" alt="image-20230707173302355"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230707173329199.png" alt="image-20230707173329199"></p><h3 id="实现人物的运动"><a href="#实现人物的运动" class="headerlink" title="实现人物的运动"></a>实现人物的运动</h3><p><strong>如果一个物品绑定了一个刚体，那么运动是通过刚体来进行的</strong></p><h4 id="人物移动"><a href="#人物移动" class="headerlink" title="人物移动"></a>人物移动</h4><ul><li>如何通过速度来驱动物体</li></ul><p>在<code>PlayerController</code>控制脚本中添加一个新的速度属性，来让前文编写的Vector2的左右值给到它</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713110452782.png" alt="image-20230713110452782"></p><p>这样就能在unity的图形界面中也能看到新的速度边框了：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713110530151.png" alt="image-20230713110530151"></p><p>接下来要在控制脚本中也编写一个刚体属性，绑定到unity上边我们需要用到的刚体，从而让后续的动作操作能够执行：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111020075.png" alt="image-20230713111020075"></p><p>在unity界面上查看并进行绑定：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111120884.png" alt="image-20230713111120884"></p><p>PS：需要注意的是，此时刚体的属性为public，也就是为初始就能进行绑定，如果改为private的话，保存之后的unity界面并不会显示到该属性值，这样就不能做到一个初始化就绑定刚体的操作，需要用其他方式来获得</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713111730448.png" alt="image-20230713111730448"></p><p>绑定速度实现左右移动(x，y)：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230713112040013.png" alt="image-20230713112040013"></p><p>保持人物落地时的速度(默认0会导致人物下落时十分缓慢)：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230721183058351.png" alt="image-20230721183058351"></p><h4 id="人物翻转"><a href="#人物翻转" class="headerlink" title="人物翻转"></a>人物翻转</h4><ul><li>如何翻转人物(实现人物的调头)</li></ul><p>通过Scale的X或Y轴进行人物的翻转，最常用的是基于X轴进行的翻转</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722103424671.png" alt="image-20230722103424671"></p><p>在人物控制脚本中绑定并实现翻转：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722104136092.png" alt="image-20230722104136092"></p><h4 id="人物跳跃"><a href="#人物跳跃" class="headerlink" title="人物跳跃"></a>人物跳跃</h4><ul><li>如何实现人物的跳跃</li></ul><p>在<code>Input System</code>系统中添加新的Action：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722105454331.png" alt="image-20230722105454331"></p><p>然后在PlayerController控制脚本中绑定编写相关内容:</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722112247589.png" alt="image-20230722112247589"></p><p><strong><code>+=</code>符号表示注册内容，相当于把+&#x3D;后边的函数给到前边的内容</strong></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722112812139.png" alt="image-20230722112812139"></p><p>返回测试：</p><p>​注意：此时代码中虽然定义了jumpForce变量，但是并没有在脚本中进行赋值，赋值的地方可以在unity UI界面上手动添加值，然后保存就行</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113005867.png" alt="image-20230722113005867"></p><p>同时，为了让跳跃效果更好一点，可以按如下配置进行更改：</p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113128337.png" alt="image-20230722113128337"></p><p><img src="/./../images/unity(%E4%BA%8C)/image-20230722113147187.png" alt="image-20230722113147187"></p><p>到这里为止，跳跃还会遇到的其他问题大致有：</p><ul><li>空中无限跳跃</li><li>跳完之后松开方向键没有惯性向前</li><li>按键时间长短和跳起高度的绑定</li></ul><p>最后完成的PlayerController脚本代码：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> Unity.VisualScripting;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> PlayerInputControls inputControl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector2 inputDirection;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Header(<span class="string">&quot;基本参数&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> jumpForce;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Awake 相当于生命周期</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        inputControl = <span class="keyword">new</span> PlayerInputControls();</span><br><span class="line"></span><br><span class="line">        inputControl.GamePlay.Jump.started += Jump;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被调用时则开始启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物品被关闭时关闭启用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDisable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputControl.Disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//周期性的每帧执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        inputDirection = inputControl.GamePlay.Move.ReadValue&lt;Vector2&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FixedUpdate是一个固定更新的值</span></span><br><span class="line">    <span class="comment">//周期性的固定执行</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Move</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = <span class="keyword">new</span> Vector2(inputDirection.x * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> faceDir = (<span class="built_in">int</span>)transform.localScale.x;</span><br><span class="line">        <span class="comment">//通过判断语句来确定当控制人物向左或者向右时进行翻转</span></span><br><span class="line">        <span class="comment">//向右是大于0，向左是小于0</span></span><br><span class="line">        <span class="keyword">if</span> (inputDirection.x &gt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(inputDirection.x &lt; <span class="number">0</span>)</span><br><span class="line">            faceDir = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//人物翻转</span></span><br><span class="line">        transform.localScale = <span class="keyword">new</span> Vector3(faceDir, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Jump</span>(<span class="params">InputAction.CallbackContext obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Debug.Log(&quot;Jump&quot;);</span></span><br><span class="line">        rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>unity开发日记 (一)</title>
      <link href="/2023/05/22/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/05/22/unity%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Unity开发日记（一）"><a href="#Unity开发日记（一）" class="headerlink" title="Unity开发日记（一）"></a>Unity开发日记（一）</h1><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="对导入素材进行调整"><a href="#对导入素材进行调整" class="headerlink" title="对导入素材进行调整"></a>对导入素材进行调整</h3><p><strong>背景素材调整</strong>：</p><p>导入素材之后调整素材大小</p><p>比较简单粗糙的调整素材大小方式(<strong>一般开发不采用</strong>)：</p><p><img src="/../images/unity(%E4%B8%80)/1.png" alt="1"></p><p><img src="/../images/unity(%E4%B8%80)/2.png" alt="2"></p><p>较为常用的方式(通过像素点来按比例进行调整)：</p><p><code>Pixels Per Unit</code>代表每个格子当中显示多少个像素单位，根据美术素材的不同(16 * 16,32 * 32等)进行调整</p><p><img src="/../images/unity(%E4%B8%80)/3.png" alt="3"></p><p>同时还要进行调整的地方有：</p><p>一般像素游戏的渲染模式都会选择Point(即没有渲染)</p><p><img src="/../images/unity(%E4%B8%80)/4.png" alt="4"></p><p>调整压缩</p><p><img src="/../images/unity(%E4%B8%80)/5.png" alt="5"></p><p><strong>动作集(任务素材)调整</strong>：</p><p>如何查看总体动作素材集：</p><p><img src="/../images/unity(%E4%B8%80)/6.png" alt="6"></p><p>打开后的显示为：</p><p><img src="/../images/unity(%E4%B8%80)/7.png" alt="7"></p><p><strong>目的：</strong>对该图集进行切割，方便接下来开发流程中的使用</p><h4 id="切割图集"><a href="#切割图集" class="headerlink" title="切割图集"></a>切割图集</h4><p>首先调整图集：</p><p><img src="/../images/unity(%E4%B8%80)/8.png" alt="8"></p><p>下方的渲染和压缩同上进行修改即可</p><p><strong>开始进行素材的切割：</strong></p><p><img src="/../images/unity(%E4%B8%80)/9.png" alt="9"></p><p>调整切割方式：</p><p><img src="/../images/unity(%E4%B8%80)/10.png" alt="10"></p><p>切割后效果：</p><p><img src="/../images/unity(%E4%B8%80)/11.png" alt="11"></p><p>PS：切割后要记得应用<img src="/../images/unity(%E4%B8%80)/12.png" alt="12"></p><p>同时退出切割页面后，在编辑页面仍然要重新进行应用</p><p><img src="/../images/unity(%E4%B8%80)/13.png" alt="13"></p><p>最终对图片集展开就可以使用每一个已经被切割出来的素材图片了</p><p><img src="/../images/unity(%E4%B8%80)/14.png" alt="14"></p><h4 id="场景绘制"><a href="#场景绘制" class="headerlink" title="场景绘制"></a>场景绘制</h4><p>对对应的场景素材先进行相应的调整：</p><p><img src="/../images/unity(%E4%B8%80)/15.png" alt="15"></p><p><img src="/../images/unity(%E4%B8%80)/16.png" alt="16"></p><p>渲染和压缩也要进行调整，同其他素材一样调整为<code>Point</code>和<code>None</code></p><p>随后开始<strong>对素材进行切割</strong>：</p><p><img src="/../images/unity(%E4%B8%80)/17.png" alt="17"></p><p>完成切割：</p><p><img src="/../images/unity(%E4%B8%80)/18.png" alt="18"></p><p><strong>对场景进行绘制</strong>：</p><p>使用2D场景绘制工具进行场景的绘制</p><h5 id="调色盘的使用"><a href="#调色盘的使用" class="headerlink" title="调色盘的使用"></a>调色盘的使用</h5><p><img src="/../images/unity(%E4%B8%80)/19.png" alt="19"></p><p><strong>创建新的调色盘：</strong></p><p><img src="/../images/unity(%E4%B8%80)/20.png" alt="20"></p><p>在Assets同级目录下创建方便管理的调色盘文件夹Titlemap，进入Titlemap文件夹再次创建方便管理每一个瓦块的文件夹Palettes，最后选择Palettes文件夹完成创建调色盘的工作</p><p>完成调色盘的创建：</p><p><img src="/../images/unity(%E4%B8%80)/21.png" alt="21"></p><p><strong>将切割后的场景素材拖拽到调色盘界面上</strong>：</p><p><img src="/../images/unity(%E4%B8%80)/22.png" alt="22"></p><p>拖拽后会显示让你添加到哪个文件夹上，这时在Palettes文件夹同级目录下再次创建一个Tiles文件夹，进入该文件夹再次创建一个Forest 1文件夹进行存放所有要进行调色的素材</p><p>完成素材的拖拽后：</p><p><img src="/../images/unity(%E4%B8%80)/23.png" alt="23"></p><p>接下来就是要对每一个瓦片进行调整：</p><p>在编辑器上先创建Tilemap</p><p><img src="/../images/unity(%E4%B8%80)/24.png" alt="24"></p><p><img src="/../images/unity(%E4%B8%80)/25.png" alt="25"></p><p>这时我们的编辑器格子很明显</p><p><img src="/../images/unity(%E4%B8%80)/26.png" alt="26"></p><p>然后<strong>回到调色盘编辑界面（Tile Palette）进行选择：</strong></p><p><img src="/../images/unity(%E4%B8%80)/27.png" alt="27"></p><p>这时就可以选择我们想要的瓦片来进行绘制了</p><p><img src="/../images/unity(%E4%B8%80)/28.png" alt="28"></p><p>绘制完成后查看在游戏中的效果：</p><p>如果要更改画面中视距的效果，可以通过<code>Free Aspect</code>调整</p><p><img src="/../images/unity(%E4%B8%80)/29.png" alt="29"></p><p>最主要的调整方式还是通过相机来进行调整：</p><p><img src="/../images/unity(%E4%B8%80)/30.png" alt="30"></p><p>而在进行场景绘制的时候，如果场景挡住了人物，此时就可以用到<strong>叠层</strong></p><h4 id="叠层设置"><a href="#叠层设置" class="headerlink" title="叠层设置"></a>叠层设置</h4><p>通过对物体的<code>Sprite Renderer</code>组件内进行叠层设置</p><p><img src="/../images/unity(%E4%B8%80)/31.png" alt="31"></p><p><strong>其中<code>Sorting Layer</code>代表不同层，<code>Order in Layer</code>代表同层下不同次序</strong></p><p><img src="/../images/unity(%E4%B8%80)/32.png" alt="32"></p><p>为角色模型设置层次：</p><p><img src="/../images/unity(%E4%B8%80)/33.png" alt="33"></p><p>具体效果展示为：</p><p>当没有设置叠层时(即场景和人物的Layer都为Default)</p><p><img src="/../images/unity(%E4%B8%80)/34.png" alt="34"></p><p>当为角色设置完层次之后</p><p><img src="/../images/unity(%E4%B8%80)/35.png" alt="35"></p><p>同理，通过叠层设置背景效果：</p><p><img src="/../images/unity(%E4%B8%80)/36.png" alt="36"></p><p>通过<code>Tilemap Focus</code>小工具来选定Tilemap，从而让我们更清晰的知道我们当前编辑或要编辑的图层是哪一个</p><p><img src="/../images/unity(%E4%B8%80)/37.png" alt="37"></p><h4 id="规则瓦片和动态瓦片"><a href="#规则瓦片和动态瓦片" class="headerlink" title="规则瓦片和动态瓦片"></a>规则瓦片和动态瓦片</h4><h5 id="规则瓦片"><a href="#规则瓦片" class="headerlink" title="规则瓦片"></a>规则瓦片</h5><p>作用：能够高效率地绘制出相对完整的地图，通过自定义不同瓦片来实现</p><p>在瓦片文件夹(Tiles)下新建存放的规则瓦片文件夹(Rule Tiles)，在该文件夹下创建规则瓦片</p><p><img src="/../images/unity(%E4%B8%80)/38.png" alt="38"></p><p>先对切割好的场景素材重新命名，方便接下来规则瓦片的使用</p><p>命名完成后开始进行规则瓦片的编辑：</p><p><img src="/../images/unity(%E4%B8%80)/39.png" alt="39"></p><p>选择瓦片，同时<strong>定义该瓦片在什么情况下出现</strong></p><p><img src="/../images/unity(%E4%B8%80)/40.png" alt="40"></p><p><img src="/../images/unity(%E4%B8%80)/41.png" alt="41"></p><p>部分瓦片（例如地面中间部分的瓦片）可以进行随机</p><p><img src="/../images/unity(%E4%B8%80)/42.png" alt="42"></p><p><img src="/../images/unity(%E4%B8%80)/43.png" alt="43"></p><p>PS：<code>Noise</code>表示在随机的几个中的比重</p><p>添加完成</p><p><img src="/../images/unity(%E4%B8%80)/44.png" alt="44"></p><p>接下来需要把我们自定义的规则瓦片添加到调色盘上，从而让我们可以直接拿去绘制</p><p><img src="/../images/unity(%E4%B8%80)/45.png" alt="45"></p><p>绘制测试效果</p><p><img src="/../images/unity(%E4%B8%80)/46.png" alt="46"></p><p>拐角处的瓦片过渡不自然，所以要再次修改规则瓦片，添加对应的转角处瓦片</p><p><img src="/../images/unity(%E4%B8%80)/47.png" alt="47"></p><h5 id="动态瓦片"><a href="#动态瓦片" class="headerlink" title="动态瓦片"></a>动态瓦片</h5><p>作用：实现动态效果（比如瀑布）</p><p>原理：几个瓦片逐层逐帧进行切换，实现类似霓虹灯那样的视角效果，从而达到动态</p><p>在瓦片文件夹(Tiles)下新建存放的规则瓦片文件夹(Animated Tiles)，在该文件夹下创建规则瓦片</p><p><img src="/../images/unity(%E4%B8%80)/48.png" alt="48"></p><p>同时为我们要用到的瓦片进行修改命名，随后开始添加到动态瓦片中</p><p>假设瀑布现在要搞成3(列)*4(行)的形式，此时就要分别在左中右各设置一个包含四张瀑布的动态瓦片</p><p><img src="/../images/unity(%E4%B8%80)/49.png" alt="49"></p><p>保存后将该动态瓦片更新到调色盘上：</p><p><img src="/../images/unity(%E4%B8%80)/50.png" alt="50"></p><p>查看效果</p><p><img src="/../images/unity(%E4%B8%80)/51.png" alt="51"></p><p>可以调节动态瓦片的速度：</p><p><img src="/../images/unity(%E4%B8%80)/52.png" alt="52"></p><p>按该步骤继续完成第二列第三列的瀑布编辑</p><p><img src="/../images/unity(%E4%B8%80)/53.png" alt="53"></p><p>最终展示效果：<img src="/../images/unity(%E4%B8%80)/54.png" alt="54"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（四）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><strong>图的基本概念：</strong>在图形结构中，<strong>结点之间的关系可以是任意</strong>的，图中任意两个数据元素之间都可能相关</p><p>图的定义：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302092959390.png" alt="image-20230302092959390"></p><p>PS：线性表可以是空表，树可以是空树，但是<strong>图不可以是空图</strong>（图中不能一个顶点也没有）</p><h2 id="图的概念"><a href="#图的概念" class="headerlink" title="图的概念"></a>图的概念</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><ul><li>无向图</li></ul><p><strong>无向图中的边没有方向</strong>，(vi,vj)表示连接顶点vi和vj之间的一条边，即(vi,vj)和(vj,vi)表示的是同一条边</p><p>树是连通的无回路的无向图，若一棵树有n个顶点，则必有n-1条边</p><ul><li>有向图</li></ul><p><strong>有向图中的边有方向</strong>，&lt;vi,vj&gt;表示从顶点vi到vj的一条有向边，vi是边的起点，vj是边的终点，即&lt;vi,vj&gt;和&lt;vj,vi&gt;表示的不是同一条边</p><p>有向图还可分为<strong>简单图</strong>和<strong>多重图</strong></p><p>多重图：指图中两个顶点之间有重复边</p><ul><li>完全图</li></ul><p>完全图是边数打到最大值的图。若有n个顶点，则完全无向图的边数为<code>n(n-1)/2</code>,完全有向图的边数为<code>n(n-1)</code></p><ul><li>带权图</li></ul><p>带权图指图中的边具有权值（权值有不同的含义）</p><ul><li>邻接顶点</li></ul><p>若(vi，vj)是无向图中的一条边，则vi和vj互为邻接顶点，边(vi，vj)依附于顶点vi和vj</p><p>若&lt;vi，vj&gt;是有向图中的一条边，则vi邻接到vj，vj邻接自vi，边&lt;vi，vj&gt;与vi和vj相关联</p><h3 id="顶点的度"><a href="#顶点的度" class="headerlink" title="顶点的度"></a>顶点的度</h3><p>顶点的度是指与顶点vi关联的<strong>边数</strong>，记作<code>degree(vi)</code></p><p>度为0的顶点称为孤立点，度为1的顶点称为悬挂点</p><p>在有向图中，以<strong>vi为终点的边数称为vi的入度</strong>，记作<code>indegree(vi)</code>；<strong>以vi为起点的边数称为vi的出度</strong>，记作<code>outdegree(vi)</code></p><p>PS：在有向图中，顶点的度 &#x3D; 该顶点的出度 + 该顶点的入度</p><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><ul><li>路径</li></ul><p>接续的边构成的顶点序列</p><ul><li>路径长度</li></ul><p>路径上边或弧的数目&#x2F;权值之和（不带权图算边数，带权图算权数和）</p><ul><li>回路</li></ul><p>第一个顶点和最后一个顶点相同的路径</p><ul><li>简单路径</li></ul><p>除路径起点和终点可以相同外，其余顶点均不相同</p><ul><li>简单回路(环)</li></ul><p>除路径起点和终点相同且长度大于1的简单路径</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095321818.png" alt="image-20230302095321818"></p><h3 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095729492.png" alt="image-20230302095729492"></p><p>以下，(b)和(c)都是(a)的子图</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302095751667.png" alt="image-20230302095751667"></p><p>若G1≠G，称图G1是G的<strong>真子图</strong></p><p>若G1是G的子图，但V1&#x3D;V，称G1是G的<strong>生成子图</strong></p><h3 id="连通性、生成树"><a href="#连通性、生成树" class="headerlink" title="连通性、生成树"></a>连通性、生成树</h3><p>在图G中，若从顶点vi到vj有路径，则称vi和vj是连通的。</p><p>若每对顶点vi和vj都是连通的，则称G为<strong>连通图</strong>(强连通图)<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100353660.png" alt="image-20230302100353660"></p><p>（无向图）<strong>非连通图</strong>的极大连通子图成为该图的<strong>连通分量</strong>；</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100519090.png" alt="image-20230302100519090"></p><p>(有向图) <strong>非强连通图</strong>的极大连通子图成为该图的<strong>强连通分量</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302100650446.png" alt="image-20230302100650446"></p><p>连通无向图G的<strong>生成树</strong>是指G的一个<strong>极小连通生成子树</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302101202957.png" alt="image-20230302101202957"></p><p>各连通分量均为树的无向图称为森林</p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵-数组表示"><a href="#邻接矩阵-数组表示" class="headerlink" title="邻接矩阵(数组表示)"></a>邻接矩阵(数组表示)</h3><p><strong>图的邻接矩阵(Adjacency Matrix) 存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息</strong></p><p>建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间的关系）</p><p><strong>无向图的邻接矩阵表示：</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302102452796.png" alt="image-20230302102452796"></p><p><strong>特点：</strong></p><p>无向图的邻接矩阵是对称的</p><p>顶点i的度 &#x3D; 第i行(列)中1的个数</p><p><strong>有向图的邻接矩阵表示：</strong></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302102418265.png" alt="image-20230302102418265"></p><p>特点：</p><p>有向图的邻接矩阵可能是不对称的</p><p>顶点的出度 &#x3D; 第i行元素之和</p><p>顶点的入度 &#x3D; 第i列元素之和</p><p>顶点的度 &#x3D; 第i行元素之和+第i列元素之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="邻接表-链式"><a href="#邻接表-链式" class="headerlink" title="邻接表(链式)"></a>邻接表(链式)</h3><p>邻接表由两部分组成：<strong>表头结点表</strong>和<strong>边表</strong></p><p>邻接表中每个单链表的<strong>第一个结点</strong>存放有关<strong>顶点的信息</strong>，把这一结点看成链表的表头，<strong>其余结点存放有关边的信息</strong></p><p><strong>表头结点表：</strong>包括<strong>数据域</strong>和<strong>链域</strong>，数据域存储<strong>顶点的名称</strong>，链域用于指向链表中第一个结点（<strong>与顶点邻接的第一个顶点</strong>）</p><p><strong>边表：</strong>包括<strong>邻接点域</strong>（指示与顶点邻接的点在图中的位置，即<strong>数组下标</strong>）、(<strong>数据域</strong>（存储和边相关的信息，如<strong>权值</strong>）、)<strong>链域</strong>（指示<strong>与顶点邻接的下一条边的结点</strong>）</p><p>无向图的邻接表：</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302131743954.png" alt="image-20230302131743954"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（三）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="树的基本定义"><a href="#树的基本定义" class="headerlink" title="树的基本定义"></a>树的基本定义</h2><p>树是由n(n&gt;&#x3D;1)个有限结点组成一个具有层次关系的集合</p><p>树具有以下特点：</p><ul><li>每个结点有零个或多个子结点</li><li>没有父结点的结点为根结点</li><li>每一个非根结点只有一个父结点</li><li>每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树</li></ul><h2 id="树的相关术语"><a href="#树的相关术语" class="headerlink" title="树的相关术语"></a>树的相关术语</h2><p><strong>结点的度：</strong></p><p>​一个结点含有的子树的个数称为该结点的度</p><p><strong>叶结点：</strong></p><p>​度为0的结点称为叶结点（也叫终端结点）</p><p><strong>分支结点：</strong></p><p>​度不为0的结点称为分支结点（也叫非终端结点）</p><p><strong>结点的层次：</strong></p><p>​从根结点开始，根结点的层次为1,根的直接后继层次为2，以此类推</p><p><strong>结点的层序编号：</strong></p><p>​将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数</p><p><strong>树的度：</strong></p><p>​树中所有结点的度的最大值</p><p><strong>树的高度：</strong></p><p>​树中结点的最大层次</p><p><strong>孩子结点：</strong></p><p>​一个结点的直接后继结点称为该结点的孩子结点</p><p><strong>双亲结点：</strong></p><p>​一个结点的直接前驱称为该结点的双亲结点</p><p><strong>兄弟结点：</strong></p><p>​同一双亲结点的孩子结点间互称为兄弟结点</p><p><strong>对某个节点</strong>:<br><strong>深度</strong>是指从<strong>根节点到该节点</strong>的<strong>最长</strong>简单路径边的条数；<br><strong>高度</strong>是指从<strong>最下面的叶子结点到该节点</strong>的<strong>最长</strong>简单路径边的条数；</p><p><strong>对二叉树：</strong><br><strong>深度</strong>是从根节点数到它的叶节点；<br><strong>高度</strong>是从叶节点数到它的根节点；<br><strong>注意： 树的深度和高度一样，但是具体到树的某个节点，其深度和高度不一样</strong></p><h2 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h2><ul><li><strong>满二叉树</strong></li><li><strong>完全二叉树</strong></li><li><strong>二叉搜索树</strong></li><li><strong>平衡二叉搜索树</strong></li></ul><p>具体分辨参考：<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB">https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB</a></p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><p><strong>性质1：</strong>若根节点的层次为1，则二叉树第i层最多有<strong>2^i-1</strong>（i&gt;&#x3D;1）个结点</p><p><strong>性质2：</strong>在高度为h的二叉树中，最多有<strong>2^h-1</strong>个结点（h&gt;&#x3D;0）</p><p><strong>性质3：</strong>设一棵二叉树的叶子结点数为n0，2度结点数为n2，则<strong>n0 &#x3D; n2+1</strong></p><p><strong>性质4：</strong>一棵具有n个结点的完全二叉树，其高度h&#x3D;<img src="/./../../../typora-images/image-20240416212437897.png" alt="image-20240416212437897"></p><p><strong>性质5：</strong>一棵具有n个结点的完全二叉树，对序号为i（0&lt;&#x3D;i&lt;&#x3D;n）的结点，有：</p><p>​1）若i&#x3D;0，则i为根结点；若i&gt;0，则i的父母结点序号为**[(i-1)&#x2F;2]**</p><p>​2）若2i+1&lt;n，则i的<strong>左孩子结点序号为2i+1</strong>；否则，i无左孩子</p><p>​3）若2i+2&gt;n，则i的<strong>右孩子结点序号为2i+2</strong>；否则，i无右孩子</p><h2 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h2><ul><li><p><strong>链式存储</strong></p></li><li><p><strong>线式存储(常用)</strong></p></li></ul><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><ul><li><strong>中序遍历</strong></li></ul><p>中序遍历先访问根结点，然后遍历左子树，最后遍历右子树<strong>(左中右)</strong></p><ul><li><strong>先序遍历</strong></li></ul><p>先序遍历是先遍历左子树，然后访问根结点，然后遍历右子树<strong>(中左右)</strong></p><ul><li><strong>后序遍历</strong></li></ul><p>后序遍历是先遍历左子树，然后遍历右子树，最后访问根节点<strong>(左右中)</strong></p><h4 id="递归方式实现"><a href="#递归方式实现" class="headerlink" title="递归方式实现"></a>递归方式实现</h4><p>（链式存储的方式来存储的树）</p><p>通过递归三部曲的方式确定递归参数和返回值，确定遍历停止的条件，确定递归逻辑</p><p>以中序遍历来说：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br></pre></td></tr></table></figure><p>前后序遍历的方式也一致，只是递归顺序不同</p><h4 id="非递归方式实现-迭代"><a href="#非递归方式实现-迭代" class="headerlink" title="非递归方式实现(迭代)"></a>非递归方式实现(迭代)</h4><p>迭代方式来进行树的遍历，<strong>主要应用在中序遍历</strong>，由于中序遍历的访问元素与处理元素的顺序不一致，所以可以通过迭代的方式来解决</p><p>讲解可以参考：<a href="https://www.bilibili.com/video/BV1Zf4y1a77g">https://www.bilibili.com/video/BV1Zf4y1a77g</a></p><p>通常使用栈的方式来模拟树的遍历：</p><ul><li>前序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            stack.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            stack.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    Stack&lt;TreeNode*&gt; stack;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    TreeNode* cur = root; <span class="comment">//代替指针操作</span></span><br><span class="line">    <span class="keyword">while</span>(cur != null || !stack.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左边叶子结点还存在，继续遍历下去</span></span><br><span class="line">        <span class="keyword">if</span>(cur != null)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur → cur.left;<span class="comment">//左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到达最深层的结点，开始返回，同时要出栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = stack.<span class="built_in">top</span>();</span><br><span class="line">            stack.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur → val);  <span class="comment">//中</span></span><br><span class="line">            cur = cur → right;            <span class="comment">//右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>描述：层序遍历一个二叉树就是指 从左到右一层一层的去遍历二叉树</p><p>讲解视频：<a href="https://www.bilibili.com/video/BV1GY4y1u7b2">https://www.bilibili.com/video/BV1GY4y1u7b2</a></p><p>思路：<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑</strong></p><p>模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">queue&lt;TreeNode*&gt; que;</span><br><span class="line"><span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">que.<span class="built_in">push</span>(root);</span><br><span class="line"><span class="keyword">while</span> (!que.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">while</span> (size--)</span><br><span class="line">&#123;</span><br><span class="line">TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line">vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">//中</span></span><br><span class="line"><span class="keyword">if</span> (node-&gt;left)<span class="comment">//左</span></span><br><span class="line">que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;right)<span class="comment">//右</span></span><br><span class="line">que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">res.<span class="built_in">push_back</span>(vec);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h2><p>例子：</p><p>以<strong>字符串</strong>方式构建二叉树</p><p>描述为：能够根据字符串<code>“A(B(,D),C)”</code>构造二叉树，构建后的树如图</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20221112142020303.png" alt="image-20221112142020303"></p><p>解题思路参考：<a href="https://www.bilibili.com/video/BV1CK4y1G7b3">https://www.bilibili.com/video/BV1CK4y1G7b3</a></p><p>采用<strong>栈</strong>的方式来构建</p><p><strong>树结点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data; <span class="comment">//结点的值</span></span><br><span class="line">    TreeNode left;  <span class="comment">//左孩子</span></span><br><span class="line">    TreeNode right; <span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">char</span> data, TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构建树：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BTree</span>&#123;</span><br><span class="line">    TreeNode root; <span class="comment">//根结点</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BTree</span><span class="params">()</span>&#123;<span class="built_in">this</span>.root = <span class="literal">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//用来标记左/右子树</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123; <span class="comment">//左括号说明此时结点有子树，同时将结点塞入栈中</span></span><br><span class="line">                st.push(node);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;,&#x27;</span>)&#123;<span class="comment">//逗号说明接下来的结点是右子树</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;<span class="comment">//右括号表示一个子树完成，此时要将子树的根节点弹出栈</span></span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(str.charAt(i));<span class="comment">//初始化赋值   </span></span><br><span class="line">                <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">                    root = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!st.isEmpty())&#123;</span><br><span class="line">                          <span class="keyword">if</span>(flag)&#123;<span class="comment">//为栈顶的结点连接对应的左孩子</span></span><br><span class="line">                    st.peek().left = node;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//为栈顶的结点连接对应的右孩子</span></span><br><span class="line">                    st.peek().right = node;</span><br><span class="line">                &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树中查找X值"><a href="#二叉树中查找X值" class="headerlink" title="二叉树中查找X值"></a>二叉树中查找X值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">findNode</span><span class="params">(TreeNode t,<span class="type">char</span> c)</span>&#123;</span><br><span class="line">    TreeNode p;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t.data==c)&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = findNode(t.left,c);</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> findNode(t.right,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>定义结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序遍历方式（中左右）：</p><ul><li><strong>递归（常用）</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>栈</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder2</span><span class="params">(TreeNode tree)</span>&#123;</span><br><span class="line">       Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">       st.push(tree);</span><br><span class="line">       <span class="keyword">while</span>(!st.empty())&#123;</span><br><span class="line">           <span class="type">TreeNode</span> <span class="variable">t1</span> <span class="operator">=</span> st.peek();</span><br><span class="line">           st.pop();</span><br><span class="line">           System.out.println(t1.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span> (t1.right!=<span class="literal">null</span>)</span><br><span class="line">               st.push(t1.right);</span><br><span class="line">           <span class="keyword">if</span> (t1.left!=<span class="literal">null</span>)</span><br><span class="line">               st.push(t1.left);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>参考学习视频：<a href="https://www.bilibili.com/video/BV15f4y1W7i2">https://www.bilibili.com/video/BV15f4y1W7i2</a></p><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">preOrder</span>(TreeNode tree)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    preOrder(tree.left);</span><br><span class="line">    preOrder(tree.right);</span><br><span class="line">    System.out.printf(tree.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>二叉树的<strong>深度</strong>主要通过<strong>后序遍历</strong>来进行，中结点进行最后的判断</p><p>二叉树的<strong>高度</strong>主要通过<strong>前序遍历</strong>来进行，叶子节点进行最后的判断</p><p>核心点在于：<strong>最初根节点的高度其实际上就是该二叉树的最大深度</strong>！</p><p>所以只要通过递归遍历获取根节点的最大高度即可</p><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p>题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/</a></p><p>解题思路：</p><p>一共分几步：</p><ul><li>第一步：如果数组大小为零的话，说明是空节点了</li><li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素</li><li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li><li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li><li>第五步：切割后序数组，切成后序左数组和后序右数组</li><li>第六步：递归处理左区间和右区间</li></ul><p>代码尝试：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* traversal (vector&lt;<span class="built_in">int</span>&gt;&amp; inorder, vector&lt;<span class="built_in">int</span>&gt;&amp; postorder) &#123;</span><br><span class="line">       <span class="keyword">if</span> (postorder.size() == <span class="number">0</span>) <span class="keyword">return</span> NULL;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">       <span class="built_in">int</span> rootValue = postorder[postorder.size() - <span class="number">1</span>];</span><br><span class="line">       TreeNode* root = <span class="keyword">new</span> TreeNode(rootValue);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 叶子节点</span></span><br><span class="line">       <span class="keyword">if</span> (postorder.size() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">       <span class="built_in">int</span> delimiterIndex;</span><br><span class="line">       <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.size(); delimiterIndex++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切割中序数组</span></span><br><span class="line">       <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">leftInorder</span>(<span class="params">inorder.begin(</span>), inorder.<span class="title">begin</span>() + delimiterIndex)</span>;</span><br><span class="line">       <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">rightInorder</span>(<span class="params">inorder.begin(</span>) + delimiterIndex + 1, inorder.<span class="title">end</span>() )</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">       postorder.resize(postorder.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 切割后序数组</span></span><br><span class="line">       <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">       <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">leftPostorder</span>(<span class="params">postorder.begin(</span>), postorder.<span class="title">begin</span>() + leftInorder.<span class="title">size</span>())</span>;</span><br><span class="line">       <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">       <span class="function">vector&lt;<span class="built_in">int</span>&gt; <span class="title">rightPostorder</span>(<span class="params">postorder.begin(</span>) + leftInorder.<span class="title">size</span>(), postorder.<span class="title">end</span>())</span>;</span><br><span class="line"></span><br><span class="line">       root-&gt;left = traversal(leftInorder, leftPostorder);</span><br><span class="line">       root-&gt;right = traversal(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h3><p>题目链接：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/</a></p><p>解题思路也同中后序一致</p><h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p>题目链接：<a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">https://leetcode.cn/problems/merge-two-binary-trees/description/</a></p><p>解题思路：</p><ol><li><strong>确定递归函数的参数和返回值：</strong></li></ol><p>首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>确定终止条件：</strong></li></ol><p>因为是传入了两个树，那么就有两个树遍历的节点t1 和 t2，如果t1 &#x3D;&#x3D; NULL 了，两个树合并就应该是 t2 了（如果t2也为NULL也无所谓，合并之后就是NULL）。</p><p>反过来如果t2 &#x3D;&#x3D; NULL，那么两个数合并就是t1（如果t1也为NULL也无所谓，合并之后就是NULL）。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t1 == <span class="literal">NULL</span>) <span class="keyword">return</span> t2; <span class="comment">// 如果t1为空，合并之后就应该是t2</span></span><br><span class="line"><span class="keyword">if</span> (t2 == <span class="literal">NULL</span>) <span class="keyword">return</span> t1; <span class="comment">// 如果t2为空，合并之后就应该是t1</span></span><br></pre></td></tr></table></figure><h2 id="AVL-平衡二叉搜索树"><a href="#AVL-平衡二叉搜索树" class="headerlink" title="AVL(平衡二叉搜索树)"></a>AVL(平衡二叉搜索树)</h2><p>AVL的插入、查询、删除、构建过程都和二叉搜索树一致，只是在失衡状态下要进行调整</p><p>AVL一个特征就是：<strong>所有结点的平衡因子(左子树高度-右子树高度)的绝对值&lt;&#x3D;1</strong></p><p>失衡状态的处理：通过旋转来让保持平衡二叉搜索树</p><p><strong>旋转操作</strong>：<a href="https://www.bilibili.com/video/BV1tZ421q72h">https://www.bilibili.com/video/BV1tZ421q72h</a></p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501203651902.png" alt="image-20240501203651902"></p><p>插入的时候只要对<strong>最近</strong>失衡的父节点进行旋转操作</p><p>删除的时候要对<strong>每个</strong>祖先检查并调整进行旋转操作</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>讲解视频：<a href="https://www.bilibili.com/video/BV1Xm421x7Lg">https://www.bilibili.com/video/BV1Xm421x7Lg</a></p><p>和AVL(平衡二叉搜索树)比较，特点在于：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501180323780.png" alt="image-20240501180323780"></p><h3 id="红黑树的特征"><a href="#红黑树的特征" class="headerlink" title="红黑树的特征"></a>红黑树的特征</h3><ol><li><strong>每个节点非红即黑</strong></li><li><strong>根节点和叶子结点是黑色的</strong></li><li><strong>每一个红色节点的子节点都是黑色的</strong></li><li><strong>任一节点到树尾端(NULL)的路径上的黑色节点数量必须相同</strong></li></ol><p>口诀：左根右、根叶黑、不红红、黑路同</p><p>红黑树的最大高度差：最长高度是最短高度的两倍，所以最大高度差也就是最长高度-最短高度 &#x3D; 最短高度</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501224935675.png" alt="image-20240501224935675"></p><p>各个节点数名称可以简单比作：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501205137332.png" alt="image-20240501205137332"></p><p>进行插入操作，其中的旋转操作和AVL是一致的：</p><p><img src="/./../images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240501205301512.png" alt="image-20240501205301512"></p><p><strong>查找、插入和删除操作</strong>：</p><p><strong>平均时间复杂度</strong>和<strong>最坏情况时间复杂度</strong>都是 𝑂(log⁡𝑛)，其中 𝑛 是树中节点的数量</p><h3 id="AVL-树和红黑树的区别"><a href="#AVL-树和红黑树的区别" class="headerlink" title="AVL 树和红黑树的区别"></a>AVL 树和红黑树的区别</h3><ol><li><p><strong>平衡条件</strong>：</p><ul><li><strong>AVL 树</strong>：AVL 树是高度平衡的。每个节点的两个子树的高度差最多为1。这使得<strong>AVL树在查找操作中表现非常好</strong>，因为它确保了树的高度尽可能低。</li><li><strong>红黑树</strong>：红黑树的平衡条件不像AVL树那样严格。红黑树通过确保没有两个连续的红节点并且从每个节点到其所有叶子节点的路径上的黑节点数相同来实现平衡。这种平衡足以<strong>保证操作的最坏时间复杂度</strong>，但允许树稍微高一些。</li></ul></li><li><p><strong>旋转操作</strong>：</p><ul><li><strong>AVL 树</strong>：为了维持严格的平衡，AVL树可能需要在每次插入或删除后进行多次旋转（最多两次）。</li><li><strong>红黑树</strong>：红黑树通常在进行插入或删除操作时需要更少的旋转操作（通常是一次或两次）。这使得红黑树在需要频繁插入和删除的应用中表现更好。</li></ul></li><li><p><strong>优劣势：</strong></p></li></ol><p>​两者优缺点各自相反</p><ul><li><strong>AVL树</strong>：<ul><li><strong>优点</strong>：由于高度平衡，对于查找密集型应用，AVL树提供了更快的查找性能。</li><li><strong>缺点</strong>：每次插入或删除可能需要更多的旋转来维持严格的平衡，这可能导致在更新操作（插入和删除）频繁的场景下性能下降。</li></ul></li><li><strong>红黑树</strong>：<ul><li><strong>优点</strong>：虽然平衡不如AVL树严格，但由于维护这种平衡的成本较低（旋转操作较少），红黑树在实际的增删操作中更为高效。</li><li><strong>缺点</strong>：相较于AVL树，查找操作可能稍慢，因为树的高度可能略高。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（二）</title>
      <link href="/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h1><p>定义：是只允许在一端进行插入或删除的<strong>线性表</strong>。限定这种线性表只能在某一端进行插入和删除操作</p><p><strong>特点：后进先出</strong></p><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><p>根据选用不同的存储结构来构建不同的栈</p><ul><li>顺序栈</li><li>链栈</li><li>共享栈</li></ul><h2 id="栈的常用操作"><a href="#栈的常用操作" class="headerlink" title="栈的常用操作"></a>栈的常用操作</h2><ul><li>InitStack：初始化一个空栈</li><li>StackEmpty:  判断一个栈是否为空</li><li>Push：进栈</li><li>Pop：出栈</li><li>GetTop：读取栈顶元素</li><li>DestoryStack：销毁栈，释放栈占用的存储空间</li></ul><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列(Queue)"></a>队列(Queue)</h1><p> 定义：队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的<strong>线性表</strong></p><p><strong>特点：先进先出</strong></p><h2 id="种类-1"><a href="#种类-1" class="headerlink" title="种类"></a>种类</h2><ul><li>顺序队列</li><li>循环队列</li><li>链队列</li><li>双端队列</li></ul><h2 id="队列的常用操作"><a href="#队列的常用操作" class="headerlink" title="队列的常用操作"></a>队列的常用操作</h2><ul><li>isEmpty：判断队列是否为空</li><li>isFull: 判断队列是否已满</li><li>add：入队</li><li>poll：出队</li><li>peek：返回队头元素</li></ul><h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] element;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> front,rear;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">32</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        size = n;</span><br><span class="line">        element = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否已满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == size-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            size = size*<span class="number">2</span>;</span><br><span class="line">            element = Arrays.copyOf(element,size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (front==-<span class="number">1</span>)</span><br><span class="line">            front++;</span><br><span class="line">        rear++;</span><br><span class="line">        element[rear] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (front==rear-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(peek());</span><br><span class="line">        front++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队头元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> element[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询队列所有内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front;i&lt;=rear;i++)&#123;</span><br><span class="line">            System.out.println(element[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><p>结点类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    Node rear,front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.rear = <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.front = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队(尾插法)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">null</span>)&#123;</span><br><span class="line">            front = rear = node;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            rear.next = node;</span><br><span class="line">            rear = rear.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(peek());</span><br><span class="line">        front = front.next;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历队列内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">this</span>.size;i++)&#123;</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2022/11/07/first/"/>
      <url>/2022/11/07/first/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构(一)</title>
      <link href="/2022/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/10/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><p>定义：零个或多个数据元素的有限序列</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>线性表的存储结构分为：</p><ul><li>顺序存储</li><li>链式存储</li></ul><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>特点：逻辑上相邻的数据元素，其物理次序也是相邻的</p><p><strong>顺序表的构造与设计：</strong></p><p>SeqList<T>顺序表必有<strong>两个成员变量</strong>，一个数组存放数据，一个表示顺序表元素个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] element;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeqList</span><span class="params">()</span>&#123;<span class="built_in">this</span>&#123;<span class="number">10</span>&#125;;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>增添数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.element[n++] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在指定位置增添元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> i，<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;<span class="built_in">this</span>.element.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//数组下标不合法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不合法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">this</span>.element.length-<span class="number">1</span>;j&gt;index;j--)&#123;</span><br><span class="line">        element[j] = element[j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    element[index] = i;</span><br><span class="line">    <span class="built_in">this</span>.n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定下标的元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleate</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=index;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            element[i] = element[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找对应元素并返回对应下标</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> t)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (element[i]==t)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><strong>特点：</strong>单链表<strong>不要求</strong>逻辑上相邻的两个元素在物理位置上也相邻，因此<strong>不需要</strong>连续的存储空间。<strong>查找某个特定的结点时，需要从表头开始遍历，依次查找</strong></p><p>链表设计习题(LeetCode707)：<a href="https://leetcode.cn/problems/design-linked-list/">https://leetcode.cn/problems/design-linked-list/</a></p><p>结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;<span class="comment">//存放数值</span></span><br><span class="line">    Node next;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span>&#123;</span><br><span class="line">    Node head;<span class="comment">//虚拟头结点</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//长度</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span>&#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=index;i++)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> cur.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加数据(重点)：</strong></p><p>需求—-</p><p>在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点</p><ul><li>头插法</li><li>尾插法</li><li>第n个结点前插入</li></ul><p><strong>头插法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atTail</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line"> <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node.next = head;</span><br><span class="line">        head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>尾插法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atEnd</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第n个结点插入法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atIndex</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">       <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">           atTail(val);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="built_in">this</span>.size)&#123;</span><br><span class="line">           atEnd(val);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">           node.next = cur.next;</span><br><span class="line">           cur.next = node;</span><br><span class="line">           size++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">if</span> (n&lt;<span class="number">0</span>||n&gt;<span class="built_in">this</span>.size)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">               cur = cur.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       cur.next = cur.next.next;</span><br><span class="line">       <span class="built_in">this</span>.size--;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h4><p> 逻辑结构上相邻的数据元素，存储在<em>指定的一块内存空间</em>中，数据元素只允许在这块内存空间中随机存放，这样的存储结构生成的链表称为<strong>静态链表</strong></p><p><strong>(静态链表是用<em>数组</em>来实现链式存储结构)</strong></p><p><strong>特点：</strong>删除和插入元素时间复杂度低(同链表)，不足点是需要提前分配一块较大的空间(同数组)</p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/29/hello-world/"/>
      <url>/2022/10/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
